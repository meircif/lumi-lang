~~~ TL5 compiler - Operators ~~~
module tl5-compiler


struct Operator
    owner String name
    owner String c-name
    var Int precedence
    var Int group-index
    var Func{(user SyntaxTreeCode code-node, user Operator operator)->(
            owner UnaryExpression expression)} unary-expression-factory
    var Func{(user SyntaxTreeCode code-node, user Operator operator)->(
            owner BinaryExpression expression)} binary-expression-factory

    func new(
            user String name,
            user String c-name,
            copy Int precedence,
            copy Int group-index,
            copy Func{(user SyntaxTreeCode code-node, user Operator operator)->(
            owner UnaryExpression expression)} unary-expression-factory,
            copy Func{(user SyntaxTreeCode code-node, user Operator operator)->(
            owner BinaryExpression expression)} binary-expression-factory)
        string-new-copy(user name)->(owner self.name)
        string-new-copy(user c-name)->(owner self.c-name)
        self.precedence := precedence
        self.group-index := group-index
        self.unary-expression-factory := unary-expression-factory
        self.binary-expression-factory := binary-expression-factory

    func create-unary-expression(user SyntaxTreeCode code-node)->(
            owner UnaryExpression expression)
        if not self.unary-expression-factory?
            code-node.syntax-error(
                    user "used non-unary operator", user self.name)
        self.unary-expression-factory(user code-node, user self)->(
                owner expression)

    func create-binary-expression(user SyntaxTreeCode code-node)->(
            owner BinaryExpression expression)
        if not self.binary-expression-factory?
            code-node.syntax-error(
                    user "used non-binary operator", user self.name)
        self.binary-expression-factory(user code-node, user self)->(
                owner expression)


~~~ not ~~~
class NotOperatorExpression(UnaryExpression)
    func dynamic analyze()
        base()
        self.test-operand-type(
                user self.right-expression, user glob.type-bool)
        self.set-simple-type(user glob.type-bool)

func not-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner UnaryExpression expression)
    expression := NotOperatorExpression(user code-node, user operator)


func set-int-type(user UnaryExpression self, copy Int bits)
    var String{8} uint-name(user "Uint")
    if bits >= 10
        uint-name.append(copy '0' + (bits div 10))
    uint-name.append(copy '0' + (bits mod 10))
    self.set-simple-type(user glob.type-int)
    string-new-copy(user uint-name)->(owner self.result-type.name)
    self.result-type.set-int-range()

func check-not-signed(user UnaryExpression self, user Expression expression)
    if expression.result-type.int-range.is-signed
        self.syntax-error-long(
                user "bitwize operation on signed integer with minimum \
                value of",
                user expression.result-type.int-range.min-value)


~~~ bnot ~~~
class BitwizeNotOperatorExpression(UnaryExpression)
    func dynamic analyze()
        base()
        self.test-operand-type(
                user self.right-expression, user glob.type-int)
        check-not-signed(user self, user self.right-expression)
        set-int-type(
                user self,
                copy self.right-expression.result-type.int-range.bits)

    func dynamic write()
        write(user "(")
        self.result-type.write-cname()
        write(user ")(")
        base()
        write(user ")")

func bitwize-not-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner UnaryExpression expression)
    expression := BitwizeNotOperatorExpression(user code-node, user operator)


~~~ - (unary) ~~~
class NegationOperatorExpression(UnaryExpression)
    func dynamic analyze()
        base()
        self.test-operand-type(user self.right-expression, user glob.type-int)
        self.set-simple-type(user glob.type-int)
        self.result-type.int-range := IntRange()
        self.right-expression.result-type.int-range.max-value.copy()->(
                owner self.result-type.int-range.min-value)
        self.right-expression.result-type.int-range.min-value.copy()->(
                owner self.result-type.int-range.max-value)
        self.result-type.int-range.min-value.negate()
        self.result-type.int-range.max-value.negate()
        self.result-type.int-range.set-sign-and-bits()

func negation-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner UnaryExpression expression)
    expression := NegationOperatorExpression(user code-node, user operator)


~~~ clamp ~~~
class ClampOperatorExpression(UnaryExpression)
    var Bool is-check
    var Bool check-min
    var Bool check-max
    
    new(
            user SyntaxTreeCode code-node,
            user Operator operator,
            copy Bool is-check,
            copy Bool error-expected)
        base(user code-node, user operator)
        self.is-check := is-check
        self.error-expected := error-expected
        self.error-propagated := error-expected
    
    func dynamic analyze()
        if not self.result-type?
            self.syntax-error(user "misplaced use of", user "clamp")
        base()
        self.test-operand-type(user self.right-expression, user glob.type-int)
        user IntRange source(user self.right-expression.result-type.int-range)
        user IntRange target(user self.result-type.int-range)
        long-larger(user target.min-value, user source.min-value)->(
                var self.check-min)
        long-larger(user source.max-value, user target.max-value)->(
                var self.check-max)
        if not self.check-min and not self.check-max
            self.syntax-error(user "unnecessary use of", user "clamp")
        self.result-type.type-data := glob.type-int
        if self.error-propagated
            self.check-error-propagated(user _)
        else-if self.is-check
            if self.code-node.set-has-error()
                self.syntax-error-msg(
                        user "using \"?\" where error is propagated")

    func dynamic write-preactions()
        base()
        if not self.is-check
            return
        ; if (`exp` < `min` || `exp` > `max`) RAISE(`integer_overflow`)
        write(user "if (")
        if self.check-min
            self.right-expression.write-safe()
            write(user " < ")
            write-long(user self.result-type.int-range.min-value)
        if self.check-max
            if self.check-min
                write(user " || ")
            self.right-expression.write-safe()
            write(user " > ")
            write-long(user self.result-type.int-range.max-value)
        write(user ") ")
        self.code-node.write-raise(user "integer_overflow")
        self.code-node.write-spaces()

    func dynamic write()
        if self.is-check
            self.right-expression.write()
            return
        ; (`exp` < `min`)? `min`: ((`exp` > `max`)? `max`: `exp`)
        if self.check-min
            self.write-clamp(
                    user " < ", user self.result-type.int-range.min-value)
        if self.check-max
            if self.check-min
                write(user "(")
            self.write-clamp(
                    user " > ", user self.result-type.int-range.max-value)
        self.right-expression.write-safe()
        if self.check-min and self.check-max
            write(user ")")
    
    func inst write-clamp(user String compare, user Long value)
        write(user "(")
        self.right-expression.write-safe()
        write(user compare)
        write-long(user value)
        write(user ")? ")
        write-long(user value)
        write(user ": ")

func clamp-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner UnaryExpression expression)
    var Bool error-expected(copy glob.last-char = '!')
    var Bool is-check(copy glob.last-char = '?' or error-expected)
    if is-check
        read-c()
    expression := ClampOperatorExpression(
            user code-node, user operator, copy is-check, copy error-expected)


class BitwizeOperatorExpression(BinaryExpression)
    func dynamic analyze()
        base()
        self.test-operands-type(user glob.type-int)
        check-not-signed(user self, user self.left-expression)
        check-not-signed(user self, user self.right-expression)
        set-int-type(user self, copy self.get-result-bits())
    
    func dynamic get-result-bits()->(var Int bits)
        if self.right-expression.result-type.int-range.bits >
                self.left-expression.result-type.int-range.bits
            bits := self.right-expression.result-type.int-range.bits
        else
            bits := self.left-expression.result-type.int-range.bits
        
func bitwize-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression := BitwizeOperatorExpression(user code-node, user operator)


class ShiftOperatorExpression(BitwizeOperatorExpression)
    func dynamic get-result-bits()->(var Int bits)
        bits := self.left-expression.result-type.int-range.bits
        
func shift-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression := ShiftOperatorExpression(user code-node, user operator)
        
        
class ArithmeticOperatorExpression(BinaryExpression)
    func dynamic analyze()
        base()
        self.test-operands-type(user glob.type-int)
        self.set-simple-type(user glob.type-int)
        self.result-type.int-range := IntRange()
        self.set-range(
                user self.result-type.int-range,
                user self.left-expression.result-type.int-range.min-value,
                user self.left-expression.result-type.int-range.max-value,
                user self.right-expression.result-type.int-range.min-value,
                user self.right-expression.result-type.int-range.max-value)
        self.result-type.int-range.set-sign-and-bits()
    
    func dynamic set-range(
            user IntRange int-range,
            user Long left-min,
            user Long left-max,
            user Long right-min,
            user Long right-max)
        raise


~~~ + ~~~
class AdditionOperatorExpression(ArithmeticOperatorExpression)
    func dynamic set-range(
            user IntRange int-range,
            user Long left-min,
            user Long left-max,
            user Long right-min,
            user Long right-max)
        long-add(user left-min, user right-min)->(owner int-range.min-value)
        long-add(user left-max, user right-max)->(owner int-range.max-value)

func addition-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression := AdditionOperatorExpression(user code-node, user operator)

~~~ - ~~~
class SubtractionOperatorExpression(ArithmeticOperatorExpression)
    func dynamic set-range(
            user IntRange int-range,
            user Long left-min,
            user Long left-max,
            user Long right-min,
            user Long right-max)
        long-sub(user left-min, user right-max)->(owner int-range.min-value)
        long-sub(user left-max, user right-min)->(owner int-range.max-value)

func subtraction-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression := SubtractionOperatorExpression(user code-node, user operator)

~~~ * ~~~
class MultiplicationOperatorExpression(ArithmeticOperatorExpression)
    func dynamic set-range(
            user IntRange int-range,
            user Long left-min,
            user Long left-max,
            user Long right-min,
            user Long right-max)
        long-mul(user left-min, user right-min)->(owner int-range.min-value)
        int-range.min-value.copy()->(owner int-range.max-value)
        self.limit-candidate(user int-range, user left-min, user right-max)
        self.limit-candidate(user int-range, user left-max, user right-min)
        self.limit-candidate(user int-range, user left-max, user right-max)
    
    func inst limit-candidate(
            user IntRange int-range, user Long a, user Long b)
        owner Long mul
        long-mul(user a, user b)->(owner mul)
        if long-larger(user int-range.min-value, user mul)
            int-range.min-value := mul
        else-if long-larger(user mul, user int-range.max-value)
            int-range.max-value := mul

func multiplication-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression :=
            MultiplicationOperatorExpression(user code-node, user operator)

~~~ div ~~~
class DivisionOperatorExpression(ArithmeticOperatorExpression)
    var Bool zero-check
    
    func dynamic set-range(
            user IntRange int-range,
            user Long left-min,
            user Long left-max,
            user Long right-min,
            user Long right-max)
        if right-min.sign() = 0
            left-max.copy()->(owner int-range.max-value)
        else
            long-div(user left-max, user right-min)->(owner int-range.max-value)
        long-div(user left-min, user right-max)->(owner int-range.min-value)
    
    func dynamic analyze()
        self.allow-right-error := true
        base()
        self.check-not-signed(user self.left-expression)
        self.check-not-signed(user self.right-expression)
        user IntRange right-int-range(
                user self.right-expression.result-type.int-range)
        if right-int-range.max-value.sign() = 0
            self.syntax-error-msg(user "dividing by zero")
        self.zero-check := right-int-range.min-value.sign() = 0
        if self.zero-check
            self.right-expression.check-error-propagated(
                    user "ignoring zero division check")
        else
            self.right-expression.check-no-error()
                
    func inst check-not-signed(user Expression expression)
        if expression.result-type.int-range.is-signed
            self.syntax-error-long(
                    user "division operation on signed integer with minimum \
                    value of",
                    user expression.result-type.int-range.min-value)

    func dynamic write-preactions()
        base()
        if not self.zero-check
            return
        ; if (`right` == 0) RAISE(`line`, `cleanup`, zero_division)
        write(user "if (")
        self.right-expression.write()
        write(user " == 0) ")
        self.code-node.write-raise(user "zero_division")
        self.code-node.write-spaces()

func division-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression := DivisionOperatorExpression(user code-node, user operator)

~~~ mod ~~~
class ModuloOperatorExpression(DivisionOperatorExpression)
    func dynamic set-range(
            user IntRange int-range,
            user Long left-min,
            user Long left-max,
            user Long right-min,
            user Long right-max)
        if long-equal(user left-min, user left-max) and
                long-equal(user right-min, user right-max)
            long-mod(user left-min, user right-min)->(owner int-range.min-value)
            int-range.min-value.copy()->(owner int-range.max-value)
        else
            var Long one
            one.set(copy 1)
            int-range.min-value := Long()
            long-sub(user right-max, user one)->(owner int-range.max-value)

func modulo-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression := ModuloOperatorExpression(user code-node, user operator)


~~~ > < >= <= ~~~
class RelationalOperatorExpression(BinaryExpression)
    ~~~ expand-and: (a > b) > c --> (a > b) && (b > c) ~~~
    var Bool expand-and

    func dynamic analyze()
        base()
        if self.binary-left-expression?
            self.binary-left-expression.is-relational()->(var self.expand-and)
        self.test-operand(user self.right-expression)
        if not self.expand-and
            self.test-operand(user self.left-expression)
        self.set-simple-type(user glob.type-bool)

    func dynamic is-relational()->(var Bool is-relational)
        is-relational := true

    func dynamic test-operand(user Expression operand)
        self.test-operand-type(user operand, user glob.type-int)

    func dynamic write-end()
        if self.expand-and
            write(user "&& (")
            self.binary-left-expression.right-expression.write()
            write(user " ")
        base()
        if self.expand-and
            write(user ")")

func relational-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression := RelationalOperatorExpression(user code-node, user operator)


~~~ = != ~~~
class EqualizerOperatorExpression(RelationalOperatorExpression)
    func dynamic test-operand(user Expression operand)
        self.test-is-reference(copy false, user operand)

func equalizer-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression := EqualizerOperatorExpression(user code-node, user operator)


~~~ is is-not ~~~
class IdentityOperatorExpression(BinaryExpression)
    func dynamic analyze()
        base()
        self.test-is-reference(copy true, user self.right-expression)
        self.test-is-reference(copy true, user self.left-expression)
        self.set-simple-type(user glob.type-bool)
        self.safe-operand-write := false

    func dynamic write()
        write(user "(void*)")
        base()

func identity-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression := IdentityOperatorExpression(user code-node, user operator)


~~~ or and ~~~
class LogicalOperatorExpression(BinaryExpression)
    func dynamic analyze()
        base()
        self.test-operands-type(user glob.type-bool)
        self.set-simple-type(user glob.type-bool)


func logical-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression := LogicalOperatorExpression(user code-node, user operator)


~~~ += -= *= ~~~
class ArithmeticAssignOperatorExpression(BinaryExpression)
    func dynamic analyze-right-and-all()
        base()
        if not self.left-expression.assignable
            self.syntax-error-msg(
                    user "assigning into non assignable expression")
        self.analyze-assignment()
        self.safe-operand-write := false
        self.result-type := _

    func dynamic analyze-assignment()
        self.test-operands-type(user glob.type-int)

func arithmetic-assign-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression :=
            ArithmeticAssignOperatorExpression(user code-node, user operator)


~~~ := ~~~
class AssignOperatorExpression(ArithmeticAssignOperatorExpression)
    var AssignExpression assign
    
    func dynamic analyze()
        self.analyze-operand()->(owner self.left-expression)
        self.left-expression.result-type.set-expected-type()->(
                owner self.right-expression.result-type)
        self.analyze-right-and-all()

    new(user SyntaxTreeCode code-node, user Operator operator)
        base(user code-node, user operator)
        self.allow-right-error := true

    func dynamic analyze-assignment()
        self.assign.new(
                user self.code-node,
                user self.left-expression,
                user self.right-expression,
                copy false)
        self.assign.analyze-value()->(owner self.right-expression)

    func dynamic check-memory(user ReferenceMemoryList refs)
        self.assign.check-memory(user refs)

    func dynamic write-preactions()
        self.assign.write-preactions()

    func dynamic write-end()
        if access-is-owner(copy self.left-expression.access)
            self.write-end-expression(user self.assign.value)
            self.assign.write-owner-null()
        else
            base()

func assign-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression := AssignOperatorExpression(user code-node, user operator)


~~~ :=: ~~~
class SwapOperatorExpression(BinaryExpression)
    var AssignExpression assign-left-to-aux
    var AssignExpression assign-right-to-left
    var AssignExpression assign-aux-to-right
    owner Expression aux-variable

    func dynamic analyze()
        base()
        if not self.left-expression.assignable or
                not self.right-expression.assignable
            self.syntax-error-msg(user "swapping non assignable expression")
        self.code-node.add-aux-variable(
                copy self.left-expression.access,
                copy false,
                user self.left-expression.result-type)->(
                owner self.aux-variable)
        self.assign-left-to-aux.new(
                user self.code-node,
                user self.aux-variable,
                user self.left-expression,
                copy false)
        self.assign-right-to-left.new(
                user self.code-node,
                user self.left-expression,
                user self.right-expression,
                copy false)
        self.assign-aux-to-right.new(
                user self.code-node,
                user self.right-expression,
                user self.aux-variable,
                copy false)
        self.left-expression.result-type.check-equal(
                user self.right-expression.result-type, user self.code-node)
        if self.left-expression.access != self.right-expression.access
            self.syntax-error2(
                    user "cannot swap access",
                    user glob.access-names[self.left-expression.access],
                    user "with other access",
                    user glob.access-names[self.right-expression.access])
        if self.left-expression.result-type.reference-path.equals(
                user self.right-expression.result-type.reference-path)
            self.syntax-error-msg(user "swapping reference with itself")


    func dynamic check-memory(user ReferenceMemoryList refs)
        if access-is-temp(copy self.left-expression.access)
            refs.check-writing-memory(user self.left-expression)
            refs.check-writing-memory(user self.right-expression)
        else
            self.left-expression.check-memory(user refs)
            self.right-expression.check-memory(user refs)

    func dynamic write()
        self.assign-left-to-aux.write-assign()
        self.code-node.write-spaces()
        self.assign-right-to-left.write-assign()
        self.code-node.write-spaces()
        self.assign-aux-to-right.write-assign()
        if not self.right-expression.result-type.type-data.is-primitive
            self.code-node.write-spaces()
            self.aux-variable.write-assign-null()

func swap-operator-factory(
        user SyntaxTreeCode code-node, user Operator operator)->(
        owner BinaryExpression expression)
    expression := SwapOperatorExpression(user code-node, user operator)
