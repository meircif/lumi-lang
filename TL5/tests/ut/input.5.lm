struct Test
    var Int num
    weak Test? t
    var Func?{()} fun
    func user? meth()
class Ta(Test)
    var Int numa
    func inst user? metha()
    func dynamic user? dyn()
class Tb(Ta)
    var Int numb
    new!(copy Int num)
    func inst user? methb()
    func dynamic user? dyn()
class Tc(Tb)
    var Int numc
    func inst user? methc()
    func dynamic user? dyn()
struct Data{Generic}
    weak Generic? item
    func user? set(owner Generic? item)
    func user? get()->(weak Generic? item)

func fun0()
func fun1(copy Int x, user String? s, owner String? o)
func fun2()->(strong String? s, var Int x)
func fun3(copy Int x)->(strong String? s)
func fun4(copy Int x)
func fun5(copy Int x)->(var Int y)
func fun6(copy Int x, copy Int y)->(var Int n, var Int m)
func fun7(weak Tb? tb)->(weak Tb? tbo)
func fun8(strong String? s)
func ! fune()

var Int i
var Byte bt
var Char c
var Bool b
user String? str
owner String? ostr
weak Array?{Int} arr
owner File? fobj
weak Test? t
weak Ta? ta
strong Tb? tb
weak Tc? tc
weak Data?{Test} d
weak Array?{String} sarr

func ! mock()->(strong String? so, var Int io, strong Test? to, weak Tc? tco)
; @@ test-int-expression
; @ c t0
i := 0
; @ c t1
i := 9630
; @ c t2
i := -9630
; @ c t3
i := 07520
; @ c t4
i := -07520
; @ c t5
i := 0xfda940
; @ c t6
i := -0xfda940
; @ c t7
i := 0xFDA940
; @ c t8
i := -0xFDA940
; @ c t9
i := 0b100101
; @ c t10
i := -0b100101
; @ ec te0
2a
; @ ec te1
0a
; @ ec te2
038
; @ ec te3
0b021
; @ ec te4
0xadg
; @@ test-byte-expression
; @ c t0
bt := 0
; @ c t1
bt := 127
; @ c t2
bt := 075
; @ c t3
bt := 0xfd
; @ c t4
bt := 0xFD
; @ c t5
bt := 0b10010100
; @@ test-char-expression
; @ c t0
c := 'a'
; @ c t1
c := '\''
; @ c t2
c := '\n'
; @ c t3
c := '\x0f'
; @ c t4
c := '\xA9'
; @ c t5
c := '\270'
; @ fec te0
c := '''
; @ fec te1
c := '\'
; @ fec te2
c := 'aa
; @ ec te3
c := '\c'
; @ ec te4
c := 'aaaa'
; @ ec te5
c := '\x6g'
; @ ec te6
c := '\058'
; @ ec te7
c := ''
; @ ec te8
c := 'aa'
; @ ec te9
c := 'aaa'
; @ ec te10
c := 'aaaaa'
; @@ test-string-expression
; @ c t0
str := "some string"
; @ c t1
str := "\nstring\t\"with\\formatting\n"
; @ c t2
str := "line\
        split\
        string\
        "
; @ c t3
str := "multi
        line
        string
        "
; @ c t4
str := "line\
         split"
; @ fec te0
str := "aaa
; @ fec te1
str := "
; @ ec te2
"error"+"string"
; @ ec te3
str := "indention
    too short"
; @ ec te4
str := "indention\
    too short"
; @@ test-empty-expression
; @ c t0
str := _
; @ c t1
t := _
; @ c t2
so := _
; @ c t3
b := t is _ or ta is-not _
; @ ec te0
i := _
; @@ test-member-expression
; @ c t0
i := t!.num
; @ c t1
i := tc!.numb
; @ c t2
i := tc!.num
; @ c t3
i := to!.num
; @ c t4
tco := tc
i := tco!.num
; @ c t5
i := t!.t!.num
; @ c t6
i := t!.t!.t!.num
; @ ec te0
error
; @ ec te1
(i := 1).error
; @ ec te2
t.error
; @ ec te3
5.error
; @@ test-slice-expression
; @ c t0
c := ostr![13]!
; @ c t1
user Array?{Char} x
x := ostr![2:6]!
; @ c t2
i := arr![13]!
; @ c t3
user Array?{Int} x
x := arr![2:i]!
; @ c t4
ostr![4]! := c
; @ c t5
arr![4]! := i
; @ c t6
strong Array?{Test} tarr
t := tarr![3]!
; @ c t7
var Array{8:String{5}} vsa
user String s(user vsa[3])
user Array{String} sa(user vsa[2:4])
; @ g t8
func ! fun(s-var String s, strong Array{String} sa)
    var Char c(copy s[5]!)
    user Array{Char} part(user s[4:2]!)
    user String si(user sa[3]!)
; @ c t9
strong Array?{String} sa
sa![3]!.copy(user "text")!
sa := _
; @ c t10
strong Array?{Array{Int}} aai
arr := aai![3]!
weak Array?{Array{Int}} ua(weak aai![2:4]!)
; @ c t11
strong Array?{Array{Array{Array{Int}}}} aai
weak Array?{Array{Array{Int}}} ua(weak aai![3]!)
weak Array?{Array{Array{Array{Int}}}} uaa(weak aai![2:4]!)
; @ c t12
strong Array?{Array{Array{String}}} aas
weak Array?{Array{String}} ua(weak aas![3]!)
weak Array?{Array{Array{String}}} uaa(weak aas![2:4]!)
aas := _
; @ c t13
var Array{8:Array{7:Array{6:Array{5:Int}}}} aai
user Array?{Array{Array{Int}}} ua(user aai[3])
user Array?{Array{Array{Array{Int}}}} uaa(user aai[2:4])
; @ c t14
var Array{8:Array{7:Array{6:String{5}}}} aas
user Array?{Array{String}} ua(user aas[i]!)
user Array?{Array{Array{String}}} uaa(user aas[2:4])
; @ g t15
func fun()
    var Array{8:Array{7:Array{6:String{5}}}} aas
    user String s(user aas[4][3][2])
; @ c t16
user Array?{Char} x
x := ostr
; @ c t17
new String{12} s!
sys.print(user s)!
; @ g t18
struct Test
    owner String? s
func fun()
    var Test t
    var Array{6:Test} a
; @ ec te0
arr[2
; @ ec te1
arr[2:3
; @ ec te2
(i := 3)[2]!
; @ ec te3
i[2]!
; @ ec te4
arr![str]!
; @ ec te5
arr![3:str]!
; @ ec te6
arr![i += 3]!
; @ ec te7
str![2:5]! := so
; @ ec te8
arr![7:2]! := Array{5:Int}()!
; @ ec te9
user Array?{Test} at
at![0] := t
; @ ec te10
so := sarr![3]!
; @ ec te11
var Array{3:Tc} error
; @ eg te12
struct Test
    var Int x
    new()
func func(user Array{Test} error)
; @ ec te13
i := arr![i]
; @ ec te14
var Array{0:Int} error
; @ ec te15
arr![-1]
; @ ec te16
arr![1:0]
; @ ec te17
s-var Array{3:Int} a!
arr := a[1:3]
; @@ test-call-expression
; @ c t0
fun0()
; @ c t1
fun1(copy 3, user ostr, owner _)
; @ c t2
fun2()->(strong so, var io)
; @ c t3
var Int x
strong String? s
fun2()->(strong s, var x)
; @ c t4
fun3(copy 0)->(strong so)
; @ c t5
var Int x
fun4(copy fun5(copy 3)->(var x))
; @ c t6
fun6(
        copy 2,
        copy 3)->(
        var io,
        var io)
; @ c t7
fun5(copy 4)
; @ c t8
io := fun5(copy 4)
; @ c t9
so := fun3(copy 7)
; @ c t10
t!.meth()
; @ c t11
to.meth()
; @ c t12
tc!.methc()
; @ c t13
tc!.methb()
; @ c t14
tc!.meth()
; @ c t15
tco := tc
tco!.meth()
; @ c t16
t!.t!.meth()
; @ c t17
fun1(copy 3, user ostr, owner so)
; @ c t18
fun3(copy 1)
fun5(copy 2)
; @ g t19
class Base
    var Int x
    func dynamic user ! meth(owner Base b)
class Test(Base)
    func dynamic user ! meth(owner Base b)
        new Test t!
        base(owner t)!
; @ g t20
class Test
    var Int x
    func dynamic user meth()
func ! mock()->(weak Test? t)
    mock()->(weak t)!.meth()
; @ g t21
class Test
    var Int x
    func dynamic user ! meth()->(weak Test? t)
        self.meth()!.meth()!
; @ g t22
func fun()->(owner Array?{String} astr)
    fun()->(owner astr)
; @ g t23
func ! fun(var String s)
    var String{12} vars
    s-var String{12} s-vars!
    owner String owners(owner String{12}()!)
    strong String strongs(strong String{12}()!)
    user String users(user s)
    fun(var s)!
    fun(var vars)!
    fun(var s-vars)!
    fun(var owners)!
    fun(var strongs)!
    s.clear()
; @ c t24
strong String? s
weak String? sw
fun1(copy 0, user sw!, owner s)
; @ c t25
fun8(strong ostr)
; @ c t26
fune()!
; @ ec te0
function( copy 1)
; @ ec te1
function(user)
; @ ec te2
function(copy 4,copy 3)
; @ ec te3
function(copy 2
; @ ec te4
function(error 4)
; @ ec te5
(i := 0)()
; @ ec te6
i()
; @ ec te7
fun5(copy 0)->(var 4)
; @ ec te8
fun7(weak _)->(weak tc)
; @ ec te9
fun5(copy i := 1)
; @ ec te10
fun5(user 8)
; @ ec te11
fun1(copy 3, user str, owner str)
; @ ec te12
fun3(copy 3)->(strong str)
; @ ec te13
fun7(weak _)->(weak tb)
; @ ec te14
fun0(copy i)
; @ ec te15
fun1()
; @ ec te16
fun0()->(copy i)
; @ ec te17
fun2()
; @ eg te18
struct Base
    var Int x
    func user meth(owner Base b)
struct Test(Base)
    func user meth(owner Test t)
        base(owner t)
; @ ec te19
var String{16} text
fun1(copy 3, user str, owner text)
; @ ec te20
owner Tb? tbo
fun7(weak tbo)
; @ ec te21
fune()
; @ eg te22
func ! fune()
func fun()
    fune()!
; @@ test-type-expression
; @ c t0
Test.meth(user t!)
; @ c t1
Tb.methb(user tc!)
; @ c t2
Tc.meth(user tc!)
; @ ec t3
Error
; @@ test-base-expression
; @ g t0
struct Base
    var Int x
    func user methb()
struct Mid(Base)
    func user methm()
struct Top(Mid)
    func user methb()
    func user methm()
        base.methm()
; @ g t1
struct Base
    var Int x
    func user methb()
struct Mid(Base)
    func user methm()
struct Top(Mid)
    func user methb()
    func user methm()
        base.methb()
; @ ec te0
base
; @ eg te1
struct Test
    var Int x
    func user mock()
        base
; @ eg te2
struct Base
    var Int x
struct Test(Base)
    var Int x
    func user mock()
        base()
; @ eg te3
struct Base
    var Int x
struct Test(Base)
    func user mock()
        base := self
; @ eg te4
struct Base
    var Int x
struct Test(Base)
    func user mock()->(var Int x)
        x := base.x
; @@ test-block-expression
; @ c t0
i := 2 + (123)
; @ c t1
i := (123)
; @ c t2
i := (123 * (i - 4)) + 2
; @ ec t3
(error
; @@ test-unary-expression
; @ c t0
i := - i
; @ c t1
i := -
        i
; @ c t2
i := - - i
; @ c t3
b := not b
; @ c t4
b := not i > 3
; @ ec t5
{45}
; @ ec t6
-[
; @ ec t7
+ 2
; @ ec t8
- (i := 2)
; @ ec t9
- (i > 4)
; @ ec t10
not i
; @@ test-binary-expression
; @ c t0
i := 23 + 54
; @ c t1
i += (100 * 2) - 37
i *= 3
; @ c t2
i -= 12 *
        13
; @ c t3
b := 3 < 5 or 23 > 37
; @ c t4
b := 3 <= 5 and 23 >= 37
; @ c t5
b := i = 5 or i <> 37
; @ c t6
b := 2 < i < 12 = 2 * i
; @ c t7
t := tc
; @ c t8
owner String? s
s := so
; @ c t9
str := so
; @ c t10
b := t is ta or tc is-not tb
; @ c t11
c := '0' + 4
; @ c t12
b := fun0 is-not fun1
; @ c t13
b := b = b
; @ c t14
owner Tc? otc
tb := otc!
; @ c t15
owner Array?{Test} otarr
otarr := _
; @ c t16
io := (60 div i!) + (60 mod i!)
; @ c t17
i := i bor 8
; @ c t18
i := i band 10
; @ c t19
i := bnot i
; @ c t20
i := i xor 16
; @ c t21
i := i shr 2
; @ c t22
i := i shl 1
; @ ec te0
345 @ 2
; @ ec te1
80 +(
; @ ec te2
1 + 2 * 3
; @ ec te3
1 < i or 2 < i and 3 < i
; @ ec te4
1 not 2
; @ ec te5
1 := 2
; @ ec te6
1 += 2
; @ ec te7
1 -= 2
; @ ec te8
so := str
; @ ec te9
b := 1 or 2
; @ ec te10
b := t > 3
; @ ec te11
b := 1 > 4 > t
; @ ec te12
i := 3 + t
; @ ec te13
t += 3
; @ ec te14
i -= b
; @ ec te15
b := 3 is t
; @ ec te16
user Array?{Char} ca
ca := arr!
; @ ec te17
owner Test? ot
ot := tb
; @ ec te18
b := b is b
; @ ec te19
b := t is t < 2
; @ ec te20
user Test? tu
t := tu
; @ ec te21
var Test tv
user Test tu(user tv)
tu := t
; @ ec te22
io := 60 div i
; @ ec te23
io := 60 mod i
; @ ec te24
io := 60 div 0
; @ ec te25
io := 60 mod 0
; @@ test-swap-expression
; @ c t0
new Test t1!
new Test t2!
t1 :=: t2
; @ c t1
strong Test t1(strong to!)
strong Test t2(strong to!)
t1 :=: t2
; @ c t2
new Tc t1(copy 1)!
new Tc t2(copy 2)!
t1 :=: t2
; @ c t3
strong Tc t1(strong Tc(copy 1)!)
strong Tc t2(strong Tc(copy 2)!)
t1 :=: t2
; @ c t4
new Array{4:Int} a1!
new Array{6:Int} a2!
a1 :=: a2
; @ c t5
strong Array{Int} a1(strong Array{4:Int}()!)
strong Array{Int} a2(strong Array{6:Int}()!)
a1 :=: a2
; @ c t6
new String{4} s1!
new String{6} s2!
s1 :=: s2
; @ c t7
strong String s1(strong String{4}()!)
strong String s2(strong String{6}()!)
s1 :=: s2
; @ g t8
struct Test
    owner File f
    new(owner File f)
        self.f := f
func fun(owner Test t1, owner Test t2)
    t1.f :=: t2.f
; @ c t9
user Test t1(user t!)
user Test t2(user t!)
t1 :=: t2
; @ c t10
weak Test t1(weak to!)
weak Test t2(weak to!)
t1 :=: t2
; @ c t11
i :=: io
; @ c t12
d!.item :=: t
; @ ec te0
t :=: to
; @ ec te1
new Test t1!
t1 :=: t1
; @ ec te2
new String{8} nstr!
ostr :=: nstr
; @ ec te3
weak Array{Char} a(weak so!)
a :=: so![1:2]!
; @ ec te4
ta :=: tc
; @ ec te5
new Test t1!
strong Test t2(strong to!)
t1 :=: t2
; @@ test-question-expression
; @ c t0
b := ostr?
; @ c t1
b := not arr?
; @ c t2
b := t!.fun?
; @ c t3
b := to?
; @ c t4
b := fun7(weak _)->(weak t)?
; @ c t5
weak Test tt(weak t!)
b := tt?
; @ g t6
struct Test
    weak String? s
    func user meth()->(var Bool res)
        res := self.s?
; @ ec te0
(i := 2)?
; @ ec te1
i?
; @ ec te2
var Test tt
if tt?
; @@ test-exclamation-expression
; @ c t0
user String s(user ostr!)
; @ c t1
user Test tt(user t!.t!)
; @ c t2
user Test? tu
tu := fun7(weak _)->(weak t)!
; @ c t3
i := tb!.num
; @ c t4
weak Test tt(weak t!)
; @ c t5
new String{str!.length()} s!
; @ ec te0
user String s(user str)
; @ ec te1
user Test? tt(user t)
; @ ec te2
new String{4} s!
s := ostr
; @ ec te3
weak String? s
fun1(copy 0, user s, owner _)
; @ ec te4
t.num
; @ ec te5
t.meth()
; @ ec te6
var Func?{()} fun
fun()
; @ ec te7
i := arr[3]!
; @ ec te8
for _ in str
; @ ec te9
weak String? s
raise! s
; @ ec te10
new String{str.length()} s!
; @ ec te11
so := ostr
; @ ec teo0
raise! str!!
; @ ec ten0
var String{8} s
so := s!
; @ ec ten1
io := (2!) + 3
; @ ec ten2
so! := str
; @ ec ten3
"text"!.clear()
; @ ec ten4
var Func{(user Test? self)} fun(copy Test!.meth)
; @ ec ten5
var Test tv
i := tv!.num
; @ eg ten6
struct Base
    var Int x
    func user fun()
struct Test(Base)
    func user fun()
        base!()
; @ ec ten7
fun0!()
; @ eg ten8
func fun(user String s)
    fun(user s!)
; @ ec ten9
var Func{()} fun(copy fun0)
fun!()
; @ ec ten10
if not b!
; @ ec ten11
io := 2 + 3!
; @ eg ten12
func fun()
mock fun()
    fun!.active := false
; @ ec ten13
ut!.fun0()
; @ ec ten14
if t!?
; @ ec ten15
if b!
; @ ec ten16
loop
    while b!
; @ ec ten17
for _ in 3!
; @ ec ten18
for _ in 3!:4
; @ ec ten19
for _ in 3:4!
; @ ec ten20
var String{4} s
for _ in s!
; @ ec ten21
var Array{4:Int} a
for _ in a!
; @ ec ten22
user String? s(user str!)
; @ eg ten23
const Int CONST 12!
; @ ec ten24
assert! b!
; @ ec ten26
var Array{4:Int} a
i := a![2]!
; @ ec ten27
var Array{4:Int} a
i := a[2!]!
; @ ec ten28
var Array{4:Int} a
i := a[2:3!]!
; @ ec ten29
var Ref r
r := ostr!
; @ ec ten30
raise! "error"!
; @ ec ten31
raise! str!
; @ ec ten32
var String{23!} s
; @@ test-dynamic
; @ c t0
var Ta a
; @ c t1
user Ta? a
; @ c t2
owner Ta nta(owner Ta()!)
; @ c t3
new Ta a!
; @ c t4
user Ta? a(user ta!)
; @ c t5
user Ta? x
x := ta!
; @ c t6
ta := tb
; @ c t7
ta := tc
; @ c t8
ta := _
; @ c t9
strong Array?{Ta} aa
ta := aa![4]!
; @ c t10
strong Array?{Tc} ca
ta := ca![4]!
; @ c t11
ta!.dyn()
; @ c t12
tb!.dyn()
; @ c t13
tc!.dyn()
; @ c t14
tco := tc
tco!.dyn()
; @ c t15
fun7(weak tc)->(weak ta)
; @ g t16
class Test
    var Int x
    func dynamic user meth()
func ! mock()->(weak Test? t)
    t!.meth()
; @ g t17
class Base
    var Int x
    func dynamic user meth()
class Test(Base)
    func inst user fun()
        self.meth()
; @ c t18
fun7(weak _)
; @ eg te0
class Test
    var Int x
    func dynamic weak? meth()
func fun()
    weak Test? t
    t.meth()
; @@ test-function-object
; @ c t0
var Func{()} fun
fun := fun0
fun()
; @ c t1
var Func{(copy Int x)->(var Int y)} fun(copy fun5)
var Int x
fun(copy 9)->(var x)
; @ c t2
var Func{(user Test? self)} fun(copy Test.meth)
fun(user t!)
; @ c t3
var Func?{()} fun
fun := _
b := fun?
fun!()
; @ c t4
t!.fun := fun0
t!.fun!()
; @ c t5
var Array{38:Func{()}} farr
new Array{12:Func{(copy Int x)->(var Int y)}} farr1!
new Array{12:Func{:()}} farr2!
user Array{Func{:()}} ufarr
farr[3] := fun0
farr[3]()
; @ c t6
var Func{(copy Int x,
        copy Int y)} fun
; @ g t7
func mock()->(var Func{()} f)
    f()
; @ g t8
func fun(copy Func?{(copy Int x,
        copy Int y)} fi)->(var Func{:(copy Int x,
        copy Int y)} fo)
    fun(copy _)
func afun(user Array{Func{(copy Int x)->(var Int y)}} in)->(
        owner Array?{Func{:()}} out)
struct Test
    var Func{(copy Int x,
            copy Int y)} fun
    var Array{4:Func{:(copy Int x)->(var Int y)}} afun
    func user meth(copy Func{:(copy Int x,
            copy Int y)} fi)->(var Func{(copy Int x,
            copy Int y)} fo)
; @ c t9
var Func{:()} fun
fun := fune
fun()!
; @ ec te0
var Func error
; @ ec te1
var Array{3:Func} error
; @ ec te2
var Func{} error
; @ ec te3
var Func{() } error
; @ ec te4
var Func{()} fun(copy fun1)
; @ ec te5
var Func{()->(var Int x)} fun
fun := fun0
; @ ec te6
var Func{()} fun
fun()
; @ ec te7
var Func{()} fun(copy fun0)
fun := _
; @ ec te8
var Func{()} fun(copy fun0)
if fun?
; @ ec te9
var Func{()} fun(copy fune)
; @ ec te10
var Func{:()} fun(copy fun0)
; @@ test-builtin
; @ c ti0
i.str(user ostr!)!
; @ c tb0
b := true
; @ c tb1
b := false
; @ ec c0
c := EOF
; @ c ta0
arr!.length()->(var i)
; @ c ts0
ostr!.length()->(var i)
; @ c ts1
ostr!.clear()
; @ c ts2
ostr!.equal(user ostr!)->(var b)
; @ c ts3
ostr!.get(copy i)->(var c)!
; @ c ts4
ostr!.set(copy i, copy c)!
; @ c ts5
ostr!.append(copy c)!
; @ c ts6
var String{12} sv
sv.copy(user ostr!)!
; @ c ts7
ostr!.concat(user ostr!)!
; @ c ts8
ostr!.concat-int(copy i)!
; @ c ts9
ostr!.find(user ostr!)->(var i)
; @ c ts10
ostr!.has(copy c)->(var b)
; @ c ts11
String.set(user ostr!, copy 0, copy 'a')!
; @ c ts12
ostr!.max-length()->(var i)
; @ c tf0
file-open-read(user ostr!)->(owner fobj)!
; @ c tf1
file-open-write(user ostr!)->(owner fobj)!
; @ c tf2
file-close(owner fobj!)!
; @ c tf3
fobj!.getc()->(var c, var b)!
; @ c tf4
fobj!.putc(copy c)!
; @ c tf5
fobj!.write(user ostr!)!
; @ c ty0
user Array{String} argv(user sys.argv)
; @ c ty1
sys.print(user ostr!)!
; @ c ty2
sys.println(user ostr!)!
; @ c ty3
sys.getchar()->(var c, var b)
; @ c ty4
sys.getline(user ostr!)!
; @ c ty5
sys.exit(copy i)!
; @ c ty6
sys.system(user ostr!)->(var i)!
; @ c ty7
sys.getenv(user ostr!, user ostr!)->(var b)!
; @ c ty8
sys.stdout.putc(copy c)!
; @ c ty9
sys.stdin.getc()->(var c, var b)!
; @ c ty10
sys.stderr.putc(copy c)!
; @ ec tef0
var File error
; @ ec tef1
new File error!
; @ ec tef2
File()
; @ ec tef3
user File? f
file-open-read(user "name")->(owner fobj)!
f!.putc(copy 'a')!
; @ ec tef4
user File? f
file-open-write(user "name")->(owner fobj)!
f!.putc(copy 'a')!
; @ ec tef5
user File? f
file-close(owner fobj!)!
f!.putc(copy 'a')!
; @ ec tef6
owner File f(owner fobj!)
file-open-read(user "name")->(owner f)!
; @ ec tey0
var Sys error
; @ ec tey1
new Sys error!
; @ ec tey2
Sys()
; @@ test-general
; @ g t0
user String str
; @ g t1


    

var Int x
; @ g t2
; comment

var Int x
; @ g t3
~~~ documentation ~~~

var Int x
; @ g t4
[; multi 
 line 
 comment ;]

var Int x
; @ g t5
~~~ multi 
 line    
 documentation
 confused by ~ or ~~ or ; or ~~ ~ ?
~~~

var Int x
; @ g t6
var String{12} s
user String us(user s)
user String gs(user "global text")
main
    var Int x(copy 6)
    x := 7
; @ tg t7
var String{12} s
user String us(user s)
func fun()
    s.clear()
; @-
module second
test dummy()
; @ tg t8
func fun()
    fun()
main
    fun()
; @-
module test
test test-fun()
; @ eg te0
error 
; @ ec te1
1 + 2
; @ ec te2
return
i := 3
; @ ec te3
raise!
i := 3
; @ eg te4
[; comment ;]?
; @ eg te5
main(
; @ eg te6
    struct Test
; @ eg te7
func f()
    x :=
        y
; @ feg te8
var Int x
; @ eg te9
var Int name
var Int name
; @ eg te10
func name()
var Int name
; @ eg te11
user Error error
; @ eg te12
var Int x(copy error)
; @ eg te13
[ ; error
; @@ test-struct
; @ g t0
struct Test
    var Int x
; @ g t1
struct Test
    var Int x
; @ g t2
struct Test1
    var Int x
struct Test2
    var Int x


struct Test3
    var Int x
; @ g t3
struct Test2(Test1)
    var Int y
struct Test1
    var Int x
; @ g t4
struct Test
    owner Test? to
    strong Test? ts
    weak Test? tw
; @ eg te0
struct(
; @ eg te1
struct error
; @ eg te2
struct ERror
; @ eg te3
struct Error-name
; @ eg te4
struct E
; @ eg te5
struct Int
; @ eg te6
struct Test
struct Test
; @ eg te7
struct Test(Base
; @ eg te8
struct Test
    error 
; @ feg te9
struct Test
; @ eg te10
struct Error
; @ eg te11
struct Error
    new 
; @ eg te12
struct Error
    new()
    new()
; @ eg te13
struct Error
    var Int x
    new()->(var Int x)
; @ eg te14
struct Error(Error)
    var Int x
; @ eg te15
struct Aerror(Berror)
    var Int x
struct Berror(Aerror)
    var Int x
; @@ test-class
; @ g t0
class Base
    var Int x
    owner Base? b
    func inst user stat()
    func dynamic user dyn0()
    func dynamic user ! dyn1()
    func dynamic user dyn2()
class Mid(Base)
    var Int y
    owner Mid? m
    func dynamic user dyn0()
    func dynamic user dyn3()
    func dynamic user ! dyn4()
class Top(Mid)
    var Int z
    owner Top? t
    func dynamic user dyn0()
        base()
    func dynamic user ! dyn1()
        base()!
    func dynamic user dyn3()
        base()
    func dynamic user dyn5()
        base.dyn0()
; @ g t1
class Test
    owner Test? to
    strong Test? ts
    weak Test? tw
    func dynamic user fun()
; @ eg te0
class(
; @ eg te1
class Error
    var Int x
; @ eg te2
class Error
    func error f()
; @ eg te3
struct Base
    var Int x
    func user meth()
class Error(Base)
    func dynamic user meth()
; @ eg te4
class Base
    var Int x
    func dynamic user meth()
class Error(Base)
    func inst user meth()
; @ eg te5
class Base
    var Int x
    func dynamic user meth()
class Error(Base)
    func dynamic user meth(copy Int x)
; @ eg te6
class Base
    var Int x
    func dynamic user meth()
class Error(Base)
    func dynamic user ! meth()
; @@ test-function
; @ g t0
func name()
; @ g t1
func name(user String self, user String text, copy Int num)
; @ g t2
func name()->(owner String? text, var Int num)
; @ g t3
func name(copy Char param)->(owner String? out)
; @ g t4
func name(user Array{Int} array)
; @ g t5
func name(copy Func{(copy Int x)->(var Int y)} fun)->(var Func{()} joy)
; @ g t6
func name()
    var Int x
; @ g t7
func ! name(user String self, copy Int px, user Array{Char} pu, owner String po)->(
        strong String? oself, var Int ox, weak String? ou, owner String? oo)
    var Int x
    user String? u
    owner String? o
    var String{12} v
    new String{12} n!
    o := String{12}()!
    u := "constant string"
    pu := po[2:6]!
; @ g t8
struct Struct
    owner Struct? s
    owner Array?{Struct} as
    owner Array?{String} astr
class Class
    owner Class? c
    owner Array?{Class} ac
    func dynamic user meth()
func name(
        owner Struct ps,
        owner Class pc,
        owner Array{Struct} pas,
        owner Array{Class} pac)
    owner Struct? s
    owner Class? c
    owner Array?{Struct} as
    owner Array?{Class} ac
    owner Array?{Int} ai
    owner Array?{File} af
    owner Array?{String} astr
; @ g t9
class Test
    var Int x
    func dynamic user meth()
func name()->(owner Test? t)
    t := _
; @ g t10
func name(user Array{Array{String}} ai)->(owner Array?{Array{Int}} ao)
; @ g tm0
main
    var Int x
; @ eg te0
func(
; @ eg te1
func name
; @ eg te2
func Error()
; @ eg te3
func error_name()
; @ eg te4
func name()
func name()
; @ eg te5
var Int name
func name()
; @ eg te6
func name( )
; @ eg te7
func name(user)
; @ eg te8
func name(user String
; @ eg te9
func name(error Int x)
; @ eg te10
func name(user String str,user Int x)
; @ eg te11
func name()-()
; @ feg te12
func name()
; @ eg te13
func name()
        var Int x
; @ eg te14
func name(user Int x)
; @ eg te15
func name()->(copy Int x)
; @ eg te16
func name(copy String s)
; @ eg te17
func name(user Array error)
; @ eg te18
func name(copy Func error)
; @ eg te20
func name(
    copy Int x)
; @ eg te21
func Type.Error.name()
; @ eg te22
func module.error.name()
; @ eg te23
func name(copy Int error, copy Int error)
; @ eg te24
func name(copy Int error)->(var Int error)
; @ eg te25
var Int error
func name(copy Int error)
; @ eg te26
func error()
func name(copy Int error)
; @ eg te27
func error(copy Int error)
; @ eg te28
func name(copy Int Error)
; @ eg te29
func name()->(owner String s)
; @ eg te30
func fun(weak String s)
    s!.clear()
; @ eg te31
func fun()
    raise!
; @ eg te32
func fun()
    assert! 1 = 2
; @ eg te33
func fun()
    assert-error! 1 = 2
; @@ test-members
; @ g t0
struct Test
    var Int x
    weak String? str
; @ g t1
struct Test
    var Int x
    func user name()
        self.x := 2
; @ g t2
struct Test
    var Int x
    func user name()
        var Int x
        x := self.x
; @ g t3
struct Test
    ; comment
    var Int x
; @ g t4
struct Test
    ~~~ documemtation ~~~
    var Int x
; @ g t5
struct Test
    [; multi 
    line 
    comment ;]
    var Int x
; @ g t6
struct Test
    ~~~ multi 
    line 
    documemtation
    ~~~
    var Int x
; @ g t7
var Int name
func fun()
struct Test1
    var Int name
    func user fun()
struct Test2
    var Int fun
    func user name()
; @ g t8
struct Test
    var Int x
    func user fun()
        if self.x > 3
            self.x := 3
        loop
            for n in 4
                self.x += n
            while self.x < 30
; @ g t9
struct Test
    var Int x
    func user fun() _
func Test.fun()
    self.x := 3
; @ g t10
func Test.fun(user String s)->(var Int x)
    s.length()->(var x)
struct Test
    var Int x
    func user fun(user String s)->(var Int x) _
; @ g t11
struct Test
    var Int x
    new(copy Int x) _
func Test.new(copy Int x)
    self.x := x
; @ eg te0
struct Test
    var Int name
    var Int name
; @ eg te1
struct Test
    func user name()
    var Int name
; @ eg te2
struct Test
    func user name()
    func user name()
; @ eg te3
struct Test
    var Int name
    func user name()
; @ eg te4
struct Test
    var Int x
    func user meth()
        owner Test? error
        error := self
; @ eg te5
struct Test
    var Int x
    func user name() 
; @ eg te6
struct Test
    var Int x
    func user error.name()
; @ eg te7
struct Test
    var Int x
    func user fun()
func Test.fun()
; @ eg te8
func Test.fun()
struct Test
    var Int x
    func user fun() _
func Test.fun()
; @ eg te9
struct Test
    var Int x
    func user fun()
        self..x := 3
; @ ec te10
Test.num
; @ eg te11
struct Test
    var Int x
    func error()
; @ eg te12
struct Test
    var Int x
    func error?()
; @ eg te13
struct Test
    var Int x
    func user fun()->(var Int x) _
func Test.fun()
; @ eg te14
struct Test
    var Int x
    func user ! fun() _
func Test.fun()
; @@ test-return
; @ g t0
func name()
    return
; @ g t1
func ! name()
    raise!
; @ g t2
func ! name()
    raise! "some error"
; @ g t3
func ! name(user Array{String} arr)
    raise! arr[3]!
; @ c t4
weak String? s
raise! s!
; @ ec te0
return()
; @ ec te1
raise!()
; @ ec te2
raise! 2
; @ ec te3
raise! _
; @ ec te4
raise
; @@ test-code-variables
; @ c t0
var Int x
; @ c t1
user String? s
; @ c t2
owner Array?{Int} a
; @ c t3
user Test? tt
; @ c t4
var String{12} s
; @ c t5
var Array{12:Int} a
; @ c t6
var Array{12:Test} a
; @ c t7
var Array{12:String{7}} sa
; @ c t8
new String{12} s!
so := s!
; @ c t9
var Array{12:Ta} a
; @ c t10
new Array{12:Int} a!
; @ c t11
new Array{12:String{7}} sa!
; @ c t12
var Array{3:Array{4:String{5}}} aa
; @ c t13
new Array{3:Array{4:String{5}}} aa!
; @ g t14
func ! fun()
    var String{4} sv
    if 1 > 2
        user Array{Char} su(user sv[1:2]!)
; @ ec te0
var Int
; @ ec te1
var Int Error
; @ ec te2
var Int errorName
; @ ec te3
var Int name
var Int name
; @ ec te4
var Int name
loop
    var Int x
    loop
        var Int name
; @ eg te5
var Int name
func mock()
    var Int name
; @ eg te6
func name()
func mock()
    var Int name
; @ eg te7
struct Test
    var Int x(1)
; @ ec te8
new
; @ ec te9
var Array{i:Int} error
; @ ec te10
var Int error--name
; @ ec te11
var Int x 
; @@ test-initialize
; @ c t0
tb := Tb(copy i)!
; @ c t1
str := String{arr![0]}()!
; @ c t2
owner Array{Int} a(owner Array{arr![0]:Int}()!)
; @ c t3
owner Array{Test} a(owner Array{arr![0]:Test}()!)
; @ c t4
owner Array{String} sa(owner Array{arr![0]:String{arr![1]!}}()!)
; @ c t5
var Int x(copy arr![0])
; @ c t6
user String? s(user ostr)
; @ c t7
var String{12} s(user "some string")!
; @ c t8
new String{i} s(user ostr!)!
; @ c t9
user Test? tt(user tc!)
; @ c t10
var Tc tt(copy 3)!
; @ c t11
new Tc tt(copy 3)!
; @ c t12
tb := Tc(copy 3)!
; @ c t13
user Tb? tt(user tb)
; @ c t14
owner Ta? ota(owner tb)
; @ c t15
owner Array{Array{String}} sa(owner Array{arr![0]:Array{arr![1]!:String{arr![2]!}}}()!)
; @ g t16
func get()->(owner File? a)
    owner File? b(owner get())
; @ c t17
owner Test? ot(owner to)
strong Test? st(strong ot!)
; @ c t18
s-var Tc tt(copy 3)!
; @ c t19
new Test t1!
s-var Test t2!
; @ g t20
struct Test
    var Int x
    new(copy Int x)
func fun()
    var Test t(copy 3)
; @ ec te0
Int()
; @ ec te1
var String s
; @ ec te2
var Array{4:String} sa
; @ ec te3
new String s!
; @ ec te4
String()
; @ ec te5
user Array a
; @ ec te6
new Array a!
; @ ec te7
Array()
; @ ec te8
var Array{23} a
; @ eg te9
struct Test{Generic}
    owner Array{Generic} arr
; @ ec te10
var Array{1
; @ ec te11
var String{12
; @ ec te12
var Array{error:Int} a
; @ ec te13
var Array{"12":Int} a
; @ ec te14
user Int x
; @ ec te15
new Int x!
; @ ec te16
var Array{4:Int} a(copy 1)
; @ ec te17
var Bool x(var 1)
; @ ec te18
var Int x(var 1, var 2)
; @ eg te19
struct Test
    var Int x
func mock()
    Test(copy 1)
; @ ec te20
var Int x(user 3)
; @ ec te21
owner String? s(user so)
; @ ec te22
owner String? s(owner str)
; @ ec te23
var Array{1:Int:Int} a
; @ ec te24
owner Test? ot(owner tb)
; @ ec te25
user String s
s.clear()
; @ ec te26
user String s(user _)
; @ ec te27
user String s(user str)
; @ ec te28
i := error
var Int error
; @ ec te29
var Int error(copy error)
; @ ec te30
error := 3
var Int error
; @ ec te31
if b
    var Int error
i := error
; @ ec te32
new Test? a!
; @ ec te33
to := Test?()
; @ ec te34
to := Test()
; @ ec te35
var Tb tt(copy 3)
; @ ec te36
user String s!
; @ eg te37
user String s!
; @ eg te38
struct Test
    weak String s!
; @@ test-comment
; @ c t0
; comment

var Int x
; @ c t1
~~~ documemtation ~~~

var Int x
; @ c t2
[; multi 
line 
comment ;]

var Int x
; @ c t3
~~~ multi 
line 
documemtation
~~~

var Int x
; @@ test-block
; @ c t0
block
    new Test tt!
    i += 1
; @ c t1
block
    return
; @ c t2
block
    var Int n
block
    var Int n
; @ ec te0
block i
; @ ec te1
block
    break
; @ ec te2
block
    while b
; @ ec te3
block
    new Test tt!
tt.meth()
; @ ec te4
user Test tt
block
    var Test tvar
    tt := tvar
tt.meth()
; @@ test-if-else
; @ c t0
if t!.num > 3
    i -= 2
; @ c t1
if i > 3
    i -= 2
else
    i += 1
; @ c t2
if i > 3
    i -= 3
else-if t!.num > 2
    i -= 2
else-if t!.num > 1
    i -= 1
else
    i += 1
; @ c t3
if b
    return
i := 3
; @ c t4
if b and
        b
    i += 1
; @ c t5
if b
    var String{4} sa
    if b
        var String{4} sb
    else-if b
        var String{4} sc
    else
        var String{4} sd
else-if b
    var String{4} se
else
    var String{4} sf
; @ ec te0
if 3
; @ ec te1
if b
    error
; @ ec te2
if b
    i := 0
else
    error
; @ ec te3
if b
    i := 0
else-if b
    error
; @ ec te4
if b
    return
    i := 3
; @ ec te5
if()
; @ ec te6
else
; @ ec te7
if false
    ; ...
else 
; @ ec te8
else-if b
; @ ec te9
if false
    ; ...
else-if()
; @ feg te10
func error()
    if b
; @@ test-loop
; @ c t0
loop
    var Int x
    while b
; @ c t1
loop
    break
; @ c t2
loop
    while t!.num > 3
; @ c t3
loop
    continue
    while b
; @ c t4
loop
    if true
        while false
; @ c t5
loop
    var String{4} sa
    while b
    break
    continue
    if b
        return
    loop
        var String{4} sb
        while b
        break
        continue
        if b
            return
        loop
            var String{4} sc
            while b
            break
            continue
            if b
                return
; @ c t6
loop! 1024
    while b
; @ c t7
try
    loop ostr.length() + 2
        while b
; @ c t8
loop-infinite
    i += 1
; @ c t9
loop
    loop
        loop
            return
; @ ec te0
loop!(
; @ ec te1
while true
; @ ec te2
continue
; @ ec te3
loop
    while 2
; @ ec te4
loop
    error
; @ ec te6
loop
    while i := 3
; @ ec te7
loop
    while
; @ ec te8
loop
    continue error
; @ ec te9
break
; @ ec te10
loop
    break error
; @ ec te11
loop
    i += 1
; @ ec te12
loop
    loop
        break
; @ ec te13
try
    loop! 64
        while b
; @@ test-for-loop
; @ c t0
for n in 5
    i += n
; @ c t1
for n in t!.num:ostr!.length() + 2
    i += n
; @ c t2
for ch in ostr!
    c := ch
; @ c t3
for n in arr!
    i += n
; @ c t4
for s in sarr!
    s.clear()
; @ c t5
var Int n
for n in 5
    i += n
; @ c t6
for n in 5
    i += n
for n in 7
    i += n
; @ c t7
for n in 1 +
        2
    i += n
; @ c t8
for n in 6
    var String{4} sa
    break
    continue
    if b
        return
    for ch in ostr!
        var String{4} sb
        break
        continue
        if b
            return
; @ c t9
user String s(user "text")
for ch in s
    c := ch
; @ c t10
var Array{3:String{4}} sa
for s in sa
    s.clear()
; @ c t11
for _ in 2:6
    i += 1
; @ c t12
for _ in ostr!
    i += 1
; @ c t13
repeat i + 4
    i += 1
; @ ec te0
for(
; @ ec te1
for n
; @ ec te2
for n error
; @ ec te3
for n in fun0()
; @ ec te4
for n in str:8
; @ ec te5
for n in 5
    error
; @ ec te6
var Int n
for n in arr!
    i += n
for n in sarr!
; @ ec te7
for n in 7
    i += 1
var Int n
; @@ test-testing
; @ c ta0
assert! t!.num = 2
; @ c ta1
assert-error! t.num
; @ c ta2
assert-error! fune()
; @ c ta3
assert-error! t.num, "expected error"
; @ c ta4
assert-error! fune(), "expected error in the function"
; @ c ta5
assert-error! t.num,
        "expected error in new line"
; @ c ta6
if b
    var String{4} s
    assert! b
    assert-error! s[i:2]
    repeat 3
        assert-error! s[i:2]
; @ g tm0
func ! fun()
    fun()!
mock ! fun()
    raise!
; @ g tm1
mock fun()
func fun()
    fun()
; @ g tm2
mock Test.meth(copy Int x)
struct Test
    var Int x
    func user meth(copy Int x)
        self.meth(copy x)
; @ g tm3
mock Test.meth(copy Int x)
class Test
    var Int x
    func dynamic user meth(copy Int x)
        self.meth(copy x)
; @ g tm4
func fun(copy Int x)->(var Int y)
mock fun(copy Int x)->(var Int y)
    fun.mocked(copy x)->(var y)
    fun.active := false
    fun(copy x)->(var y)
    fun.active := true
; @ g tm5
struct Test
    var Int x
    func user meth(copy Int x)->(var Int y)
        self.meth(copy x)->(var y)
mock Test.meth(copy Int x)->(var Int y)
    self.meth.mocked(copy x)->(var y)
    Test.meth.mocked(user self, copy x)->(var y)
    self.meth.active := false
    Test.meth(user self, copy x)->(var y)
    Test.meth.active := true
; @ g tm6
class Test
    var Int x
    func dynamic user meth(copy Int x)->(var Int y)
        self.meth(copy x)->(var y)
mock Test.meth(copy Int x)->(var Int y)
    Test.meth.mocked(user self, copy x)->(var y)
    Test.meth.active := false
    Test.meth(user self, copy x)->(var y)
    Test.meth.active := true
; @ g tm7
func ! fun()
    sys.print(user "mock print")!
    sys.print.mocked(user "really print")!
    Sys.print.active := false
    sys.print.active := true
mock ! Sys.print(user Array{Char} text)
; @ g tm8
struct Test
    var Int x
    new(copy Int x)
mock Test.new(copy Int x)
func fun()
    var Test t(copy 2)
; @ tg tt0
func fun0()
    var Int x(copy 4)
    x += 1
    var Int y(copy 5)
    y := x
    if y > 3
        y := 3
    else-if y < 0
        y := 0
    else
        y += 1
    try
        x := 0
        sys.print(user "text")
        y := 0
    catch
        x := 1
        x := 2
    if x > 3
        return
    else
        x := 3
    loop
        while x > 1
        if x = 5
            continue
    for n in 3
        x += y
; @-
module ut
func fun1()
    fun0()
test fun2()
    fun1()
; @ tg tt1
func fun()
    var Int x
main
    fun()
; @-
module second
test fun0()
test fun1()
; @ g tmg0
mock Test.delete()
    var Ref? r(copy self)
struct Test
    weak String? s
; @ g tmg1
mock delete()
    var Ref? r(copy self)
main
; @ g tmg2
mock new()->(var Bool allocate-success)
    allocate-success := false
main
; @ c tr0
var Ref r
; @ c tr1
var Ref r
r := ostr
; @ c tr2
var Ref r
r := _
; @ c tr3
var Ref r(copy ostr)
; @ c tr4
var Ref r
assert! r is r
; @ ec te0
assert! 3
; @ ec te1
assert! error
; @ ec te2
assert-error! error
; @ eg te3
test fun(copy Int x)
; @ eg te4
test fun()->(copy Int x)
; @ eg te5
mock error()
; @ eg te6
mock Error.fun()
; @ eg te7
struct Test
    var Int x
mock Test.error()
; @ eg te8
mock fun(owner String s)
func fun(user String s)
; @ eg te9
mock fun(user Int s)
func fun(user String s)
; @ eg te10
mock fun(user Array{Char} a)
func fun(user Array{Int} a)
; @ ec te11
assert 
; @ ec te12
assert-error 
; @ eg te13
mock()
; @ eg te14
func fun()
mock fun()
mock fun()
; @ eg te15
struct Test
    var Int x
    func user fun()
mock Test.fun()
mock Test.fun()
; @ eg te16
mock delete()
mock delete()
; @ eg te17
struct Test
    var Int x
mock Test.delete()
mock Test.delete()
; @ ec te18
assert-error! t.num , "error"
; @ ec te19
assert-error! t.num,"error"
; @ ec te20
assert-error! t.num,  "error"
; @ ec te21
assert-error! t.num, error
; @ eg te22
mock new()->(var Bool res)
mock new()->(var Bool res)
; @ eg te23
mock new()->(var Int x)
; @ eg te24
mock new()
; @ eg te25
mock new(copy Int x)->(var Bool res)
; @ eg te26
mock new()->(var Bool res, var Int x)
; @ eg te27
mock delete(copy Int x)
; @ eg te28
mock delete()->(copy Int x)
; @ eg te29
func fun()
mock fun()
    fun.error
; @ eg te30
class Test
    var Int x
    func dynamic user meth()
mock Test.meth()
    self.meth.mocked()
; @ eg te31
test
; @ eg te32
struct Test
    owner String s
    new!()
        self.s := String{12}()!
mock ! Test.new()
; @ eg te33
test ! fun()
; @ ec te34
assert-error! fun0()
; @ ec te35
assert-error! t!.num
; @ ec te36
assert-error! t!
; @@ test-native
; @ g ti0
native include "native.h"
; @ g ti1
struct Test
    var Int x
native include "first.h"
func fun()
native include "second.h"
; @ g tf0
native func external()
func call()
    external()
; @ g tf1
class Test
    var Int x
    func dynamic user meth()
native func external(
        copy Int i, user String? s, user Array?{Int} a, user Test? t)->(
        copy Int res)
func call()
    var Int i
    user String? s
    user Array?{Int} a
    user Test? t
    i := external(copy 5, user s, user a, user t)
    i := (2 * external(copy 5, user s, user a, user t)) + 3
    external(copy 5, user s, user a, user t)
; @ g tf2
native func external() "SOME_External_func"
func call()
    external()
; @ g tf3
struct Test
    var Int x
native func external()->(user Test? t)
func call()
    user Test? t
    t := external()
    external()
; @ g tv0
native var Int x
func use()
    x := 2
; @ g tv1
native var Int x "SOME_External_var"
func use()
    x := 2
; @ g tc0
native const Int VALUE
func get()->(var Int x)
    x := VALUE
; @ g tc1
native const Int VALUE "SOME_External_const"
func get()->(var Int x)
    x := VALUE
; @ g tt0
native type Native
native func external(copy Native n)->(copy Native no)
func call()
    var Native n
    n := external(copy n)
; @ g tt1
native type Native "SOME_External_type"
native func external(copy Native n)->(copy Native no) "SOME_External_func"
func call()
    var Native n
    n := external(copy n)
; @ g tb0
var Int x
native code "#define HAS_SOME_DEFINE"
var Int y
; @ c tb1
native "#ifdef __UNIX__"
io := 3
native "#else"
io := 4
native "#endif"
; @ eg te0
native()
; @ eg te1
native error
; @ eg te2
native error 
; @ eg tei0
native include native.h
; @ eg tef0
native func error()
native func error()
; @ eg tef1
native func ! error()
; @ eg tef2
native func error()->(copy Int a, copy Int b)
; @ eg tef3
native func error()->(owner String? s)
; @ eg tef4
native func error()->(var Int s)
; @ eg tef5
native func error()->(s-var String? s)
; @ eg tef6
native func error()->(weak String? s)
; @ eg tef7
native func error()->(strong String? s)
; @ eg tef8
native func error(owner String s)
; @ eg tef9
native func error(weak String s)
; @ eg tef10
native func error(strong String s)
; @ eg tef11
native func error(s-var String s)
; @ eg tef12
native func fun()->(copy Int res)
func error(copy Int i)
    fun()->(copy i)
; @ eg tef13
native func fun()->(copy Int res) error
; @ eg tef14
native func error()->(user String? s)
; @ eg tef15
native func error()->(user Array?{Int} a)
; @ eg tef16
struct Error
    var Int x
native func error()->(user Error s)
; @ eg tef17
class Error
    var Int x
    func dynamic user meth()
native func error()->(user Error? e)
; @ eg tev0
native var String s
; @ eg tev1
native var Int x error
; @ eg tec0
native const Int VALUE error
; @ eg tec1
native const Int VALUE
var String{VALUE} error
; @ eg tet0
native type Native error
; @ eg teb0
native code #define error
; @ ec teb1
native #ifdef error
; @@ test-parameter-type
; @ g t0
struct Test{Generic}
    weak Generic? item
    func user ! set(weak Generic item)
        weak Generic x(weak item)
        self.item := x
        new Test{Generic} t!
        t.item := self.item
        self.item := t.item
; @ g t1
struct Test{Generic}
    owner Generic? item
    func user get()->(user Generic? item)
        item := self.item
; @ g t2
struct Test{First:Second:Third}
    weak First? first
    weak Second? second
    weak Third? third
    func user set(weak First first, weak Second second, weak Third third)
        self.first := first
        self.second := second
        self.third := third
func use(weak File first, weak Sys second, weak File third)
    var Test{File:Sys:File} t
    t.first := first
    t.second := second
    t.third := third
    t.set(weak first, weak second, weak third)
; @ g t3
struct Base
    var Int x
struct Test{Generic}(Base)
; @ c t4
d!.item := t
; @ c t5
t := d!.item
; @ g t6
struct Test{Generic}
    var Int x
    var Func{(user Generic item, copy Func{(user Generic item)} fun)} fun
    func user meth(copy Func{(user Generic item,
            copy Func{(user Generic item)} fun)} fun)
        var Func{(user Generic item, copy Func{(user Generic item)} funa)} funv
; @ c t8
var Array{5:Data{Test}} ad
t := ad[2].item
; @ c t10
d!.set(owner _)
; @ c t11
var Data{Data{Data{Test}}} dr
t := dr.item!.item!.item
; @ c t12
d!.set(owner to)
; @ c t13
d!.get()->(weak t)
d!.get()!.meth()
; @ c t14
var Data dg
; @ c t15
user Data? dg(user d!)
; @ c t16
Data{Test}.set(user d!, owner to)
; @ g t17
struct Test{Generic}
    weak Test?{Generic} next
    func user meth(weak Test{Generic} next)->(user Test?{Generic} out)
        self.next := next
        out := self
; @ c t18
var Data{Tb} dt
dt.item := tc
ta := dt.item
owner Tc? otc
dt.set(owner otc)
dt.get()->(weak ta)
i := dt.get()!.numa
fun7(weak dt.item)->(weak dt.item)
user Tb? tb2(user dt.item!)
tb2 := dt.item!
; @ g t19
struct Base{Generic}
    weak Generic? item
    func user get()->(weak Generic? item)
struct Test(Base{File})
    func user set(weak File? f)
        self.item := f
        self.get()->(weak f)
func ! fun(user Test test, weak File? f)
    test.item := f
    test.set(weak f)
    f := test.item
    test.get()->(weak f)
    test.get()!.putc(copy 'a')!
; @ g t20
class Base{Param}
    weak Param? item
    func dynamic user set(weak Param? item)
    func dynamic user get()->(weak Param? item)
class Test{Generic}(Base{Generic})
    func dynamic user set(weak Generic? item)
    func dynamic user get()->(weak Generic? item)
func ! mock(weak Test{File} test, weak File? f)
    test!.set(weak f)
    test!.get()->(weak f)
    test!.get()!.putc(copy 'a')!
; @ g t21
struct Test{Param}
    weak Param? item
    func user meth(weak Param? in)->(weak Param? out) _
func Test.meth(weak Param? in)->(weak Param? out)
    weak Param? p(weak in)
    out := p
    self.item := p
    self.meth(weak p)->(weak p)
; @ eg teg0
struct Test{First:Second:Third
; @ eg teg1
struct Test{Generic}
    var Generic error
; @ eg teg2
struct Test{Generic}
    weak Generic? item
    func user meth(copy Generic error)
; @ eg teg3
struct Test{Generic}
    weak Generic? item
    func user meth(weak String s)
        self.item := s
; @ eg teg4
struct Test{Generic}
    weak Generic? item
    func user ! meth()->(user String? s)
        s := self.item!
; @ eg teg5
struct Test{Generic}
    weak Generic? item
    func user meth()
        var Generic error
; @ eg teg6
struct Test{First:Second}
    weak First? first
    weak Second? second
    func user meth()
        self.first := self.second
; @ eg teg7
struct Test{error}
    var Int x
; @ eg teg11
struct Test{First:Second:Third}
    weak First first
    weak Second second
    weak Third third
func meth(user Test{File:File} t)
    user Test{File:File:File} error(user t)
; @ eg teg12
struct Base{Param}
    weak Param item
struct Error(Base)
; @ eg teg13
struct Base
    weak Int x
struct Error(Base{File})
; @ eg teg14
struct Base{Param}
    weak Param item
struct Error(Base{File:File})
; @ eg teg15
struct Base{Param0:Param1}
    weak Param0 item0
    weak Param1 item1
struct Error(Base{File})
; @ ec tec0
var Data{Int} error
; @ ec tec1
var Data{File:File} error
; @ ec tec2
var Data{Error} error
; @ ec tec3
var Char{File} error
; @ ec tec4
var Data dg
str := dg.item!
; @ ec tec5
s-var Data dg!
d := dg
; @ ec tec6
str := d!.item!
; @ ec tec7
var Data{Array{Int}} error
; @ ec tec8
var Data{String} error
; @@ test-parameter-inheritance
; @ g t0
struct Base{Generic}
    weak Generic? item
struct Test(Base{File})
    func user ! set(weak File f)
        self.item := f
        Test.set(user Test()!, weak f)!
func use(weak File f)
    var Test t
    t.item := f
; @ g t1
struct Base{Generic}
    weak Generic? item
struct Test{Param}(Base{Param})
    func user ! set(weak Param i, weak File f)
        self.item := i
        Test{File}.set(user Test{File}()!, weak f, weak f)!
func use(weak File f)
    var Test{File} t
    t.item := f
; @ g t2
struct Base{Pbase}
    weak Pbase? item
    func user set(weak Pbase i)
struct Mid{Pmid}(Base{Pmid})
    func user set(weak Pmid i)
struct Top(Mid{File})
    func user set(weak File f)
        base(weak f)
        self.item := f
struct Test(Top)
    func user ! set(weak File f)
        base(weak f)
        self.item := f
        Top.set(user Top()!, weak f)
        Test.set(user Test()!, weak f)!
        Mid{File}.set(user Top()!, weak f)
func use(weak File f)
    var Test t
    t.item := f
; @ g t3
struct Base{Generic}
    weak Generic? item
struct Test{Generic}(Base{Generic})
    func user ! set(weak Generic i, weak File f)
        self.item := i
        Test{File}.set(user Test{File}()!, weak f, weak f)!
func use(weak File f)
    var Test{File} t
    t.item := f
; @ g t4
struct Base{First:Second}
    weak First? first
    weak Second? second
struct Mid{Param:Third}(Base{Param:Sys})
    weak Third? third
    func user set(weak Param first, weak Sys second, weak Third third)
        self.first := first
        self.second := second
        self.third := third
struct Top{Generic}(Mid{Generic:File})
    func user set(weak Generic first, weak Sys second, weak File third)
        self.first := first
        self.second := second
        self.third := third
struct Test(Top{File})
    func user set(weak File first, weak Sys second, weak File third)
        self.first := first
        self.second := second
        self.third := third
func use(weak File first, weak Sys second, weak File third)
    var Test t
    t.first := first
    t.second := second
    t.third := third
; @ g t5
struct First{FirstGeneric}
    weak FirstGeneric? item
struct Second{SecondGeneric}
    weak SecondGeneric? item
struct Test{Generic}(First{Second{Generic}})
    func user ! set(weak Generic g, weak Second{Generic} sg)
        self.item := sg
        self.item!.item := g
func ! use(weak File f, weak Second{File} ff)
    var Test{File} t
    t.item := ff
    t.item!.item := f
; @ g t6
struct BaseGen{FirstGeneric}
    weak FirstGeneric? item
struct TestGen{SecondGeneric}(BaseGen{SecondGeneric})
struct Base
    var Int x
struct Test(Base)
func test()
    user BaseGen?{Base} bb
    user BaseGen?{Test} bt
    user TestGen?{Base} tb
    user TestGen?{Test} tt
    bb := tb
    bt := tt
    bb := bt
    tb := tt
    bb := tt
; @ g t7
struct Base{Generic}
    weak Generic? first
struct Mid{First:Second}(Base{First})
    weak Second? second
struct Top{Generic}(Mid{Sys:Generic})
func fun(user Top?{File} t)
    user Mid?{Sys:File} m
    m := t
; @ eg te0
struct Base{Generic}
    weak Generic item
struct Test{Param}(Base{Param})
    weak Generic error
; @ eg te1
struct Base{Generic}
    weak Generic? item
struct Test(Base{File})
    func user set(weak String error)
        self.item := error
; @ eg te2
struct Base{Generic}
    weak Generic? item
struct Test{Param}(Base{Param})
    func user set(weak String error)
        self.item := error
; @ eg te3
struct Base{Pbase}
    weak Pbase? item
struct Mid{Pmid}(Base{Pmid})
struct Top(Mid{File})
struct Test(Top)
    func user set(weak String error)
        self.item := error
; @@ test-error-handling
; @ c t0
if-error i := t.num
    i := 0
; @ c t1
if-error fune()
    i := 0
else
    io := i
; @ c t2
if-ok i := t.num
    io := i
else
    i := 0
; @ c t3
if b
    io := 0
else-if-error fune()
    i := 0
else
    io := i
; @ c t4
if b
    io := 0
else-if-ok i := t.num
    io := i
else
    i := 0
; @ g t5
func fun(weak String s)->(var Bool fail)
    if-error s.clear()
        fail := true
; @ ec te0
if-error t.num
    i := 0
; @ ec te1
if-ok t.num
else
    i := 0
; @ ec te2
if-error fun0()
    i := 0
; @ ec te3
if-ok i := t.num
; @ ec te4
if-error i := t.num
; @ ec te5
if-ok i := t.num
else
; @ ec te6
if-error i := t!.num
    i := 0
; @@ test-try-catch
; @ c t0
try
    t.num := 1
    fun0()
catch
    i := t!.num
    fun4(copy 2)
; @ c t1
try
    t.num := 1
    fun0()
; @ c t2
try
    t.num := 1
    try
        fune()
    catch
        fun4(copy 2)
catch
    try
        i := arr[3]
    catch
        i := t!.num
; @ c t3
try
    var String{4} sa
    try
        s-var String{4} sb
    catch
        s-var String{4} sc
catch
    var String{4} sd
    try
        s-var String{4} se
    catch
        var String{4} sf
; @ g t4
func fun(weak String s)
    try
        s.clear()
        assert true
        assert-error s.clear()
        raise
; @ ec te0
try()
; @ ec te1
catch
; @ ec te2
try
catch()
; @ ec te3
try
; @ ec te4
try
    fune()
catch
; @ ec te5
try
    fune()
i := 2
catch
    i := 3
; @ ec te6
try
    i := 1
; @ ec te7
try
    fune()!
; @ ec te8
try
    assert! true
; @@ test-for-each
; @ g t0
struct TestIterator
    var Int counter
    new(copy Int count)
    func user step()->(var Int num, var Bool has-data)
func ! fun()->(var Int i)
    for n in TestIterator(copy 6)!
        var String{4} s
        i := n
; @ g t1
struct TestIterator
    owner String? value
    func user step()->(user String? text, var Bool has-data)
        text := self.value
func fun(user TestIterator iter)
    user String? t
    user String? s
    for t in iter
        s := t
; @ g t2
struct TestIterator{Generic}
    weak Generic? item
    func user ! step()->(user Generic? item, var Bool has-data)
        item := self.item!
class Test
    var Int x
    func dynamic user fun()
func ! fun(user TestIterator{File} fiter, user TestIterator{Test} titer)
    user File? of
    user Test? ot
    for f in fiter!
        of := f
    for t in titer!
        ot := t
; @ g t3
class TestIterator{Generic}
    weak Generic? item
    func dynamic user ! step()->(user Generic? item, var Bool has-data)
        item := self.item!
func ! f-mock(user TestIterator{File} iter)
    user File? f
    for t in iter!
        f := t
; @ g t4
struct TestIterator
    owner String? value
    func user step()->(strong String? text, var Bool has-data)
        if-error text := String{12}(user self.value)
            text := _
func fun(user TestIterator iter)
    owner String? s
    for t in iter
        s := t
; @ g t5
struct TestIterator
    owner String? value
    func user step()->(user String? text, var Bool has-data)
        text := self.value
func fun(user TestIterator iter)
    var Int x
    for _ in iter
        x += 1
; @ eg te0
struct TestIterator
    var Int num
func fun(user TestIterator iter)
    for n in iter
; @ eg te1
struct TestIterator
    var Int num
    func user step(user Int x)->(var Int num, var Bool has-data)
func fun(user TestIterator iter)
    for n in iter
; @ eg te2
struct TestIterator
    var Int num
    func user step()
func fun(user TestIterator iter)
    for n in iter
; @ eg te3
struct TestIterator
    var Int num
    func user step()->(var Int num)
func fun(user TestIterator iter)
    for n in iter
; @ eg te4
struct TestIterator
    var Int num
    func user step()->(var Int num, var Bool has-data, var Int error)
func fun(user TestIterator iter)
    for n in iter
; @ eg te5
struct TestIterator
    var Int num
    func user step()->(var Int num, var Int has-data)
func fun(user TestIterator iter)
    for n in iter
; @ eg te6
struct TestIterator
    var Int num
    func weak step()->(var Int num, var Bool has-data)
func fun(user TestIterator iter)
    for n in iter
; @ eg te7
struct TestIterator
    var Int num
    func user ! step()->(var Int num, var Bool has-data)
func fun(user TestIterator iter)
    for n in iter
; @@ test-complex-fields
; @ g t0
struct Test
    var Bstruct b
    s-var Bstruct sb
    func user ! test()
        weak Bstruct b(weak self.sb)
        b := self.sb
        self.b.meth()
        Bstruct.meth(user self.b)
        user Bstruct? b2(user self.b.b!)
        b2 := self.b.b!
        self.b.b!.meth()
        self.b.b := b
        Bstruct.meth(user self.b.b!)
        s-var Test t!
        self.b.x := 5
        Astruct.meth(user self.b)
        if self.b is b or b2 is-not self.b
        b := t.b
class Astruct
    var Int x
    func dynamic user? meth()
class Bstruct(Astruct)
    weak Bstruct? b
    func dynamic user? meth()
; @ g t1
struct Base
    var Int x
struct Test
    var String{10} s
    var Array{11:Int} ai
    var Array{12:Base} ab
    var Array{7:String{8}} as
    var Array{4:Array{5:Array{6:Int}}} aai
    var Array{4:Array{5:Array{6:Base}}} aab
    var Array{4:Array{5:String{6}}} aas
    func user ! test()->(var Char c, var Int i, user Base? b)
        c := self.s[3]!
        i := self.ai[4]
        b := self.ab[5]
        c := self.as[4][5]!
        i := self.aai[1][2][3]
        b := self.aab[1][2][3]
        c := self.aas[1][2][3]!
; @ eg te0
var Int x
struct Test
    var String{x} error
; @ eg te1
var Int x
struct Test
    var Array{x:Int} error
; @ eg te2
struct Test
    var Test error
; @ eg te3
struct Test
    var Base error
struct Base
    var Test t
; @ eg te4
struct Abase
    var Berror b
struct Aerror(Abase)
struct Bbase
    var Aerror a
struct Berror(Bbase)
; @ eg te5
struct Base
    var Int x
struct Test
    var Base b
    func user test(user Base b)
        self.b := b
; @ eg te6
struct Base
    var Int x
struct Test
    var Base b
    func user ! error()
        assert! self.b?
; @@ test-enum
; @ g t0
enum MyEnum
    VALUE
    ANOTHER-VALUE
    LAST-VALUE
func dummy()
    var Int x(copy MyEnum.VALUE)
    x += MyEnum.ANOTHER-VALUE
    x -= MyEnum.length
; @ g t1
enum MyEnum
    VALUE
    ANOTHER-VALUE
    LAST-VALUE
var Array{MyEnum.length:Int} arr
; @ eg te0
enum MyEnum
    VALUE
func dummy()
    var Int x(copy MyEnum.ERROR)
; @ ec te1
i := Error.VALUE
; @ eg te2
enum MyEnum
    VALUE
func dummy()
    var Int x(copy MyEnum.error)
; @ eg te3
enum My-Enum
; @ eg te4
enum MyEnum
    Error
; @ eg te5
enum MyEnum
    ERRoR
; @ eg te6
enum
; @ eg te7
enum MyEnum
    VALUE(0)
; @ eg te8
enum MyEnum
; @ eg te9
enum MyEnum
        VALUE
; @ eg te10
enum Error
    VALUE
enum Error
; @ eg te11
struct Error
    var Int x
enum Error
; @ eg te12
enum Error
    VALUE
struct Error
    var Int x
; @@ test-constant
; @ g t0
const Int NUMBER 12
; @ g t1
const Int SIZE 12
var Array{SIZE + 3:Int} arr
func fun(user Array{Int} a)
    fun(user arr)
; @ g t2
const Int LARGE 1 - (- (2 * SMALL))
const Int SMALL 7
; @ g t3
enum MyEnum
    VALUE
const Int NUMBER MyEnum.VALUE
; @ g t4
const Int NUMBER (128 div 3) mod 10
const Int D-CHAR 'a' + 3
; @ eg te0
const
; @ eg te1
const Bool
; @ eg te2
const Int
; @ eg te3
const Int Error
; @ eg te4
const Int ERROR
; @ eg te5
const Int NAME false
; @ eg te6
var Int x
const Int NAME x
; @ eg te7
const Int ERROR ERROR + 1
; @ eg te8
const Int A-ERROR B-ERROR
const Int B-ERROR - (2 * A-ERROR) + 1
; @ eg te9
const Int NUMBER 12
func dummy()
    NUMBER := 3
; @ eg te10
const Int NUMBER 12
func dummy()->(var Int x)
    dummy()->(var NUMBER)
; @@ test-module
; @ tg t0
enum Enum
    VALUE
const Int SIZE 12
struct Test
    var Int x
    func user meth()
var Test t
func ! fun()
    t.x := Enum.VALUE + SIZE
    fun()!
    Test.meth(user t)
    second.t.x := second.Enum.VALUE + second.SIZE
    second.fun()!
    second.Test.meth(user second.t)
    new second.Test nt!
; @-
module second
enum Enum
    VALUE
const Int SIZE 12
struct Test(ut.Test)
    func user meth()
var Test t
func ! fun()
    t.x := Enum.VALUE + SIZE
    fun()!
    Test.meth(user t)
    ut.t.x := ut.Enum.VALUE + ut.SIZE
    ut.fun()!
    ut.Test.meth(user ut.t)
    new ut.Test nt!
test dummy()
; @ tg t1
func fun()
struct Test
    var Int x
    func user meth()
        fun()
        self.meth()
; @-
module second
mock ut.fun()
mock ut.Test.meth()
test dummy()
; @ tg t2
native type Native
native var Int x
native func external()
func fun()
    x := 0
; @-
module second
test use()
    var ut.Native n
    ut.x := 2
    ut.external()
; @ ec te0
ut.error
; @ eg te1
var Int ut
; @ eg te2
func ut()
; @ eg te3
var error.Test x
; @ eg te4
var ut.Error x
; @ etg te5
; nothing
; @-
module(error)
; @ etg te6
; @-
module Error
; @ etg te7
; @-
module true
; @ etg te8
; @-
module file-open-read
; @ etg te9
; @-
func fun()
; @ ec te10
fun0().Error
; @ ec te11
i.Error
; @ ec te12
ut.Error.VALUE
; @@ test-memory
; @ g to0
struct Test
    owner String? s
    owner String str
    new!()
        self.str := String{12}()!
        self.str.clear()
func use(user String? s)
func take(owner String? s)
func give()->(owner String? s)
func ! fun(owner String? s, user Test tu, owner Test to)
    s := _
    s := String{12}()!
    s!.clear()
    to.s := String{12}()!
    user String? su(user tu.s)
    use(user tu.s)
    take(owner to.s)
    var Array{12:Int} arr
    arr[4] := arr[8]
    loop
        give()->(owner s)
        while s?
; @ g tu0
func deleting()->(owner String? s)
    s := _
func fun(user String s)->(owner String? so)
    s.clear()
    deleting()->(owner so)
; @ g tu1
func deleting()->(strong String? s)
    s := _
func ! fun()
    strong String? so(strong String{12}()!)
    user String? s(user so)
    s!.clear()
    deleting()->(strong so)
; @ g tu2
func deleting()->(strong String? s)
    s := _
func ! fun()
    strong String? so(strong String{12}()!)
    weak String? s(weak so)
    deleting()->(strong so)
    s!.clear()
; @ c tu3
user String? s
so := _
s := so
s!.clear()
; @ g tu4
struct Test
    weak String? s
    func user ! get()->(user String? s) _
func ! Test.get()->(user String? s)
    s := self.s!
func ! fun(user Test t)
    user String? s
    owner String? sowner(owner _)
    t.get()->(user s)!
    s!.clear()
    s := t.get()!
    s!.clear()
; @ c tu5
user String? s(user ostr)
ostr := _
for s in sarr!
    s!.clear()
; @ g tu6
func get()->(user String? s)
    s := _
func ! fun()
    loop
        user String? s
        while get()->(user s)?
        s!.clear()
; @ g tb0
struct Test
    owner String? s
func fun(var Test t)
    t.s := _
func use(owner Test to)
    fun(var to)
; @ c tb1
weak String s
s := so!
s!.clear()
; @ eg teo0
struct Test
    owner String s
    new()
func ! fun(user Test t)
    t.s := String{12}()!
; @ eg teo1
struct Aa
    var Int x
struct Bb
    owner Aa? a
func fun(user Bb b)
    owner Aa? a(owner b.a)
; @ eg teo2
struct Aa
    var Int x
struct Bb
    owner Aa? a
func take(owner Aa? a)
func fun(user Bb b)
    take(owner b.a)
; @ eg teo3
struct Aa
    owner String? s
struct Bb
    weak Aa? a
func ! fun(owner Array{Bb} b)
    b[3]!.a!.s := _
; @ eg teo4
struct Test
    owner String? s
func get-user()->(weak Test? t)
func ! fun()
    weak Test? t
    get-user()->(weak t)!.s := _
; @ eg teo5
struct Test
    owner String? s
func get-weak()->(weak Test? t)
func ! fun()
    get-weak()!.s := _
; @ eg teo6
struct Test
    owner String s
    new()
func fun(owner Test t)->(owner String? s)
    s := t.s
; @ eg teo7
struct Test
    owner String s
    new()
func fun(owner Test t)
    owner String s(owner t.s)
; @ eg teo8
struct Test
    owner String s
    new()
func take(owner String s)
func fun(owner Test t)->(owner String? s)
    take(owner t.s)
; @ ec teo9
new String{12} s!
new String{12} sg!
ostr := sg
sg := s
ostr!.clear()
sg.clear()
s.clear()
; @ eg teo10
struct Test
    owner Test? t
func ! fun()->(owner Test? t, owner Test? x)
    t := x!.t
    t := t!.t
; @ eg teo11
struct Test
    owner Test? t
func ! fun(owner Test? t)
    t := t!.t
; @ eg teo12
struct Test
    owner Test? t
func ! fun(owner Test? t)
    t!.t := t
; @ eg teo13
struct Test
    owner Test? t
func ! fun(owner Test? t)
    t!.t!.t := t!.t
; @ eg teo14
struct Test
    owner String s
    new()
func fun(owner Test t, user Test tu, owner String s, user String su)
    t.s :=: s
    su.clear()
    s.clear()
    t.s.clear()
    tu.s :=: s
; @ ec teo15
fun8(strong so)
so!.clear()
new String{12} s!
fun8(strong s)
s.clear()
; @ ec teo16
new Test tgood!
owner Test tbad
if b
    tgood := to!
tgood.meth()
if b
    tbad := to!
tbad.meth()
; @ ec teo17
new String{12} s!
repeat 12
    s.clear()
    ostr := s
    if b
        continue
    s := String{12}()!
; @ eg teo18
func fun(owner String? s, owner String? s2)
    fun(owner s, owner s)
; @ eg teo19
func fun()->(owner String? s, owner String? s2)
    fun()->(owner s, owner s2)
    fun()->(owner s, owner s)
; @ eg teo20
func fun(owner String? s)->(owner String? s2)
    fun(owner s)->(owner s)
; @ eg teo21
struct Test
    var Int x
func ! fun(owner Test? t)->(var Int x)
    x := fun(owner t)! + t!.x
; @ eg teo22
struct Test
    var Int x
func ! fun(owner Test? t)->(var Int x)
    x := t!.x + fun(owner t)!
; @ eg teo23
func ! fun(owner String s)->(var Int x)
    for _ in fun(owner s)!:s.length()
; @ ec teo24
new String{12} s!
try
    owner String s2(owner s)
    if b
        raise
    s := s2
s.clear()
; @ eg teo25
struct Test
    owner String? s
func error()
    var cdef.Pointer{Test} pt
    pt.get-ref-at(copy 0).s := _
; @ ec teu0
user String? s
so := _
c := s![2]!
; @ ec teu1
user String? s
user String? s2
so := _
s2 := s
; @ ec teu2
user String? s
so := _
s!.length()->(var i)
; @ ec teu3
user String? s
so := _
String.clear(user s!)
; @ ec teu4
user String? s
so := _
b := not (false or s!.length() > 3)
; @ eg teu5
func deleting(owner String? s)
func fun(user String s)
    deleting(owner _)
    s.clear()
; @ eg teu6
func deleting()->(owner String? s)
    s := _
func proxy()
    deleting()
func fun(user String s)
    proxy()
    s.clear()
; @ eg teu7
func deleting()->(owner String? s)
    proxy()
    s := _
func proxy()
    deleting()
func fun(user String s)
    proxy()
    s.clear()
; @ eg teu8
struct Test
    var Int x
    func user deleting()->(owner String? s)
        s := _
    func user fun(user String s)
        self.deleting()
        s.clear()
; @ eg teu9
func deleting()->(owner String? s)
    s := _
func fun(user String s)
    deleting()
    s.clear()
; @ eg teu10
func deleting()
    owner String? s
func fun(user String s)
    deleting()
    s.clear()
; @ eg teu11
func deleting()
    var String{12} s
func fun(user String s)
    deleting()
    s.clear()
; @ eg teu12
func deleting()
    strong String? s
func fun(user String s)
    deleting()
    s.clear()
; @ ec teu13
user Array{Char} a(user ostr!)
ostr := _
c := a[2]!
; @ eg teu14
func ! deleting()
    var Int x(copy String{12}()!.length())
func ! fun(user String s)
    deleting()!
    s.clear()
; @ eg teu15
struct Test
    owner String? s
func ! deleting(owner Test? ta, owner Test? tb)
    ta!.s := tb!.s
func ! fun(user String s)
    deleting(owner _, owner _)!
    s.clear()
; @ ec teu16
user Test? tt
d!.set(owner _)
tt.meth()
; @ eg teu17
struct Base{Atype}
    var Int x
    func user fun(owner Atype? a)
struct Test{Btype}(Base{Btype})
    func user fun()
        base(owner _)
func ! fun(user File f)
    var Test{File} t
    t.fun()
    f.putc(copy 'a')!
; @ eg teu18
struct Base
    var Int x
struct Test(Base)
func deleting(owner Base? b)
func fun(user Test t)
    deleting(owner _)
    t.x := 0
; @ eg teu19
struct Base
    var Int x
struct Test(Base)
struct Other(Base)
func deleting(owner Test? t)
func fun(user Base b, user Other o)
    deleting(owner _)
    o.x := 0
    b.x := 0
; @ eg teu20
class Base
    var Int x
    func dynamic user fun()
class Test(Base)
    func dynamic user fun()
        owner String? s
func fun(user String s, user Base b)
    b.fun()
    s.clear()
; @ eg teu21
class Base
    var Int x
    func dynamic user fun()
class Test{Generic}(Base)
    func dynamic user fun()
func fun(user String s, user Base b)
    b.fun()
    s.clear()
; @ eg teu22
class Base
    var Int x
    func dynamic user? fun(owner Base? b)
        recursive()
class Test{Generic}(Base)
    func dynamic user? fun(owner Base? b)
func recursive()
    Base.fun(user _, owner _)
func fun(user String s)
    recursive()
    s.clear()
; @ ec teu23
user String? s
t!.fun!()
s!.clear()
; @ eg teu24
func ! deleting(copy Func?{()} f)
    f!()
func ! fun(user String s)
    deleting(copy _)!
    s.clear()
; @ eg teu25
func fun()->(user String? s)
; @ eg teu26
func deleting()
    owner String? s
func fun()->(user String? s)
    s := _
    deleting()
; @ eg teu27
func fun(owner String so)->(user String? s)
    s := _
; @ eg teu28
func fun()->(user String? s)
    owner String? so
    s := _
; @ eg teu29
struct Test
    owner String? s
func fun(owner Test? t, user String s)
    t := _
    s.clear()
; @ eg teu30
struct Other
    owner String? s
struct Test
    owner Other? o
func fun(owner Test? t, user String s)
    t := _
    s.clear()
; @ eg teu31
struct Base
    owner String? s
struct Test(Base)
struct Other(Base)
    owner File? f
func ! fun(owner Test? t, user String s, user File f)
    t := _
    f.putc(copy 'a')!
    s.clear()
; @ eg teu32
struct Base
    var Int x
struct Test(Base)
    owner String? s
func fun(owner Base? b, user String s)
    b := _
    s.clear()
; @ eg teu33
struct Test{Generic}
    owner Generic? x
func ! fun(owner Test?{File} t, user File f)
    t := _
    f.putc(copy 'a')!
; @ eg teu34
struct Base{Generic}
    owner Generic? x
struct Test{Data}(Base{Data})
func ! fun(owner Test?{File} t, user File f)
    t := _
    f.putc(copy 'a')!
; @ eg teu35
main
    owner String? so(owner String{12}()!)
    user String? su(user so)
    so := _
    su!.clear()
; @ ec teu36
assert! str?
; @ ec teu37
assert-error! str.clear()
; @ ec teu38
if str?
; @ ec teu39
for _ in str!.length():2
; @ ec teu40
for _ in 2:str!.length()
; @ ec teu41
for _ in str!
; @ ec teu42
if b
    str!.clear()
; @ ec teu43
if false
    str := ostr
str!.clear()
; @ ec teu44
str := ostr
repeat 12
    str!.clear()
    ostr := _
    if b
        continue
    str := ostr
; @ ec teu45
str := ostr
try
    ostr := _
    if b
        raise
    str := ostr
str!.clear()
; @ eg teu46
func fun(user String sin)->(user String? sout)
    if false
        sout := sin
; @ eg teu47
func fun(user String sin)->(user String? sout)
    if true
        return
    sout := sin
; @ ec teu48
str := ostr
for n in str!
    ostr := _
; @ eg tev0
func fun(var String s)
func error(user String s)
    fun(var s)
; @ eg tev1
func fun(owner String s)
func error(var String s)
    fun(owner s)
; @ eg tev2
func error(var String a, owner String b)
    a := b
; @ eg tev3
func error()->(var String s)
; @ eg tee0
struct Error
    weak String s
; @ eg tee1
struct Error
    owner String s
    new()
; @ eg tee2
struct Error
    weak String s
    new!(strong String s)
        self.s!.clear()
        self.s := s
; @ eg tee3
struct Error
    owner String s
    new!()
        self.fun()
        self.s := String{12}()!
    func user fun()
        self.s.clear()
; @ eg tee4
struct Error
    owner String s
    new!()
        error(user self)
        self.s := String{12}()!
func error(user Error e)
    e.s.clear()
; @ eg tee5
struct Error
    owner String s
    new!()
        if false
            self.s := String{12}()!
; @ eg tee6
struct Error
    owner String s
    new() _
func Error.new()
; @ ec tec0
str := str
; @ eg tec1
struct Error
    user String s
; @@ test-c-objects
; @ c t0
var cdef.Char c-char
var cdef.Uchar c-uchar
var cdef.Short c-short
var cdef.Ushort c-ushort
var cdef.Int c-int
var cdef.Uint c-uint
var cdef.Long c-long
var cdef.Ulong c-ulong
var cdef.Size c-size
var cdef.Float c-float
var cdef.Double c-double
var cdef.LongDouble c-long-double
c-char := i
i := c-char
c-uchar := i
i := c-uchar
c-short := i
i := c-short
c-ushort := i
i := c-ushort
c-int := i
i := c-int
c-uint := i
i := c-uint
c-long := i
i := c-long
c-ulong := i
i := c-ulong
c-size := i
i := c-size
c-float := i
i := c-float
c-double := i
i := c-double
c-long-double := i
i := c-long-double
; @ c t1
var cdef.Pointer p-void
var cdef.Pointer{cdef.Char} p-char
var cdef.Pointer{cdef.Uint} p-uint
var cdef.Pointer{Test} p-test
var cdef.Pointer{cdef.Pointer{cdef.Int}} pp-int
var cdef.Pointer{cdef.Pointer{cdef.Pointer{cdef.Char}}} ppp-char
p-void := p-char
p-uint := p-void
p-char := p-uint
; @ c t2
var cdef.Int int
var cdef.Pointer{cdef.Int} p-int
var cdef.Pointer{cdef.Pointer{cdef.Int}} pp-int
user Array?{cdef.Int} arr-int
p-int.set-from-array(user arr-int!)
p-int.set-point-to(var int)
pp-int.set-point-to(var p-int)
p-int := pp-int.get-pointed-at(copy 0)
int := p-int.get-pointed-at(copy 3)
var Test test
user Test u-test(user test)
var cdef.Pointer{Test} p-test
user Array?{Test} arr-test
p-test.set-from-array(user arr-test!)
p-test.set-from-ref(user test)
u-test := p-test.get-ref-at(copy 5)
; @ c t3
var cdef.Pointer{Char} p-char
p-char.set-from-array(user ostr!)
ostr!.copy-from-pointer(copy p-char)!
ostr!.set-null-term-length()
; @ ec te0
var cdef.Pointer{Ta} error
; @ ec te1
var cdef.Pointer{Int} p-int
i := p-int.get-ref-at(copy 5)
; @ ec te2
var Test tv
var cdef.Pointer{Test} p-test
tv := p-test.get-pointed-at(copy 0)
; @