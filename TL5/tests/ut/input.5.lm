struct Test
    var Uint32 num
    weak Test? t
    var Func?{()} fun
    func user? meth()
class Ta(Test)
    var Uint32 numa
    func inst user? metha()
    func dynamic user? dyn()
class Tb(Ta)
    var Uint32 numb
    new!(copy Uint32 num)
    func inst user? methb()
    func dynamic user? dyn()
class Tc(Tb)
    var Uint32 numc
    func inst user? methc()
    func dynamic user? dyn()
struct Data{Generic}
    weak Generic? item
    func user? set(owner Generic? item)
    func user? get()->(weak Generic? item)

func fun0()
func fun1(copy Uint32 x, user String? s, owner String? o)
func fun2()->(strong String? s, var Uint32 x)
func fun3(copy Uint32 x)->(strong String? s)
func fun4(copy Uint32 x)
func fun5(copy Uint32 x)->(var Uint32 y)
func fun6(copy Uint32 x, copy Uint32 y)->(var Uint32 n, var Uint32 m)
func fun7(weak Tb? tb)->(weak Tb? tbo)
func fun8(strong String? s)
func ! fune()

var Uint32 i
var Sint32 j
var Byte bt
var Char c
var Bool b
owner String? ostr
owner Buffer? buff
weak Array?{Uint32} arr
weak Test? t
weak Ta? ta
strong Tb? tb
weak Tc? tc
weak Data?{Test} d
weak Array?{String} sarr
weak Array?{Buffer} barr

func ! mock(user String? str, user Buffer? bfr)->(strong String? so, var Uint32 io, strong Test? to, weak Tc? tco)
; @@ test-int-expression
; @ c test-int-expression-0
i := 0
; @ c test-int-expression-1
i := 9630
; @ c test-int-expression-2
j := -9630
; @ c test-int-expression-3
i := 07520
; @ c test-int-expression-4
j := -07520
; @ c test-int-expression-5
i := 0xfda940
; @ c test-int-expression-6
j := -0xfda940
; @ c test-int-expression-7
i := 0xFDA940
; @ c test-int-expression-8
j := -0xFDA940
; @ c test-int-expression-9
i := 0b100101
; @ c test-int-expression-10
j := -0b100101
; @ ec test-int-expression-e0
2a
; @ ec test-int-expression-e1
0a
; @ ec test-int-expression-e2
038
; @ ec test-int-expression-e3
0b021
; @ ec test-int-expression-e4
0xadg
; @@ test-byte-expression
; @ c test-byte-expression-0
bt := 0
; @ c test-byte-expression-1
bt := 127
; @ c test-byte-expression-2
bt := 075
; @ c test-byte-expression-3
bt := 0xfd
; @ c test-byte-expression-4
bt := 0xFD
; @ c test-byte-expression-5
bt := 0b10010100
; @@ test-char-expression
; @ c test-char-expression-0
c := 'a'
; @ c test-char-expression-1
c := '\''
; @ c test-char-expression-2
c := '\n'
; @ c test-char-expression-3
c := '\x0f'
; @ c test-char-expression-4
c := '\x7A'
; @ c test-char-expression-5
c := '\173'
; @ c test-char-expression-6
var Int{10:10} c10(copy '\n')
var Int{15:15} c15(copy '\x0f')
var Int{39:39} c39(copy '\'')
var Int{97:97} c97(copy 'a')
var Int{169:169} c169(copy '\xA9')
var Int{184:184} c184(copy '\270')
; @ fec test-char-expression-e0
c := '''
; @ fec test-char-expression-e1
c := '\'
; @ fec test-char-expression-e2
c := 'aa
; @ ec test-char-expression-e3
c := '\c'
; @ ec test-char-expression-e4
c := 'aaaa'
; @ ec test-char-expression-e5
c := '\x6g'
; @ ec test-char-expression-e6
c := '\058'
; @ ec test-char-expression-e7
c := ''
; @ ec test-char-expression-e8
c := 'aa'
; @ ec test-char-expression-e9
c := 'aaa'
; @ ec test-char-expression-e10
c := 'aaaaa'
; @ ec test-char-expression-e11
c := '\777'
; @ ec test-char-expression-e12
c := '\0'
; @ ec test-char-expression-e13
c := '\x00'
; @@ test-string-expression
; @ c test-string-expression-0
bfr := "some string"
; @ c test-string-expression-1
bfr := "\nstring'\t\"\xd5with\x21\\\'\307formatting\n"
; @ c test-string-expression-2
bfr := "line\
        split\
        string\
        "
; @ c test-string-expression-3
bfr := "multi
        line
        string
        "
; @ c test-string-expression-4
bfr := "line\
         split"
; @ c test-string-expression-5
bfr := "×©Ö¸××œ×•Ö¹× ðŸ‘‹ðŸ¾ ×¢×•Ö¹×œÖ¸Ö½× ðŸŒŽ"
; @ fec test-string-expression-e0
bfr := "aaa
; @ fec test-string-expression-e1
bfr := "
; @ ec test-string-expression-e2
"error"+"string"
; @ ec test-string-expression-e3
bfr := "indention
    too short"
; @ ec test-string-expression-e4
bfr := "indention\
    too short"
; @ ec test-string-expression-e5
bfr := "\70"
; @ ec test-string-expression-e6
bfr := "\xa"
; @ ec test-string-expression-e7
bfr := "aa \787 bb"
; @ ec test-string-expression-e8
bfr := "aa \x8g bb"
; @ ec test-string-expression-e9
bfr := "aa \c bb"
; @ ec test-string-expression-e10
bfr := "aa \777 bb"
; @ ec test-string-expression-e11
bfr := "aa \x00 bb"
; @ g test-string-expression-large
func fun()
    user Buffer s(user "\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789")
; @@ test-buffer-expression
; @ c test-buffer-expression-0
bfr := `4a00e2ff59`
; @ c test-buffer-expression-1
bfr := `4a00
        e2ff
        59a8`
; @ c test-buffer-expression-2
bfr := `
        4a00
        e2ff
        59a8
        `
; @ fec test-buffer-expression-e0
bfr := `0000
; @ fec test-buffer-expression-e1
bfr := `
; @ ec test-buffer-expression-e2
bfr := `4a00
    e2ff
    59a8`
; @ ec test-buffer-expression-e3
bfr := `4a00e2fg59a8`
; @ ec test-buffer-expression-e4
bfr := `4a00e2ff59a`
; @ g test-buffer-expression-large
func fun()
    user Buffer b(user `
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899`)
; @@ test-empty-expression
; @ c test-empty-expression-0
bfr := _
; @ c test-empty-expression-1
t := _
; @ c test-empty-expression-2
so := _
; @ c test-empty-expression-3
b := t is _ or ta is-not _
; @ ec test-empty-expression-e0
i := _
; @@ test-member-expression
; @ c test-member-expression-0
i := t!.num
; @ c test-member-expression-1
i := tc!.numb
; @ c test-member-expression-2
i := tc!.num
; @ c test-member-expression-3
i := to!.num
; @ c test-member-expression-4
tco := tc
i := tco!.num
; @ c test-member-expression-5
i := t!.t!.num
; @ c test-member-expression-6
i := t!.t!.t!.num
; @ ec test-member-expression-e0
error
; @ ec test-member-expression-e1
(i := 1).error
; @ ec test-member-expression-e2
t.error
; @ ec test-member-expression-e3
5.error
; @@ test-slice-expression
; @ c test-slice-expression-0
bt := buff![13]!
; @ c test-slice-expression-1
user Array?{Byte} y
y := buff![2:6]!
; @ c test-slice-expression-2
i := arr![13]!
; @ c test-slice-expression-3
user Array?{Uint32} x
x := arr![2:i]!
; @ c test-slice-expression-4
buff![4]! := bt
; @ c test-slice-expression-5
arr![4]! := i
; @ c test-slice-expression-6
strong Array?{Test} tarr
t := tarr![3]!
; @ c test-slice-expression-7
var Array{8:Buffer{5}} vba
user Buffer bf(user vba[3])
user Array{Buffer} ba(user vba[2:4])
; @ g test-slice-expression-8
func ! fun(
        temp Buffer b,
        strong Array{Buffer} ba)
    var Byte y(copy b[5]!)
    user Array{Byte} bpart(user b[4:2]!)
    user Buffer bi(user ba[3]!)
; @ c test-slice-expression-9
strong Array?{String} sa
sa![3]!.new(user "text")!
sa := _
; @ c test-slice-expression-10
strong Array?{Array{Uint32}} aai
arr := aai![3]!
weak Array?{Array{Uint32}} ua(weak aai![2:4]!)
; @ c test-slice-expression-11
strong Array?{Array{Array{Array{Uint32}}}} aai
weak Array?{Array{Array{Uint32}}} ua(weak aai![3]!)
weak Array?{Array{Array{Array{Uint32}}}} uaa(weak aai![2:4]!)
; @ c test-slice-expression-12
strong Array?{Array{Array{String}}} aas
weak Array?{Array{String}} wsa(weak aas![3]!)
weak Array?{Array{Array{String}}} wsaa(weak aas![2:4]!)
aas := _
strong Array?{Array{Array{Buffer}}} aab
weak Array?{Array{Buffer}} wba(weak aab![3]!)
weak Array?{Array{Array{Buffer}}} wbaa(weak aab![2:4]!)
aas := _
; @ c test-slice-expression-13
var Array{8:Array{7:Array{6:Array{5:Uint32}}}} aai
user Array?{Array{Array{Uint32}}} ua(user aai[3])
user Array?{Array{Array{Array{Uint32}}}} uaa(user aai[2:4])
; @ c test-slice-expression-14
var Array{8:Array{7:Array{6:Buffer{5}}}} aab
user Array?{Array{Buffer}} uba(user aab[i]!)
user Array?{Array{Array{Buffer}}} ubaa(user aab[2:4])
; @ g test-slice-expression-15
func fun()
    var Array{8:Array{7:Array{6:Buffer{5}}}} aab
    user Buffer b(user aab[4][3][2])
; @ c test-slice-expression-16
user Array?{Byte} x
x := ostr!
user Array?{Byte} y
y := buff
; @ c test-slice-expression-17
new Buffer{12} s!
sys.print(user s)!
new Buffer{12} bf!
; @ g test-slice-expression-18
struct Test
    owner String? s
    owner Buffer? b
func fun()
    var Test t
    var Array{6:Test} a
; @ c test-slice-expression-19
new Array{i:Uint32} a!
var Sint8 x
var Int{-6:0} y
i := wraparound a[x:x]![y:y + 1]![x]! + a[i:i + 1]![0:y + 1]![y]! + a[0:1][i]!
var Int{100:200} length
new Array{length:Uint32} aa!
var Int{10:20} xx(copy 10)
var Int{0:8} yy
i := aa[xx:xx][yy]
var Array{12:Uint32} ab
i := ab[3:4][3]
; @ c test-slice-expression-20
i := buff![2]! + buff![1:3]![2]
; @ g test-slice-expression-21
struct Test
    var Array{4:Uint32} va
    weak Array?{4:Uint32} wa
func ! fun(weak Array{4:Uint32} a4, weak Array{Uint32} ad)->(
        weak Array{6:Uint32} oa6, weak Array{Uint32} oad)
    oa6 := ad!
    oad := a4
    s-var Array{8:Uint32} a8!
    oa6 := a8
    oad := a8
    var Int i(copy a4![2])
    i := ad![2]!
    i := a8[2]
    fun(weak ad!, weak a4)->(weak oa6, weak oad)!
    fun(weak a8, weak a8)->(weak oad, weak oa6!)!
    user Array{2:Uint32} a2
    a2 := a8
    a2 := a4!
    a2 := ad!
    ; line 20
; @ g test-slice-expression-22
func ! fun(owner Array?{4:Uint32} a4, owner Array?{Uint32} ad)->(
        owner Array?{4:Uint32} oa4, owner Array?{Uint32} oad)
    oa4 := ad!
    oad := a4
    fun(owner a4, owner ad)->(owner oa4, owner oad)!
    fun(owner ad!, owner a4)->(owner oad, owner oa4!)!
; @ g test-slice-expression-23
struct Test
    var Array{6:Array{7:Array{8:Uint32}}} av
    weak Array?{6:Array{7:Array{8:Uint32}}} as
    weak Array?{6:Array{Array{8:Uint32}}} ams
    weak Array?{Array{7:Array{Uint32}}} amd
    weak Array?{Int{3:9}:Array{Int{4:10}:Array{Int{5:11}:Uint32}}} ar
    weak Array?{Array{Array{Uint32}}} ad
func ! fun(
        weak Array{6:Array{7:Array{8:Uint32}}} as,
        weak Array{6:Array{Array{8:Uint32}}} ams,
        weak Array{Array{7:Array{Uint32}}} amd,
        weak Array{Int{3:9}:Array{Int{4:10}:Array{Int{5:11}:Uint32}}} ar,
        weak Array{Array{Array{Uint32}}} ad)->(
        weak Array{4:Array{7:Array{8:Uint32}}} oas,
        weak Array{4:Array{Array{8:Uint32}}} oams,
        weak Array{Array{7:Array{Uint32}}} oamd,
        weak Array{Int{3:9}:Array{Int{4:10}:Array{Int{5:11}:Uint32}}} oar,
        weak Array{Array{Array{Uint32}}} oad)
    oas := as
    ; line 20
    oas := ams!
    oas := amd!
    oas := ar!
    oas := ad!
    oams := as
    oams := ams
    oams := amd!
    oams := ad!
    oams := ar!
    oamd := as
    oamd := ams!
    oamd := amd
    oamd := ar!
    oamd := ad!
    oar := as
    oar := ams!
    oar := amd!
    oar := ar
    oar := ad!
    ; line 40
    oad := as
    oad := ams
    oad := amd
    oad := ar
    oad := ad
    fun(weak as, weak as, weak as, weak as, weak as)->(
            weak oas, weak oams, weak oamd, weak oar, weak oad)!
    fun(weak ams!, weak ams, weak ams!, weak ams!, weak ams)->(
            weak oad, weak oas!, weak oams!, weak oamd!, weak oar!)!
    fun(weak amd!, weak amd!, weak amd, weak amd!, weak amd)->(
            weak oar, weak oad, weak oas!, weak oams!, weak oamd!)!
    fun(weak ar!, weak ar!, weak ar!, weak ar, weak ar)->(
            weak oamd, weak oar!, weak oad, weak oas!, weak oams!)!
    fun(weak ad!, weak ad!, weak ad!, weak ad!, weak ad)->(
            weak oams, weak oamd!, weak oar!, weak oad, weak oas!)!
    ; line 56
; @ c test-slice-expression-24
new Array{i:Byte} abi!
new Array{6:Byte} ab6!
owner Array{6:Byte} ab6o(owner Array{6:Byte}()!)
user Array{Byte} uab(user abi)
uab := ab6
uab := ab6o
; @ c test-slice-expression-25
user Array?{Int{3:8}:Byte} a3-8(user _)
user Array?{6:Byte} a6
user Array?{Byte} ad
a3-8 := a6
a3-8 := ad!
a6 := a3-8!
ad := a3-8
new Array{j:Byte} as!
; @ ec test-slice-expression-e0
arr[2
; @ ec test-slice-expression-e1
arr[2:3
; @ ec test-slice-expression-e2
(i := 3)[2]!
; @ ec test-slice-expression-e3
i[2]!
; @ ec test-slice-expression-e4
arr![str]!
; @ ec test-slice-expression-e5
arr![3:str]!
; @ ec test-slice-expression-e6
arr![i wraparound+= 3]!
; @ ec test-slice-expression-e7
bfr![2:5]! := buff
; @ ec test-slice-expression-e8
arr![7:2]! := Array{5:Uint32}()!
; @ ec test-slice-expression-e9
user Array?{Test} at
at![0] := t
; @ ec test-slice-expression-e10
so := sarr![3]!
; @ ec test-slice-expression-e11
var Array{3:Tc} error
; @ eg test-slice-expression-e12
struct Test
    var Uint32 x
    new()
func func(user Array{Test} error)
; @ ec test-slice-expression-e13
i := arr![i]
; @ ec test-slice-expression-e14
var Array{0:Uint32} error
; @ ec test-slice-expression-e15
arr![-1]
; @ ec test-slice-expression-e16
var Int{-10:-2} x
arr![x]
; @ ec test-slice-expression-e17
arr![1:0]
; @ ec test-slice-expression-e18
var Int{-10:0} x
arr![1:x]
; @ ec test-slice-expression-e19
s-var Array{3:Uint32} a!
arr := a[1:3]
; @ ec test-slice-expression-e20
var Int{-10:10} length
new Array{length:Uint32} a!
var Int{8:80} x
arr := a[x:x]
; @ ec test-slice-expression-e21
owner Array?{6:Byte} a6
owner Array?{4:Byte} a4(owner a6)
; @ ec test-slice-expression-e22
user Array?{4:Byte} a4
user Array?{6:Byte} a6(user a4)
; @ ec test-slice-expression-e23
owner Array?{2:Array{6:Byte}} a6
owner Array?{2:Array{4:Byte}} a4(owner a6)
; @ eg test-slice-expression-e24
func fun()->(user Array{Byte} ao)
    user Array{6:Byte} a
    fun()->(user a)
    fun()->(user ao)
; @ ec test-slice-expression-e25
user Array{Sint8:Byte} error
; @ ec test-slice-expression-e26
user Array{String:Byte} error
; @ ec test-slice-expression-e27
user Array?{Int{10:20}:Byte} al
user Array?{Int{100:200}:Byte} ah
al := ah
; @ ec test-slice-expression-e28
weak Array?{Int{10:20}:Uint32} a
a := arr
; @@ test-call-expression
; @ c test-call-expression-0
fun0()
; @ c test-call-expression-1
fun1(copy 3, user ostr, owner _)
; @ c test-call-expression-2
fun2()->(strong so, var io)
; @ c test-call-expression-3
var Uint32 x
strong String? s
fun2()->(strong s, var x)
; @ c test-call-expression-4
fun3(copy 0)->(strong so)
; @ c test-call-expression-5
var Uint32 x
fun4(copy fun5(copy 3)->(var x))
; @ c test-call-expression-6
fun6(
        copy 2,
        copy 3)->(
        var i,
        var io)
; @ c test-call-expression-7
fun5(copy 4)
; @ c test-call-expression-8
io := fun5(copy 4)
; @ c test-call-expression-9
so := fun3(copy 7)
; @ c test-call-expression-10
t!.meth()
; @ c test-call-expression-11
to.meth()
; @ c test-call-expression-12
tc!.methc()
; @ c test-call-expression-13
tc!.methb()
; @ c test-call-expression-14
tc!.meth()
; @ c test-call-expression-15
tco := tc
tco!.meth()
; @ c test-call-expression-16
t!.t!.meth()
; @ c test-call-expression-17
fun1(copy 3, user ostr, owner so)
; @ c test-call-expression-18
fun3(copy 1)
fun5(copy 2)
; @ g test-call-expression-19
class Base
    var Uint32 x
    func dynamic user ! meth(owner Base b)
class Test(Base)
    func dynamic user ! meth(owner Base b)
        new Test t!
        base(owner t)!
; @ g test-call-expression-20
class Test
    var Uint32 x
    func dynamic user meth()
func ! mock()->(weak Test? t)
    mock()->(weak t)!.meth()
; @ g test-call-expression-21
class Test
    var Uint32 x
    func dynamic user ! meth()->(weak Test? t)
        self.meth()!.meth()!
; @ g test-call-expression-22
func fun()->(owner Array?{String} astr)
    fun()->(owner astr)
; @ g test-call-expression-23
func ! fun(temp String s)
    var String vars
    s-var String s-vars!
    owner String owners(owner String()!)
    strong String strongs(strong String()!)
    user String users(user s)
    fun(temp s)!
    fun(temp vars)!
    fun(temp s-vars)!
    fun(temp owners)!
    fun(temp strongs)!
    s.clear()
; @ c test-call-expression-24
strong String? s
weak String? sw
fun1(copy 0, user sw!, owner s)
; @ c test-call-expression-25
fun8(strong ostr!)
; @ c test-call-expression-26
fune()!
; @ c test-call-expression-27
var Uint8 u8
var Sint8 s8
var Uint32 u32
var Sint32 s32
var Uint64 u64
var Sint64 s64
u8 := wraparound fun5(copy 0)
s8 := clamp fun5(copy 1)
fun5(copy 50)->(var u32)
s32 := clamp fun5(copy 2)
fun5(copy 3)->(var u64)
fun5(copy 4)->(var s64)
; @ g test-call-expression-28
func ! get()->(weak String res)
    weak String s
    get()->(weak s)!
    s!.clear()
    res := s
; @ c test-call-expression-29
fun7(weak tb)->(weak t)
; @ g test-call-expression-30
func ! fun(user Uint32? x, strong Uint32? y)->(weak Uint32? i, owner Uint32? j)
    new Uint32 z!
    x!.value := wraparound x!.value + y!.value + i!.value + j!.value
    i!.value := 4
    weak Uint32? a
    strong Uint32? b(strong j!)
    j := y
    y := b
    x := j
    fun(user x, strong y)->(weak i, owner j)!
    fun(user i!, strong j!)->(weak a, owner b!)!
; @ g test-call-expression-31
func ! fun(user Uint32 x, weak Uint32 y, temp Uint32 z)
    s-var Uint32 i!
    var Uint32 j
    fun(user i, weak i, temp j)!
; @ ec test-call-expression-e0
function( copy 1)
; @ ec test-call-expression-e1
function(user)
; @ ec test-call-expression-e2
function(copy 4,copy 3)
; @ ec test-call-expression-e3
function(copy 2
; @ ec test-call-expression-e4
function(error 4)
; @ ec test-call-expression-e5
(i := 0)()
; @ ec test-call-expression-e6
i()
; @ ec test-call-expression-e7
fun5(copy 0)->(var 4)
; @ ec test-call-expression-e8
fun7(weak _)->(weak tc)
; @ ec test-call-expression-e9
fun5(copy i := 1)
; @ ec test-call-expression-e10
fun5(user 8)
; @ ec test-call-expression-e11
fun1(copy 3, user str, owner str)
; @ ec test-call-expression-e12
fun3(copy 3)->(strong str)
; @ ec test-call-expression-e13
fun7(weak _)->(weak tb)
; @ ec test-call-expression-e14
fun0(copy i)
; @ ec test-call-expression-e15
fun1()
; @ ec test-call-expression-e16
fun0()->(copy i)
; @ ec test-call-expression-e17
fun2()
; @ eg test-call-expression-e18
struct Base
    var Uint32 x
    func user meth(owner Base b)
struct Test(Base)
    func user meth(owner Test t)
        base(owner t)
; @ ec test-call-expression-e19
var String text
fun1(copy 3, user str, owner text)
; @ ec test-call-expression-e20
owner Tb? tbo
fun7(weak tbo)
; @ ec test-call-expression-e21
fune()
; @ eg test-call-expression-e22
func ! fune()
func fun()
    fune()!
; @ ec test-call-expression-e23
strong String s
fun3(copy 0)->(strong s)
; @ eg test-call-expression-e24
func fun(weak String in)->(weak String out)
    weak String s
    s := fun(weak s)
    out := s
; @ ec test-call-expression-e25
fun0()->()
; @ ec test-call-expression-e26
fun6(copy i, copy i)->(var io, var io)
; @@ test-type-expression
; @ c test-type-expression-0
Test.meth(user t!)
; @ c test-type-expression-1
Tb.methb(user tc!)
; @ c test-type-expression-2
Tc.meth(user tc!)
; @ ec test-type-expression-3
Error
; @@ test-base-expression
; @ g test-base-expression-0
struct Base
    var Uint32 x
    func user methb()
struct Mid(Base)
    func user methm()
struct Top(Mid)
    func user methb()
    func user methm()
        base.methm()
; @ g test-base-expression-1
struct Base
    var Uint32 x
    func user methb()
struct Mid(Base)
    func user methm()
struct Top(Mid)
    func user methb()
    func user methm()
        base.methb()
; @ ec test-base-expression-e0
base
; @ eg test-base-expression-e1
struct Test
    var Uint32 x
    func user mock()
        base
; @ eg test-base-expression-e2
struct Base
    var Uint32 x
struct Test(Base)
    var Uint32 x
    func user mock()
        base()
; @ eg test-base-expression-e3
struct Base
    var Uint32 x
struct Test(Base)
    func user mock()
        base := self
; @ eg test-base-expression-e4
struct Base
    var Uint32 x
struct Test(Base)
    func user mock()->(var Uint32 x)
        x := base.x
; @@ test-block-expression
; @ c test-block-expression-0
i := 2 + (123)
; @ c test-block-expression-1
i := (123)
; @ c test-block-expression-2
i := wraparound (123 * (i - 4)) + 2
; @ ec test-block-expression-3
(error
; @@ test-unary-expression
; @ c test-unary-expression-0
j := - j
; @ c test-unary-expression-1
j := -
        j
; @ c test-unary-expression-2
i := - - i
; @ c test-unary-expression-3
b := not b
; @ c test-unary-expression-4
b := not i > 3
; @ c test-unary-expression-5
i := clamp i + 1
; @ c test-unary-expression-6
j := clamp j - 1
; @ c test-unary-expression-7
var Sint8 x(copy clamp j)
x := clamp j
; @ c test-unary-expression-8
i := clamp! i + 1
; @ c test-unary-expression-9
j := clamp! j - 1
; @ c test-unary-expression-10
j := clamp! j * 2
; @ c test-unary-expression-11
if-error i := clamp? i + 1
    i := 12
; @ c test-unary-expression-12
fun4(copy clamp i + 1)
new Tb ttb(copy clamp i + 1)!
ttb := Tb(copy clamp i + 1)!
; @ c test-unary-expression-13
fun4(copy clamp! i + 1)
; @ c test-unary-expression-14
if-error fun4(copy clamp? i + 1)
    i := 12
; @ c test-unary-expression-15
i := wraparound i + 1
; @ c test-unary-expression-16
fun4(copy wraparound i + 1)
new Tb ttb(copy wraparound i + 1)!
ttb := Tb(copy wraparound i + 1)!
; @ ec test-unary-expression-e0
{45}
; @ ec test-unary-expression-e1
-[
; @ ec test-unary-expression-e2
+ 2
; @ ec test-unary-expression-e3
- (i := 2)
; @ ec test-unary-expression-e4
- (i > 4)
; @ ec test-unary-expression-e5
not i
; @ ec test-unary-expression-e6
i := i + clamp i
; @ ec test-unary-expression-e7
fun4(copy - clamp i)
; @ ec test-unary-expression-e8
i := clamp i
; @ ec test-unary-expression-e9
fun4(copy clamp i)
; @ ec test-unary-expression-e10
i := clamp? i + 1
; @ eg test-unary-expression-e11
func error()->(var Uint32 i)
    i := clamp! i + 1
; @ eg test-unary-expression-e12
func error()->(var Uint32 i)
    i := clamp? i + 1
; @ ec test-unary-expression-e13
i clamp+= clamp -1
; @ ec test-unary-expression-e14
fun5(copy i)->(var clamp j)
; @ ec test-unary-expression-e15
i := i + wraparound i
; @ ec test-unary-expression-e16
i := wraparound i
; @@ test-binary-expression
; @ c test-binary-expression-0
i := 23 + 54
; @ c test-binary-expression-1
i clamp+= (100 * 2) - 37
i clamp*= 3
; @ c test-binary-expression-2
i clamp-= 12 *
        13
; @ c test-binary-expression-3
b := 3 < 5 or 23 > 37
; @ c test-binary-expression-4
b := 3 <= 5 and 23 >= 37
; @ c test-binary-expression-5
b := i = 5 or i <> 37
; @ c test-binary-expression-6
b := 2 < i < 12 = -2 * i
; @ c test-binary-expression-7
t := tc
; @ c test-binary-expression-8
owner String? s
s := so
; @ c test-binary-expression-9
str := so
; @ c test-binary-expression-10
b := t is ta or tc is-not tb
; @ c test-binary-expression-11
c := '0' + 4
; @ c test-binary-expression-12
b := fun0 is-not fun1
; @ c test-binary-expression-13
b := b = b
; @ c test-binary-expression-14
owner Tc? otc
tb := otc!
; @ c test-binary-expression-15
owner Array?{Test} otarr
otarr := _
; @ c test-binary-expression-16
io := (60 div i!) + (60 mod i!)
; @ c test-binary-expression-17
i := i bor 8
; @ c test-binary-expression-18
i := 10 band i
; @ c test-binary-expression-19
var Int{4:20} i8(copy 4)
var Int{100000000000:200000000000} i64(copy 100000000000)
i := bnot i wraparound+ bnot i8 wraparound+ bnot i64
; @ c test-binary-expression-20
i := i xor 16
; @ c test-binary-expression-21
i := 2 shr i
; @ c test-binary-expression-22
i := i shl 1
; @ c test-binary-expression-23
i := wraparound bnot i + (10 band i)
; @ c test-binary-expression-24
var Int{1:100} x(copy 1)
io := (60 div x) + (600 mod x)
; @ c test-binary-expression-25
i := i clamp+ i
i := i clamp+ j
j := j clamp+ i
j := j clamp+ j
; @ c test-binary-expression-26
i := i clamp- i
i := i clamp- j
j := j clamp- i
j := j clamp- j
; @ c test-binary-expression-27
i := i clamp* i
i := i clamp* j
j := j clamp* i
j := j clamp* j
; @ c test-binary-expression-28
b := i >= i or i < j or j > j or bt <= j
; @ c test-binary-expression-29
var Int{10:100} x(copy 50)
var Int{1000} y
var Uint64 z
i := x wraparound+ 1000
i := y wraparound- 2000
z := z wraparound* 2
z := z wraparound+ j wraparound+ (x wraparound- z)
; @ c test-binary-expression-30
i wraparound+= i
i wraparound-= i
i wraparound*= i
; @ c test-binary-expression-31
var Sint64 x
var Uint64 y
i := wraparound x +! j
i := wraparound x -! j
i := wraparound x *! j
y := y +! 3
i := wraparound x -! 3
if-error x := x +? 3
    x := 0
; @ ec test-binary-expression-e0
345 @ 2
; @ ec test-binary-expression-e1
80 +(
; @ ec test-binary-expression-e2
1 + 2 * 3
; @ ec test-binary-expression-e3
1 < i or 2 < i and 3 < i
; @ ec test-binary-expression-e4
1 not 2
; @ ec test-binary-expression-e5
1 := 2
; @ ec test-binary-expression-e6
1 clamp+= 2
; @ ec test-binary-expression-e7
1 clamp-= 2
; @ ec test-binary-expression-e8
so := str
; @ ec test-binary-expression-e9
b := 1 or 2
; @ ec test-binary-expression-e10
b := t > 3
; @ ec test-binary-expression-e11
b := 1 > 4 > t
; @ ec test-binary-expression-e12
i := 3 + t
; @ ec test-binary-expression-e13
t clamp+= 3
; @ ec test-binary-expression-e14
i clamp-= b
; @ ec test-binary-expression-e15
b := 3 is t
; @ ec test-binary-expression-e16
user Array?{Char} ca
ca := arr!
; @ ec test-binary-expression-e17
owner Test? ot
ot := tb
; @ ec test-binary-expression-e18
b := b is b
; @ ec test-binary-expression-e19
b := t is t < 2
; @ ec test-binary-expression-e20
user Test? tu
t := tu
; @ ec test-binary-expression-e21
var Test tv
user Test tu(user tv)
tu := t
; @ ec test-binary-expression-e22
io := 60 div i
; @ ec test-binary-expression-e23
io := 60 mod i
; @ ec test-binary-expression-e24
io := 60 div 0
; @ ec test-binary-expression-e25
io := 60 mod 0
; @ ec test-binary-expression-e26
var Int{-10:10} x
i := bnot x
; @ ec test-binary-expression-e27
var Int{-10:10} x
i := x xor 1
; @ ec test-binary-expression-e28
var Int{-10:10} x
i := 2 bor x
; @ ec test-binary-expression-e29
var Int{-10:10} x
i := x band 3
; @ ec test-binary-expression-e30
var Int{-10:10} x
i := x shr 4
; @ ec test-binary-expression-e31
var Int{-10:10} x
i := 5 shl x
; @ ec test-binary-expression-e32
var Int{-10:10} x
i := x div 6
; @ ec test-binary-expression-e33
var Int{-10:10} x
i := 7 mod x
; @ ec test-binary-expression-e34
var Uint64 u64
b := j < u64
; @ ec test-binary-expression-e35
var Int{10} x
i := x wraparound+ 100
; @ ec test-binary-expression-e36
var Int{200:220} x(copy 210)
i := x wraparound- 100
; @ ec test-binary-expression-e37
var Uint8 x
i := x wraparound* 1
; @ ec test-binary-expression-e38
var Int{1:255} x
x wraparound+= 1
; @ ec test-binary-expression-e39
var Int{254} x
x wraparound-= 1
; @ ec test-binary-expression-e40
var Uint64 x
x := x +? j
; @ ec test-binary-expression-e41
var Uint64 x
if-error x := x +! j
    x := 0
; @ eg test-binary-expression-e42
func error(copy Sint32 j)
    var Uint64 x
    x := x +! j
; @ ec test-binary-expression-e43
i := wraparound i +! 3
; @ ec test-binary-expression-e44
i := wraparound i +? 3
; @@ test-swap-expression
; @ c test-swap-expression-0
new Test t1!
new Test t2!
t1 :=: t2
; @ c test-swap-expression-1
strong Test t1(strong to!)
strong Test t2(strong to!)
t1 :=: t2
; @ c test-swap-expression-2
new Tc t1(copy 1)!
new Tc t2(copy 2)!
t1 :=: t2
; @ c test-swap-expression-3
strong Tc t1(strong Tc(copy 1)!)
strong Tc t2(strong Tc(copy 2)!)
t1 :=: t2
; @ c test-swap-expression-4
new Array{i:Uint32} a1!
new Array{i:Uint32} a2!
a1 :=: a2
; @ c test-swap-expression-5
strong Array{Uint32} a1(strong Array{4:Uint32}()!)
strong Array{Uint32} a2(strong Array{6:Uint32}()!)
a1 :=: a2
; @ c test-swap-expression-6
new String s1!
new String s2!
s1 :=: s2
; @ c test-swap-expression-7
strong String s1(strong String()!)
strong String s2(strong String()!)
s1 :=: s2
; @ g test-swap-expression-8
struct MyStruct
    var Uint32 x
struct Test
    owner MyStruct f
    new(owner MyStruct f)
        self.f := f
func fun(owner Test t1, owner Test t2)
    t1.f :=: t2.f
; @ c test-swap-expression-9
user Test t1(user t!)
user Test t2(user t!)
t1 :=: t2
; @ c test-swap-expression-10
weak Test t1(weak to!)
weak Test t2(weak to!)
t1 :=: t2
; @ c test-swap-expression-11
i :=: io
; @ c test-swap-expression-12
d!.item :=: t
; @ ec test-swap-expression-e0
t :=: to
; @ ec test-swap-expression-e1
new Test t1!
t1 :=: t1
; @ ec test-swap-expression-e2
new String nstr!
ostr :=: nstr
; @ ec test-swap-expression-e3
user Array{Byte} a(user buff!)
a :=: buff![1:2]!
; @ ec test-swap-expression-e4
ta :=: tc
; @ ec test-swap-expression-e5
new Test t1!
strong Test t2(strong to!)
t1 :=: t2
; @ ec test-swap-expression-e6
new String valid!
owner String invalid
valid :=: invalid
; @ ec test-swap-expression-e7
new String valid!
owner String invalid
invalid :=: valid
; @ ec test-swap-expression-e8
i :=: j
; @ ec test-swap-expression-e9
var Uint8 x
i :=: x
; @ ec test-swap-expression-e10
user Array?{6:Bool} a6
user Array?{Bool} ad
a6 :=: ad
; @ ec test-swap-expression-e11
user Array?{6:Bool} a6
user Array?{8:Bool} a8
a6 :=: a8
; @@ test-question-expression
; @ c test-question-expression-0
b := ostr?
; @ c test-question-expression-1
b := not arr?
; @ c test-question-expression-2
b := t!.fun?
; @ c test-question-expression-3
b := to?
; @ c test-question-expression-4
b := fun7(weak _)->(weak t)?
; @ c test-question-expression-5
weak Test tt(weak t!)
b := tt?
; @ g test-question-expression-6
struct Test
    weak String? s
    func user meth()->(var Bool res)
        res := self.s?
; @ ec test-question-expression-e0
(i := 2)?
; @ ec test-question-expression-e1
i?
; @ ec test-question-expression-e2
var Test tt
if tt?
; @ ec test-question-expression-e3
var Int? error
; @@ test-exclamation-expression
; @ c test-exclamation-expression-0
user String s(user ostr!)
; @ c test-exclamation-expression-1
user Test tt(user t!.t!)
; @ c test-exclamation-expression-2
user Test? tu
tu := fun7(weak _)->(weak t)!
; @ c test-exclamation-expression-3
i := tb!.num
; @ c test-exclamation-expression-4
weak Test tt(weak t!)
; @ c test-exclamation-expression-5
new Buffer{str!.length()} s!
; @ c test-exclamation-expression-6
so := ostr!
; @ ec test-exclamation-expression-e0
user String s(user str)
; @ ec test-exclamation-expression-e1
user Test? tt(user t)
; @ ec test-exclamation-expression-e2
new Buffer{12} s!
s := ostr
; @ ec test-exclamation-expression-e3
weak String? s
fun1(copy 0, user s, owner _)
; @ ec test-exclamation-expression-e4
t.num
; @ ec test-exclamation-expression-e5
t.meth()
; @ ec test-exclamation-expression-e6
var Func?{()} fun
fun()
; @ ec test-exclamation-expression-e7
i := arr[3]!
; @ ec test-exclamation-expression-e8
for _ in str
; @ ec test-exclamation-expression-e9
weak Buffer? s
raise! s
; @ ec test-exclamation-expression-e10
new Buffer{str.length()} s!
; @ ec test-exclamation-expression-e11
so := ostr
; @ ec test-exclamation-expression-e12
fun8(strong ostr)
; @ ec test-exclamation-expression-eo0
raise! str!!
; @ ec test-exclamation-expression-en0
var String s
so := s!
; @ ec test-exclamation-expression-en1
io := (2!) + 3
; @ ec test-exclamation-expression-en2
so! := str
; @ ec test-exclamation-expression-en3
"text"!.length
; @ ec test-exclamation-expression-en4
var Func{(user Test? self)} fun(copy Test!.meth)
; @ ec test-exclamation-expression-en5
var Test tv
i := tv!.num
; @ eg test-exclamation-expression-en6
struct Base
    var Uint32 x
    func user fun()
struct Test(Base)
    func user fun()
        base!()
; @ ec test-exclamation-expression-en7
fun0!()
; @ eg test-exclamation-expression-en8
func fun(user String s)
    fun(user s!)
; @ ec test-exclamation-expression-en9
var Func{()} fun(copy fun0)
fun!()
; @ ec test-exclamation-expression-en10
if not b!
; @ ec test-exclamation-expression-en11
io := 2 + 3!
; @ eg test-exclamation-expression-en12
func fun()
mock fun()
    fun!.active := false
; @ ec test-exclamation-expression-en13
ut!.fun0()
; @ ec test-exclamation-expression-en14
if t!?
; @ ec test-exclamation-expression-en15
if b!
; @ ec test-exclamation-expression-en16
loop
    while b!
; @ ec test-exclamation-expression-en17
for _ in 3!
; @ ec test-exclamation-expression-en18
for _ in 3!:4
; @ ec test-exclamation-expression-en19
for _ in 3:4!
; @ ec test-exclamation-expression-en20
var String s
for _ in s!
; @ ec test-exclamation-expression-en21
var Array{4:Uint32} a
for _ in a!
; @ ec test-exclamation-expression-en22
user String? s(user str!)
; @ eg test-exclamation-expression-en23
const Int CONST 12!
; @ ec test-exclamation-expression-en24
assert! b!
; @ ec test-exclamation-expression-en26
var Array{4:Uint32} a
i := a![2]!
; @ ec test-exclamation-expression-en27
var Array{4:Uint32} a
i := a[2!]!
; @ ec test-exclamation-expression-en28
var Array{4:Uint32} a
i := a[2:3!]!
; @ ec test-exclamation-expression-en29
var Ref r
r := ostr!
; @ ec test-exclamation-expression-en30
raise! "error"!
; @ ec test-exclamation-expression-en31
raise! bfr!
; @ ec test-exclamation-expression-en32
var String s!
; @ ec test-exclamation-expression-en33
`beaf`!.length
; @ ec test-exclamation-expression-en34
strong String? s
fun3(copy 0)->(strong s!)
; @@ test-int-range
; @ g test-int-range-0
struct Test
    var Uint32 int-def
    var Uint8 u8b
    var Uint16 u16b
    var Uint32 u32b
    var Uint64 u64b
    var Sint8 s8b
    var Sint16 s16b
    var Sint32 s32b
    var Sint64 s64b
    var Int{32} ru8
    var Int{5:1000} ru16
    var Int{1000000} ru32
    var Int{100000000000:200000000000} ru64
    var Int{-100:100} rs8
    var Int{-1:1000} rs16
    var Int{-2000000:-1000000} rs32
    var Int{-100000000000:100000000000} rs64
    new()
        self.ru16 := 5
        self.ru32 := 1000000
        self.rs32 := -1000000
        self.ru64 := 100000000000
        self.rs64 := -100000000000
        self.u8b := 0xff
        self.s8b := 0x7f
        self.s8b := -0x7f
        self.u16b := 0xffff
        self.s16b := 0x7fff
        self.s16b := -0x7fff
        self.u32b := 0xffffffff
        self.s32b := 0x7fffffff
        self.s32b := -0x7fffffff
        self.u64b := 0xffffffffffffffff
        self.s64b := 0x7fffffffffffffff
        self.s64b := -0x7fffffffffffffff
; @ c test-int-range-1
var Int{0:255} u8
var Int{0:65535} u16
var Int{0:4294967295} u32
var Int{0:18446744073709551615} u64
var Int{-128:127} s8
var Int{-32768:32767} s16
var Int{-2147483648:2147483647} s32
var Int{-9223372036854775808:9223372036854775807} s64
; @ g test-int-range-2
const Int MAX 10000
enum Nums
    MIN
var Int{Nums.MIN - 12:MAX * 2} s16
struct Test
    var Uint32 x
func fun(user Test t)->(var Uint32 x)
    x := wraparound fun(user t) + t.x
; @ c test-int-range-3
var Uint8 u8
var Sint16 s16(copy -1000)
var Uint32 u32(copy 100000)
var Uint16 u16
u16 := 1000
var Sint32 s32
s32 := 100000
s32 := -100000
i := 20 + -20
; @ g test-int-range-4
func fun()
    set(copy 12)
    get()
    var Uint32 x
    get()->(var x)
func get()->(var Int{20} x)
func set(copy Int{20} x)
; @ ec test-int-range-e0
var Int{12:11} error
; @ ec test-int-range-e1
var Int{0:18446744073709551616} error
; @ ec test-int-range-e2
var Int{-1:9223372036854775808} error
; @ ec test-int-range-e3
var Int{-9223372036854775809:1} error
; @ ec test-int-range-e4
var Int{0:str} error
; @ ec test-int-range-e5
var Int{0:i} error
; @ ec test-int-range-e6
var Int{-100} error
; @ ec test-int-range-e7
i := j
; @ ec test-int-range-e8
j := i
; @ ec test-int-range-e9
var Uint64 x
x := wraparound x + 1
; @@ test-dynamic-call
; @ c test-dynamic-call-0
var Ta a
; @ c test-dynamic-call-1
user Ta? a
; @ c test-dynamic-call-2
owner Ta nta(owner Ta()!)
; @ c test-dynamic-call-3
new Ta a!
; @ c test-dynamic-call-4
user Ta? a(user ta!)
; @ c test-dynamic-call-5
user Ta? x
x := ta!
; @ c test-dynamic-call-6
ta := tb
; @ c test-dynamic-call-7
ta := tc
; @ c test-dynamic-call-8
ta := _
; @ c test-dynamic-call-9
strong Array?{Ta} aa
ta := aa![4]!
; @ c test-dynamic-call-10
strong Array?{Tc} ca
ta := ca![4]!
; @ c test-dynamic-call-11
ta!.dyn()
; @ c test-dynamic-call-12
tb!.dyn()
; @ c test-dynamic-call-13
tc!.dyn()
; @ c test-dynamic-call-14
tco := tc
tco!.dyn()
; @ c test-dynamic-call-15
fun7(weak tc)->(weak ta)
; @ g test-dynamic-call-16
class Test
    var Uint32 x
    func dynamic user meth()
func ! mock()->(weak Test? t)
    t!.meth()
; @ g test-dynamic-call-17
class Base
    var Uint32 x
    func dynamic user meth()
class Test(Base)
    func inst user fun()
        self.meth()
; @ c test-dynamic-call-18
fun7(weak _)
; @ eg test-dynamic-call-e0
class Test
    var Uint32 x
    func dynamic weak? meth()
func fun()
    weak Test? t
    t.meth()
; @@ test-function-object
; @ c test-function-object-0
var Func{()} fun
fun := fun0
fun()
; @ c test-function-object-1
var Func{(copy Uint32 x)->(var Uint32 y)} fun(copy fun5)
var Uint32 x
fun(copy 9)->(var x)
; @ c test-function-object-2
var Func{(user Test? self)} fun(copy Test.meth)
fun(user t!)
; @ c test-function-object-3
var Func?{()} fun
fun := _
b := fun?
fun!()
; @ c test-function-object-4
t!.fun := fun0
t!.fun!()
; @ c test-function-object-5
var Array{38:Func{()}} farr
new Array{12:Func{(copy Uint32 x)->(var Uint32 y)}} farr1!
new Array{12:Func{:()}} farr2!
user Array{Func{:()}} ufarr
farr[3] := fun0
farr[3]()
; @ c test-function-object-6
var Func{(copy Uint32 x,
        copy Uint32 y)} fun
; @ g test-function-object-7
func fun()
func mock()->(var Func{()} f)
    f := fun
    f()
; @ g test-function-object-8
func ! fun(copy Uint32 x, copy Uint32 y)
func mock(copy Func?{(copy Uint32 x,
        copy Uint32 y)} fi)->(var Func{:(copy Uint32 x,
        copy Uint32 y)} fo)
    mock(copy _)
    fo := fun
func afun(user Array{Func{(copy Uint32 x)->(var Uint32 y)}} in)->(
        owner Array?{Func{:()}} out)
struct Test
    var Func{(copy Uint32 x,
            copy Uint32 y)} fun
    var Array{4:Func{:(copy Uint32 x)->(var Uint32 y)}} afun
    func user meth(copy Func{:(copy Uint32 x,
            copy Uint32 y)} fi)->(var Func{:(copy Uint32 x,
            copy Uint32 y)} fo)
        fo := fun
; @ c test-function-object-9
var Func{:()} fun
fun := fune
fun()!
; @ ec test-function-object-e0
var Func error
; @ ec test-function-object-e1
var Array{3:Func} error
; @ ec test-function-object-e2
var Func{} error
; @ ec test-function-object-e3
var Func{() } error
; @ ec test-function-object-e4
var Func{()} fun(copy fun1)
; @ ec test-function-object-e5
var Func{()->(var Uint32 x)} fun
fun := fun0
; @ ec test-function-object-e6
var Func{()} fun
fun()
; @ ec test-function-object-e7
var Func{()} fun(copy fun0)
fun := _
; @ ec test-function-object-e8
var Func{()} fun(copy fun0)
if fun?
; @ ec test-function-object-e9
var Func{()} fun(copy fune)
; @ ec test-function-object-e10
var Func{:()} fun(copy fun0)
; @@ test-builtin
; @ c test-builtin-int0
var Uint64 u64
var Sint64 s64
u64.str(user ostr!)!
s64.str(user ostr!)!
; @ c test-builtin-bool0
b := true
; @ c test-builtin-bool1
b := false
; @ ec test-builtin-char0
c := EOF
; @ c test-builtin-array0
i := arr!.length
; @ c test-builtin-array1
var Array{12:Bool} a
user Array{12:Bool} ua(user a)
i := a.length + ua.length
; @ c test-builtin-string0
ostr!.length()->(var i)
; @ c test-builtin-string1
ostr!.clear()
; @ c test-builtin-string2
ostr!.equal(user buff!)->(var b)
; @ c test-builtin-string3
ostr!.bytes()->(user bfr)
; @ c test-builtin-string4
bfr := ostr!
ostr!.equal(user ostr!)->(var b)
; @ c test-builtin-string5
ostr!.append(copy c)!
; @ c test-builtin-string6
var String sv
sv.new(user buff!)!
; @ c test-builtin-string7
ostr!.concat(user buff!)!
; @ c test-builtin-string8
ostr!.concat-int(copy i)!
; @ c test-builtin-string9
ostr!.has(copy c)->(var b)
; @ c test-builtin-string10
user Buffer{Int{4:20}} bf
var String s
bf := str!
bf := s!
bfr := s
; @ ec test-builtin-string-e0
bfr := str!
str!.clear()
bt := bfr![1]!
; @ ec test-builtin-string-e1
bfr := str!
str!.append(copy bt)!
bt := bfr![1]!
; @ ec test-builtin-string-e2
bfr := str!
str!.concat(user buff!)!
bt := bfr![1]!
; @ ec test-builtin-string-e3
bfr := str!
str!.concat-int(copy i)!
bt := bfr![1]!
; @ ec test-builtin-string-e4
bfr := so!
so := _
bt := bfr![1]!
; @ ec test-builtin-string-e5
var String s
bfr := s!
; @ c test-builtin-buffer0
i := buff!.length
; @ c test-builtin-file0
try
    s-var FileReadText f(user ostr)
    f.get()->(var bt, var b)
    f.getline(user buff)->(user bfr, var b)
    var Sint64 x
    f.tell()->(var x)
    f.seek-set(copy x)
    f.seek-cur(copy x)
    f.seek-end(copy x)
    f.flush()
    f.close()
    var Data{FileReadText} df
    df.item := f
; @ c test-builtin-file1
try
    new FileReadBinary f(user ostr)
    f.get()->(var bt, var b)
    f.read(user buff)->(var i)
    var Sint64 x
    f.tell()->(var x)
    f.seek-set(copy x)
    f.seek-cur(copy x)
    f.seek-end(copy x)
    f.flush()
    f.close()
    var Data{FileReadBinary} df
    df.set(owner f)
; @ c test-builtin-file2
try
    owner FileWriteText f(owner FileWriteText(user ostr, copy false))
    f.put(copy bt)
    f.write(user buff)->(var i)
    var Sint64 x
    f.tell()->(var x)
    f.seek-set(copy x)
    f.seek-cur(copy x)
    f.seek-end(copy x)
    f.flush()
    f.close()
    var Data{FileWriteText} df
    df.set(owner f)
; @ c test-builtin-file3
try
    strong FileWriteBinary f(strong FileWriteBinary(user ostr, copy true))
    f.put(copy bt)
    f.write(user buff)->(var i)
    var Sint64 x
    f.tell()->(var x)
    f.seek-set(copy x)
    f.seek-cur(copy x)
    f.seek-end(copy x)
    f.flush()
    f.close()
    var Data{FileWriteBinary} df
    df.item := f
; @ c test-builtin-file4
try
    s-var FileReadWriteText f(user ostr, copy true, copy true)
    f.get()->(var bt, var b)
    f.getline(user buff)->(user bfr, var b)
    f.put(copy bt)
    f.write(user buff)->(var i)
    var Sint64 x
    f.tell()->(var x)
    f.seek-set(copy x)
    f.seek-cur(copy x)
    f.seek-end(copy x)
    f.flush()
    f.close()
    var Data{FileReadWriteText} df
    df.item := f
; @ c test-builtin-file5
try
    new FileReadWriteBinary f(user ostr, copy false, copy false)
    f.get()->(var bt, var b)
    f.read(user buff)->(var i)
    f.put(copy bt)
    f.write(user buff)->(var i)
    var Sint64 x
    f.tell()->(var x)
    f.seek-set(copy x)
    f.seek-cur(copy x)
    f.seek-end(copy x)
    f.flush()
    f.close()
    var Data{FileReadWriteBinary} df
    df.set(owner f)
; @ g test-builtin-file6
struct Data{Generic}
    weak Generic? item
    func user? set(owner Generic? item)
func ! fun(
        user String name,
        user File f,
        user FileReadText frt,
        user FileReadBinary frb,
        user FileWriteText fwt,
        user FileWriteBinary fwb,
        user FileReadWriteText frwt,
        user FileReadWriteBinary frwb)
    f := frt
    f := frb
    f := fwt
    f := fwb
    f := frwt
    f := frwb
    frt := frwt
    frb := frwb
    ; line 20
    fwt := frwt
    fwb := frwb
    fun(
            user name,
            user frt,
            user frwt,
            user frwb,
            user frwt,
            user frwb,
            user frwt,
            user frwb)!
    var Data{File} df
    owner File fo(owner FileWriteBinary(user name, copy false)!)
    var Sint64 i
    fo.tell()->(var i)!
    fo.seek-set(copy i)!
    fo.seek-cur(copy i)!
    fo.seek-end(copy i)!
    fo.flush()!
    fo.close()!
    ; line 40
    df.set(owner fo)
; @ c test-builtin-sys0
user Array{String} argv(user sys.argv)
; @ c test-builtin-sys1
sys.print(user buff!)!
; @ c test-builtin-sys2
sys.println(user buff!)!
; @ c test-builtin-sys3
sys.getchar()->(var c, var b)!
; @ c test-builtin-sys4
sys.getline(user buff!)->(user bfr, var b)!
; @ c test-builtin-sys5
sys.exit(copy j)!
; @ c test-builtin-sys6
sys.system(user ostr!)->(var j)!
; @ c test-builtin-sys7
sys.getenv(user ostr!, user ostr!)->(var b)!
; @ c test-builtin-sys8
sys.stdin.get()->(var bt, var b)!
; @ c test-builtin-sys9
sys.stdout.put(copy bt)!
; @ c test-builtin-sys10
sys.stderr.put(copy bt)!
; @ ec test-builtin-file-e0
var FileReadText error
; @ ec test-builtin-file-e1
new FileReadText error!
; @ ec test-builtin-file-e2
FileReadText()
; @@ test-general
; @ g test-general-0
owner String? str
; @ g test-general-1


    #

var Uint32 x
; @ g test-general-2
; comment

var Uint32 x
; @ g test-general-3
~~~ documentation ~~~

var Uint32 x
; @ g test-general-4
[; multi #
 line #
 comment ;]

var Uint32 x
; @ g test-general-5
~~~ multi #
 line    #
 documentation
 confused by ~ or ~~ or ; or ~~ ~ ?
~~~

var Uint32 x
; @ g test-general-6
var String s
s-var String svs!
owner String cs(owner String(user "global text")!)
; const Buffer cb `fade00beaf`
strong String us(strong String(user s)!)
weak String gs(weak us)
main!
    var Uint32 x(copy 6)
    x := 7
    new String ls!
    ls :=: cs
; @ tg test-general-7
var String s
func fun()
    s.clear()
; @-
module second
test dummy()
; @ tg test-general-8
func fun()
    fun()
main
    fun()
; @-
module test
test test-fun()
; @ eg test-general-e0
error #
; @ ec test-general-e1
1 + 2
; @ ec test-general-e2
return
i := 3
; @ ec test-general-e3
raise!
i := 3
; @ eg test-general-e4
[; comment ;]?
; @ eg test-general-e5
main(
; @ eg test-general-e6
    struct Test
; @ eg test-general-e7
func f()
    x :=
        y
; @ feg test-general-e8
var Uint32 x
; @ eg test-general-e9
var Uint32 name
var Uint32 name
; @ eg test-general-e10
func name()
var Uint32 name
; @ eg test-general-e11
user Error? error
; @ eg test-general-e12
var Uint32 x(copy error)
; @ eg test-general-e13
[ ; error
; @ eg test-general-e14
user String? error
; @ eg test-general-e15
temp String? error
; @ eg test-general-e16
weak String error
; @ eg test-general-e17
owner String error(owner String()!)
func fun()->(owner String? s)
    s := error
main!
; @ eg test-general-e18
owner String error(owner String()!)
func fun(owner String s)
main!
    fun(owner error)
; @@ test-struct
; @ g test-struct-0
struct Test
    var Uint32 x
; @ g test-struct-1
struct Test
    var Uint32 x
; @ g test-struct-2
struct Test1
    var Uint32 x
struct Test2
    var Uint32 x


struct Test3
    var Uint32 x
; @ g test-struct-3
struct Test2(Test1)
    var Uint32 y
struct Test1
    var Uint32 x
; @ g test-struct-4
struct Test
    owner Test? to
    strong Test? ts
    weak Test? tw
; @ eg test-struct-e0
struct(
; @ eg test-struct-e1
struct error
; @ eg test-struct-e2
struct ERror
; @ eg test-struct-e3
struct Error-name
; @ eg test-struct-e4
struct E
; @ eg test-struct-e5
struct Int
; @ eg test-struct-e6
struct Test
struct Test
; @ eg test-struct-e7
struct Test(Base
; @ eg test-struct-e8
struct Test
    error #
; @ feg test-struct-e9
struct Test
; @ eg test-struct-e10
struct Error
; @ eg test-struct-e11
struct Error
    new #
; @ eg test-struct-e12
struct Error
    new()
    new()
; @ eg test-struct-e13
struct Error
    var Uint32 x
    new()->(var Uint32 x)
; @ eg test-struct-e14
struct Error
    func temp new()
; @ eg test-struct-e15
struct Error(Error)
    var Uint32 x
; @ eg test-struct-e16
struct Aerror(Berror)
    var Uint32 x
struct Berror(Aerror)
    var Uint32 x
; @@ test-dynamic
; @ g test-dynamic-0
dynamic Test
    func user fun()
    func weak wf()
struct Some
    var Uint8 x
    owner Test? t
    func user fun()
        self.x := 3
support Test in Some
    func weak wf()
owner Test? gt
func ! fun(user Test? t)->(user Some? so, user Test? to)
    so := _
    to := t
    t!.fun()
    so!.fun()
    to := so
    to := _
    fun(user t)->(user so, user to)!
    fun(user _)->(user so)!
    user Test? t2
    fun(user so)->(user to, user t2)!
func sfun(strong Some s)
    s.wf()
    user Test? tc(user s)
    strong Test t
    t := s
    t.fun()
    t.wf()
; @ g test-dynamic-1
dynamic Test
    func user fun()
    func weak wf()
    func user another()
class Some
    var Uint8 x
    func dynamic user fun()
        self.x := 4
    func inst user another()
support Test in Some
    func weak wf()
func ! fun(user Test? t)->(user Some? so)
    so := _
    user Test? tu(user so)
    so!.fun()
    so!.another()
    fun(user so)->(user tu)!
func sfun(strong Some s)
    s.wf()
    strong Test t
    t := s
    t.fun()
    t.another()
    t.wf()
; @ g test-dynamic-2
struct Base
    var Bool x
struct Mid(Base)
struct Top(Mid)
dynamic Da
    func user fa()
dynamic Db
    func user fb()
dynamic Dc
    func user fc()
support Da in Base
    func user fa()
support Da in Mid
    func user fa()
support Da in Top
    func user fa()
support Db in Base
    func user fb()
support Dc in Mid
    func user fc()
func fun(user Base b, user Mid m, user Top t)->(
        user Da da, user Db db, user Dc dc)
    da := b
    da := m
    da := t
    db := b
    db := m
    db := t
    dc := m
    dc := t
; @ g test-dynamic-3
struct Base
    var Bool x
class Low(Base)
    func dynamic user meth()
class Mid(Low)
class Top(Mid)
dynamic Da
    func user fa()
dynamic Db
    func user fb()
dynamic Dc
    func user fc()
support Da in Base
    func user fa()
support Da in Low
    func user fa()
support Da in Mid
    func user fa()
support Da in Top
    func user fa()
support Db in Base
    func user fb()
support Dc in Mid
    func user fc()
func dyn(user Da da, user Db db, user Dc dc)
func fun(user Base b, user Low l, user Mid m, user Top t)->(
        user Da da, user Db db, user Dc dc)
    da := b
    da := l
    da := m
    da := t
    db := b
    db := l
    db := m
    db := t
    dc := m
    dc := t
    dyn(user t, user t, user t)
; @ g test-dynamic-4
struct Data{Generic}
    weak Generic? d
    func user meth(weak Generic? in)->(weak Generic? out)
dynamic Test
    func user fun()
struct MyStruct
    var Bool x
class MyClass
    var Bool x
support Test in MyStruct
    func user fun()
support Test in MyClass
    func user fun()
func fun(user Data{Test} dt, user Data{MyStruct} ds, user Data{MyClass} dc)
    weak Test? t
    t := dt.d
    dt.d := t
    dt.meth(weak t)->(weak t)
    t := ds.d
    ds.meth(weak _)->(weak t)
    t := dc.d
    dc.meth(weak _)->(weak t)
; @ tg test-dynamic-5
struct Some
    var Bool x
    func user fun()
        self.x := true
dynamic Test
    func user fun()
    func user test()
; @-
module second
var Bool b
support ut.Test in ut.Some
    func user test()
        self.x := b
test dummy()
; @ g test-dynamic-6
support Da in Test
    func user fa()
struct Test
    var Int x
dynamic Da
    func user fa()
dynamic Db
    func user fb()
support Db in Test
    func user fb()
; @ eg test-dynamic-e0
class Error
    var Bool x
    func dynamic user meth()
struct Test
    var Bool x
support Error in Test
; @ eg test-dynamic-e1
dynamic Test
    func user test()
dynamic Error
    func user error()
support Test in Error
; @ eg test-dynamic-e2
struct Some
    var Bool x
    func user fun()
dynamic Test
    func user fun()
support Test in Some
support Test in Some
; @ eg test-dynamic-e3
struct Error
    var Bool x
dynamic Test
    func user fun()
support Test in Error
; @ eg test-dynamic-e4
dynamic Error
; @ eg test-dynamic-e5
struct Test
    var Bool x
dynamic Error(Test)
    func user fun()
; @ eg test-dynamic-e7
dynamic Test
    func user fun()->(var Bool b)
        b := false
; @ eg test-dynamic-e8
dynamic Test
    func user fun()
func fun()
    var Test t
; @ eg test-dynamic-e9
dynamic Test
    func user fun()
struct Error
    var Test t
; @ eg test-dynamic-e10
dynamic Test
    func user fun()
struct Error
    weak Array?{Test} a
; @ eg test-dynamic-e11
dynamic Test
    func user fun()
func ! fun()
    new Test t!
; @ eg test-dynamic-e12
dynamic Test
    func user fun()
func ! fun()->(owner Test t)
    t := Test()!
; @ eg test-dynamic-e12a
support Error
; @ feg test-dynamic-e13
support Test in Error
; @ eg test-dynamic-e14
support Error{Gen} in Test
; @ eg test-dynamic-e15
support Test in Error{Gen}
; @ eg test-dynamic-de0
dynamic Error
    var Bool x
    func user fun()
; @ eg test-dynamic-de1
dynamic Test
    func user fun()
support Test in String
    func user fun()
; @ eg test-dynamic-de2
dynamic Test
    func user fun()
support Test in Bool
    func user fun()
; @ eg test-dynamic-de3
native struct Some
dynamic Test
    func user fun()
support Test in Some
    func user fun()
; @ eg test-dynamic-de4
dynamic Base
    func user fun()
dynamic Test(Base)
    func user test()
; @@ test-class
; @ g test-class-0
class Base
    var Uint32 x
    owner Base? b
    func inst user stat()
    func dynamic user dyn0()
    func dynamic user ! dyn1()
    func dynamic user dyn2()
class Mid(Base)
    var Uint32 y
    owner Mid? m
    func dynamic user dyn0()
    func dynamic user dyn3()
    func dynamic user ! dyn4()
class Top(Mid)
    var Uint32 z
    owner Top? t
    func dynamic user dyn0()
        base()
    func dynamic user ! dyn1()
        base()!
    func dynamic user dyn3()
        base()
    func dynamic user dyn5()
        base.dyn0()
; @ g test-class-1
class Test
    owner Test? to
    strong Test? ts
    weak Test? tw
    func dynamic user fun()
; @ eg test-class-e0
class(
; @ eg test-class-e1
class Error
    var Uint32 x
; @ eg test-class-e2
class Error
    func error f()
; @ eg test-class-e3

class Base
    var Uint32 x
    func dynamic user meth()
class Error(Base)
    func inst user meth()
; @ eg test-class-e4
class Base
    var Uint32 x
    func dynamic user meth()
class Error(Base)
    func dynamic user meth(copy Uint32 x)
; @ eg test-class-e5
class Base
    var Uint32 x
    func dynamic user meth()
class Error(Base)
    func dynamic user ! meth()
; @@ test-function
; @ g test-function-0
func name()
; @ g test-function-1
func name(user String self, user String text, copy Uint32 num)
; @ g test-function-2
func name()->(owner String? text, var Uint32 num)
; @ g test-function-3
func name(copy Char param)->(owner String? out)
; @ g test-function-4
func name(user Array{Uint32} array)
; @ g test-function-5
func some()
func name(copy Func{(copy Uint32 x)->(var Uint32 y)} fun)->(var Func{()} joy)
    joy := some
; @ g test-function-6
func name()
    var Uint32 x
; @ g test-function-7
func ! name(user String self, copy Uint32 px, user Buffer pu, owner Buffer po)->(
        strong String? oself, var Uint32 ox, weak String? ou, owner String? oo)
    var Uint32 x
    user Buffer? u
    user Buffer? b
    owner String? o
    var String v
    new String n!
    o := String()!
    u := "constant string"
    b := `beef`
    pu := po[2:6]!
; @ g test-function-8
struct Struct
    owner Struct? s
    owner Array?{Struct} as
    owner Array?{String} astr
class Class
    owner Class? c
    owner Array?{Class} ac
    func dynamic user meth()
func name(
        owner Struct ps,
        owner Class pc,
        owner Array{Struct} pas,
        owner Array{Class} pac)
    owner Struct? s
    owner Class? c
    owner Array?{Struct} as
    owner Array?{Class} ac
    owner Array?{Uint32} ai
    owner Array?{String} astr
; @ g test-function-9
class Test
    var Uint32 x
    func dynamic user meth()
func name()->(owner Test? t)
    t := _
; @ g test-function-10
func name(user Array{Array{String}} ai)->(owner Array?{Array{Uint32}} ao)
; @ g test-function-11
func ! name()->(owner String so)
    so := String()!
; @ g test-function-m0
main
    var Uint32 x
; @ g test-function-m1
main!
    owner String? s
    s!.clear()
; @ eg test-function-me0
main
    owner String? s
    s!.clear()
; @ eg test-function-e0
func(
; @ eg test-function-e1
func name
; @ eg test-function-e2
func Error()
; @ eg test-function-e3
func error_name()
; @ eg test-function-e4
func name()
func name()
; @ eg test-function-e5
var Uint32 name
func name()
; @ eg test-function-e6
func name( )
; @ eg test-function-e7
func name(user)
; @ eg test-function-e8
func name(user String
; @ eg test-function-e9
func name(error Uint32 x)
; @ eg test-function-e10
func name(user String str,user Uint32 x)
; @ eg test-function-e11
func name()-()
; @ feg test-function-e12
func name()
; @ eg test-function-e13
func name()
        var Uint32 x
; @ eg test-function-e14
func name(var Uint32 x)
; @ eg test-function-e15
func name()->(copy Uint32 x)
; @ eg test-function-e16
func name(copy String s)
; @ eg test-function-e17
func name(user Array error)
; @ eg test-function-e18
func name(copy Func error)
; @ eg test-function-e20
func name(
    copy Uint32 x)
; @ eg test-function-e21
func Type.Error.name()
; @ eg test-function-e22
func module.error.name()
; @ eg test-function-e23
func name(copy Uint32 error, copy Uint32 error)
; @ eg test-function-e24
func name(copy Uint32 error)->(var Uint32 error)
; @ eg test-function-e25
var Uint32 error
func name(copy Uint32 error)
; @ eg test-function-e26
func error()
func name(copy Uint32 error)
; @ eg test-function-e27
func error(copy Uint32 error)
; @ eg test-function-e28
func name(copy Uint32 Error)
; @ eg test-function-e29
func fun(weak String s)
    s!.clear()
; @ eg test-function-e30
func fun()
    raise!
; @ eg test-function-e31
func fun()
    assert! 1 = 2
; @ eg test-function-e32
func fun()
    assert-error! 1 = 2
; @ eg test-function-e33
func error()->()
; @@ test-members
; @ g test-members-0
struct Test
    var Uint32 x
    weak String? str
; @ g test-members-1
struct Test
    var Uint32 x
    func user name()
        self.x := 2
; @ g test-members-2
struct Test
    var Uint32 x
    func user name()
        var Uint32 x
        x := self.x
; @ g test-members-3
struct Test
    ; comment
    var Uint32 x
; @ g test-members-4
struct Test
    ~~~ documemtation ~~~
    var Uint32 x
; @ g test-members-5
struct Test
    [; multi #
    line #
    comment ;]
    var Uint32 x
; @ g test-members-6
struct Test
    ~~~ multi #
    line #
    documemtation
    ~~~
    var Uint32 x
; @ g test-members-7
var Uint32 name
func fun()
struct Test1
    var Uint32 name
    func user fun()
struct Test2
    var Uint32 fun
    func user name()
; @ g test-members-8
struct Test
    var Uint32 x
    func user fun()
        if self.x > 3
            self.x := 3
        loop
            for n in 4
                self.x := n
            while self.x < 30
; @ g test-members-9
struct Test
    var Uint32 x
    func user fun() _
func Test.fun()
    self.x := 3
; @ g test-members-10
func Test.fun(user String s)->(var Uint32 x)
    s.length()->(var x)
struct Test
    var Uint32 x
    func user fun(user String s)->(var Uint32 x) _
; @ g test-members-11
struct Test
    var Uint32 x
    new(copy Uint32 x) _
func Test.new(copy Uint32 x)
    self.x := x
; @ g test-members-12
struct Test
    owner Uint32? x
    weak Uint32? y
    s-var Uint32 z
    func user ! fun()
        self.x!.value := self.y!.value
        self.y := self.z
; @ eg test-members-e0
struct Test
    var Uint32 name
    var Uint32 name
; @ eg test-members-e1
struct Test
    func user name()
    var Uint32 name
; @ eg test-members-e2
struct Test
    var Bool x
    func user name()
    func user name()
; @ eg test-members-e3
struct Test
    var Uint32 name
    func user name()
; @ eg test-members-e4
struct Test
    var Uint32 x
    func user meth()
        owner Test? error
        error := self
; @ eg test-members-e5
struct Test
    var Uint32 x
    func user name() #
; @ eg test-members-e6
struct Test
    var Uint32 x
    func user error.name()
; @ eg test-members-e7
struct Test
    var Uint32 x
    func user fun()
func Test.fun()
; @ eg test-members-e8
func Test.fun()
struct Test
    var Uint32 x
    func user fun() _
func Test.fun()
; @ eg test-members-e9
struct Test
    var Uint32 x
    func user fun()
        self..x := 3
; @ ec test-members-e10
Test.num
; @ eg test-members-e11
struct Test
    var Uint32 x
    func error()
; @ eg test-members-e12
struct Test
    var Uint32 x
    func error?()
; @ eg test-members-e13
struct Test
    var Uint32 x
    func user fun()->(var Uint32 x) _
func Test.fun()
; @ eg test-members-e14
struct Test
    var Uint32 x
    func user ! fun() _
func Test.fun()
; @@ test-return
; @ g test-return-0
func name()
    return
; @ g test-return-1
func ! name()
    raise!
; @ g test-return-2
func ! name()
    raise! "some error"
; @ g test-return-3
func ! name(user Array{String} arr)
    raise! arr[3]!
; @ c test-return-4
weak Buffer? s
raise! s!
; @ c test-return-5
raise! _
; @ ec test-return-e0
return()
; @ ec test-return-e1
raise!()
; @ ec test-return-e2
raise! 2
; @ ec test-return-e3
raise
; @ ec test-return-e4
raise! arr!
; @ ec test-return-e5
return 0
; @@ test-code-variables
; @ c test-code-variables-0
var Uint32 x
; @ c test-code-variables-1
user String? s
; @ c test-code-variables-2
owner Array?{Uint32} a
; @ c test-code-variables-3
user Test? tt
; @ c test-code-variables-4
var Buffer{12} s
; @ c test-code-variables-5
var Array{12:Uint32} a
; @ c test-code-variables-6
var Array{12:Test} a
; @ c test-code-variables-7
var Array{12:Buffer{7}} sa
; @ c test-code-variables-8
new Buffer{12} s!
buff := s
; @ c test-code-variables-9
var Array{12:Ta} a
; @ c test-code-variables-10
new Array{12:Uint32} a!
; @ c test-code-variables-11
new Array{12:Buffer{7}} sa!
; @ c test-code-variables-12
var Array{3:Array{4:Buffer{5}}} aa
; @ c test-code-variables-13
new Array{3:Array{4:Buffer{5}}} aa!
; @ c test-code-variables-14
s-var Test tt!
t := tt
; @ c test-code-variables-15
owner Uint32? x
; @ g test-code-variables-g0
func ! fun()
    var Buffer{4} sv
    if 1 > 2
        user Array{Byte} su(user sv[1:2])
; @ ec test-code-variables-e0
var Int
; @ ec test-code-variables-e1
var Uint32 Error
; @ ec test-code-variables-e2
var Uint32 errorName
; @ ec test-code-variables-e3
var Uint32 name
var Uint32 name
; @ ec test-code-variables-e4
var Uint32 name
loop
    var Uint32 x
    loop
        var Uint32 name
; @ eg test-code-variables-e5
var Uint32 name
func mock()
    var Uint32 name
; @ eg test-code-variables-e6
func name()
func mock()
    var Uint32 name
; @ eg test-code-variables-e7
struct Test
    var Uint32 x(1)
; @ ec test-code-variables-e8
new
; @ ec test-code-variables-e9
var Array{i:Uint32} error
; @ ec test-code-variables-e10
var Uint32 error--name
; @ ec test-code-variables-e11
var Uint32 x #
; @ ec test-code-variables-e12
new Array{-2:Uint32} a!
; @@ test-initialize
; @ c test-initialize-0
tb := Tb(copy i)!
; @ c test-initialize-1
str := String()!
buff := Buffer{arr![0]}()!
; @ c test-initialize-2
owner Array{Uint32} a(owner Array{arr![0]:Uint32}()!)
; @ c test-initialize-3
owner Array{Test} a(owner Array{arr![0]:Test}()!)
; @ c test-initialize-4
owner Array{String} sa(owner Array{arr![0]:String}()!)
owner Array{Buffer} ba(owner Array{arr![0]:Buffer{arr![1]!}}()!)
; @ c test-initialize-5
var Uint32 x(copy arr![0])
; @ c test-initialize-6
user String? s(user ostr)
user Buffer? bf(user buff)
; @ c test-initialize-7
var String s(user "some string")!
user Buffer bf(user `fade00beaf`)
; @ c test-initialize-8
new String s(user buff!)!
new Buffer{i} bf!
; @ c test-initialize-9
user Test? tt(user tc!)
; @ c test-initialize-10
var Tc tt(copy 3)!
; @ c test-initialize-11
new Tc tt(copy 3)!
; @ c test-initialize-12
tb := Tc(copy 3)!
; @ c test-initialize-13
user Tb? tt(user tb)
; @ c test-initialize-14
owner Ta? ota(owner tb)
; @ c test-initialize-15
owner Array{Array{String}} sa(owner Array{arr![0]:Array{arr![1]!:String}}()!)
owner Array{Array{Buffer}} ba(owner Array{arr![0]:Array{arr![1]!:Buffer{arr![2]!}}}()!)
; @ g test-initialize-16
struct MyStruct
    var Uint32 x
func get()->(owner MyStruct? a)
    owner MyStruct? b(owner get())
; @ c test-initialize-17
owner Test? ot(owner to)
strong Test? st(strong ot!)
; @ c test-initialize-18
s-var Tc tt(copy 3)!
; @ c test-initialize-19
new Test t1!
s-var Test t2!
; @ g test-initialize-20
struct Test
    var Uint32 x
    new(copy Uint32 x)
func fun()
    var Test t(copy 3)
; @ g test-initialize-21
struct Base
    var Uint32 x
    new()
        self.x := 2
struct Test(Base)
    var Uint32 y
    new()
        base()
        self.y := 3
; @ c test-initialize-22
if b
    new Test nt!
    new Ta nta!
    new Tb ntb(copy 3)!
    new Tc ntc(copy 4)!
; @ c test-initialize-23
new Uint32 x!
i := wraparound x.value + 2
x.value := 3
fun5(copy x.value)->(var x.value)
strong Uint32 y(strong x!)
new Uint32 z(copy 4)!
x := Uint32()!
y := Uint32(copy 5)!
user Uint32? u(user x)
; line 10
i := u!.value
u!.value := i
u := _
weak Uint32 w(weak y)
i := w!.value
w!.value := i
u := i
s-var Uint32 si(copy 6)!
w := si
; @ ec test-initialize-e0
new Uint32 x!
x := Uint32(owner x)!
; @ ec test-initialize-e1
var Array{Bool} a
; @ ec test-initialize-e2
var Array{4:Buffer} sa
; @ ec test-initialize-e3
new Buffer s!
; @ ec test-initialize-e4
Buffer()
; @ ec test-initialize-e5
user Array a
; @ ec test-initialize-e6
new Array a!
; @ ec test-initialize-e7
Array()
; @ ec test-initialize-e8
var Array{23} a
; @ eg test-initialize-e9
struct Test{Generic}
    owner Array{Generic} arr
; @ ec test-initialize-e10
var Array{1
; @ ec test-initialize-e11
var Buffer{12
; @ ec test-initialize-e12
var Array{error:Uint32} a
; @ ec test-initialize-e13
var Array{"12":Uint32} a
; @ ec test-initialize-e14
user Uint32? u
i := u.value
; @ ec test-initialize-e15
strong Uint32? x
weak Uint32 w(weak x!)
i := w.value
; @ ec test-initialize-e16
var Array{4:Uint32} a(copy 1)
; @ ec test-initialize-e17
var Bool x(copy 1)
; @ ec test-initialize-e18
var Uint32 x(var 1, var 2)
; @ eg test-initialize-e19
struct Test
    var Uint32 x
func mock()
    Test(copy 1)
; @ ec test-initialize-e20
var Uint32 x(user 3)
; @ ec test-initialize-e21
owner String? s(user so)
; @ ec test-initialize-e22
owner String? s(owner str)
; @ ec test-initialize-e23
var Array{1:Uint32:Uint32} a
; @ ec test-initialize-e24
owner Test? ot(owner tb)
; @ ec test-initialize-e25
user String s
s.clear()
; @ ec test-initialize-e26
user String s(user _)
; @ ec test-initialize-e27
user String s(user str)
; @ ec test-initialize-e28
i := error
var Uint32 error
; @ ec test-initialize-e29
var Uint32 error(copy error)
; @ ec test-initialize-e30
error := 3
var Uint32 error
; @ ec test-initialize-e31
if b
    var Uint32 error
i := error
; @ ec test-initialize-e32
new Test? a!
; @ ec test-initialize-e33
to := Test?()
; @ ec test-initialize-e34
to := Test()
; @ ec test-initialize-e35
var Tb tt(copy 3)
; @ ec test-initialize-e36
user String s!
; @ eg test-initialize-e37
user String s!
; @ eg test-initialize-e38
struct Test
    weak String s!
; @ ec test-initialize-e39
arr := Buffer{-2}()!
; @ ec test-initialize-e40
var Int{10:20} x
i := x
; @@ test-comment
; @ c test-comment-0
; comment

var Uint32 x
; @ c test-comment-1
~~~ documemtation ~~~

var Uint32 x
; @ c test-comment-2
[; multi #
line #
comment ;]

var Uint32 x
; @ c test-comment-3
~~~ multi #
line #
documemtation
~~~

var Uint32 x
; @@ test-block
; @ c test-block-0
block
    new Test tt!
    i := 1
; @ c test-block-1
block
    return
; @ c test-block-2
block
    var Uint32 n
block
    var Uint32 n
; @ ec test-block-e0
block i
; @ ec test-block-e1
block
    break
; @ ec test-block-e2
block
    while b
; @ ec test-block-e3
block
    new Test tt!
tt.meth()
; @ ec test-block-e4
user Test tt
block
    var Test tvar
    tt := tvar
tt.meth()
; @@ test-if-else
; @ c test-if-else-0
if t!.num > 3
    i := 2
; @ c test-if-else-1
if i > 3
    i := 2
else
    i := 1
; @ c test-if-else-2
if i > 3
    i := 3
else-if t!.num > 2
    i := 2
else-if t!.num > 1
    i := 1
else
    i := 1
; @ c test-if-else-3
if b
    return
i := 3
; @ c test-if-else-4
if b and
        b
    i := 1
; @ c test-if-else-5
if b
    var Buffer{4} ba
    if b
        var Buffer{4} bb
    else-if b
        var Buffer{4} bc
    else
        var Buffer{4} bd
else-if b
    var Buffer{4} be
else
    var Buffer{4} bf
; @ ec test-if-else-e0
if 3
; @ ec test-if-else-e1
if b
    error
; @ ec test-if-else-e2
if b
    i := 0
else
    error
; @ ec test-if-else-e3
if b
    i := 0
else-if b
    error
; @ ec test-if-else-e4
if b
    return
    i := 3
; @ ec test-if-else-e5
if()
; @ ec test-if-else-e6
else
; @ ec test-if-else-e7
if false
    ; ...
else #
; @ ec test-if-else-e8
else-if b
; @ ec test-if-else-e9
if false
    ; ...
else-if()
; @ feg test-if-else-e10
func error()
    if b
; @@ test-loop
; @ c test-loop-0
loop
    var Uint32 x
    while b
; @ c test-loop-1
loop
    break
; @ c test-loop-2
loop
    while t!.num > 3
; @ c test-loop-3
loop
    continue
    while b
; @ c test-loop-4
loop
    if true
        while false
; @ c test-loop-5
loop
    var Buffer{4} ba
    while b
    break
    continue
    if b
        return
    loop
        var Buffer{4} bb
        while b
        break
        continue
        if b
            return
        loop
            var Buffer{4} bc
            while b
            break
            continue
            if b
                return
; @ c test-loop-6
loop! 1024
    while b
; @ c test-loop-7
try
    loop ostr.length() + 2
        while b
; @ c test-loop-8
loop-infinite
    i := 1
; @ c test-loop-9
loop
    loop
        loop
            return
; @ ec test-loop-e0
loop!(
; @ ec test-loop-e1
while true
; @ ec test-loop-e2
continue
; @ ec test-loop-e3
loop
    while 2
; @ ec test-loop-e4
loop
    error
; @ ec test-loop-e6
loop
    while i := 3
; @ ec test-loop-e7
loop
    while
; @ ec test-loop-e8
loop
    continue error
; @ ec test-loop-e9
break
; @ ec test-loop-e10
loop
    break error
; @ ec test-loop-e11
loop
    i := 1
; @ ec test-loop-e12
loop
    loop
        break
; @ ec test-loop-e13
try
    loop! 64
        while b
; @@ test-for-loop
; @ c test-for-loop-0
for n in 5
    i := n
; @ c test-for-loop-1
for n in t!.num:ostr!.length() + 2
    i := wraparound n
; @ c test-for-loop-2
for y in buff!
    bt := y
; @ c test-for-loop-3
for n in arr!
    i := n
; @ c test-for-loop-4
for s in sarr!
    s.clear()
for bf in barr!
    i := bf.length
; @ c test-for-loop-5
var Uint32 n
for n in 5
    i := n
; @ c test-for-loop-6
for n in 5
    i := n
for n in 7
    i := n
; @ c test-for-loop-7
for n in 1 +
        2
    i := n
; @ c test-for-loop-8
for n in 6
    var Buffer{4} ba
    break
    continue
    if b
        return
    for ch in buff!
        var Buffer{4} bb
        break
        continue
        if b
            return
; @ c test-for-loop-9
user Buffer bf(user `beaf`)
for y in bf
    bt := y
; @ c test-for-loop-10
var Array{3:String} sa
for s in sa
    s.clear()
var Array{3:Buffer{4}} ba
for bf in ba
    i := bf.length
; @ c test-for-loop-11
for _ in 2:6
    i := 1
; @ c test-for-loop-12
for _ in buff!
    i := 1
; @ c test-for-loop-13
for _ in ostr!.length():2
    i := 1
; @ c test-for-loop-14
repeat i - 4
    i := 1
; @ ec test-for-loop-e0
for(
; @ ec test-for-loop-e1
for n
; @ ec test-for-loop-e2
for n error
; @ ec test-for-loop-e3
for n in fun0()
; @ ec test-for-loop-e4
for n in str:8
; @ ec test-for-loop-e5
for n in 5
    error
; @ ec test-for-loop-e6
var Uint32 n
for n in arr!
    i := n
for n in sarr!
; @ ec test-for-loop-e7
for n in 7
    i := 1
var Uint32 n
; @@ test-testing
; @ c test-testing-a0
assert! t!.num = 2
; @ c test-testing-a1
assert-error! t.num
; @ c test-testing-a2
assert-error! fune()
; @ c test-testing-a3
assert-error! t.num, "expected error"
; @ c test-testing-a4
assert-error! fune(), "expected error in the function"
; @ c test-testing-a5
assert-error! t.num,
        "expected error in new line"
; @ c test-testing-a6
if b
    var Buffer{4} bf
    assert! b
    assert-error! bf[i:2]
    repeat 3
        assert-error! bf[i:2]
; @ g test-testing-m0
func ! fun()
    fun()!
mock ! fun()
    raise!
; @ g test-testing-m1
mock fun()
func fun()
    fun()
; @ g test-testing-m2
mock Test.meth(copy Uint32 x)
struct Test
    var Uint32 x
    func user meth(copy Uint32 x)
        self.meth(copy x)
; @ g test-testing-m3
mock Test.meth(copy Uint32 x)
class Test
    var Uint32 x
    func dynamic user meth(copy Uint32 x)
        self.meth(copy x)
; @ g test-testing-m4
func fun(copy Uint32 x)->(var Uint32 y)
mock fun(copy Uint32 x)->(var Uint32 y)
    fun.mocked(copy x)->(var y)
    fun.active := false
    fun(copy x)->(var y)
    fun.active := true
; @ g test-testing-m5
struct Test
    var Uint32 x
    func user meth(copy Uint32 x)->(var Uint32 y)
        self.meth(copy x)->(var y)
mock Test.meth(copy Uint32 x)->(var Uint32 y)
    self.meth.mocked(copy x)->(var y)
    Test.meth.mocked(user self, copy x)->(var y)
    self.meth.active := false
    Test.meth(user self, copy x)->(var y)
    Test.meth.active := true
; @ g test-testing-m6
class Test
    var Uint32 x
    func dynamic user meth(copy Uint32 x)->(var Uint32 y)
        self.meth(copy x)->(var y)
mock Test.meth(copy Uint32 x)->(var Uint32 y)
    Test.meth.mocked(user self, copy x)->(var y)
    Test.meth.active := false
    Test.meth(user self, copy x)->(var y)
    Test.meth.active := true
; @ g test-testing-m7
func ! fun()
    sys.print(user "mock print")!
    sys.print.mocked(user "really print")!
    sys.print.active := false
    sys.print.active := true
mock ! sys.print(user Buffer text)
; @ g test-testing-m8
struct Test
    var Uint32 x
    new(copy Uint32 x)
mock Test.new(copy Uint32 x)
func fun()
    var Test t(copy 2)
; @ tg test-testing-t0
func fun0()
    var Uint32 x(copy 4)
    x := 1
    var Uint32 y(copy 5)
    y := x
    if y > 3
        y := 3
    else-if y < 0
        y := 0
    else
        y := 1
    try
        x := 0
        sys.print(user "text")
        y := 0
    catch
        x := 1
        x := 2
    if x > 3
        return
    else
        x := 3
    loop
        while x > 1
        if x = 5
            continue
    for n in 3
        x := y
; @-
module ut
func fun1()
    fun0()
test fun2()
    fun1()
; @ tg test-testing-t1
func fun()
    var Uint32 x
main
    fun()
; @-
module second
test fun0()
test fun1()
; @ g test-testing-mg0
mock Test.delete()
    var Ref? r(copy self)
struct Test
    weak String? s
; @ g test-testing-mg1
mock delete()
    var Ref? r(copy self)
main
; @ g test-testing-mg2
mock new()->(var Bool allocate-success)
    allocate-success := false
main
; @ c test-testing-r0
var Ref r
; @ c test-testing-r1
var Ref r
r := ostr
; @ c test-testing-r2
var Ref? r
r := _
; @ c test-testing-r3
var Ref r(copy ostr)
; @ c test-testing-r4
var Ref r
assert! r is r
; @ ec test-testing-e0
assert! 3
; @ ec test-testing-e1
assert! error
; @ ec test-testing-e2
assert-error! error
; @ eg test-testing-e3
test fun(copy Uint32 x)
; @ eg test-testing-e4
test fun()->(copy Uint32 x)
; @ eg test-testing-e5
mock error()
; @ eg test-testing-e6
mock Error.fun()
; @ eg test-testing-e7
struct Test
    var Uint32 x
mock Test.error()
; @ eg test-testing-e8
mock fun(owner String s)
func fun(user String s)
; @ eg test-testing-e9
mock fun(user Uint32 s)
func fun(user String s)
; @ eg test-testing-e10
mock fun(user Array{Char} a)
func fun(user Array{Uint32} a)
; @ ec test-testing-e11
assert #
; @ ec test-testing-e12
assert-error #
; @ eg test-testing-e13
mock()
; @ eg test-testing-e14
func fun()
mock fun()
mock fun()
; @ eg test-testing-e15
struct Test
    var Uint32 x
    func user fun()
mock Test.fun()
mock Test.fun()
; @ eg test-testing-e16
mock delete()
mock delete()
; @ eg test-testing-e17
struct Test
    var Uint32 x
mock Test.delete()
mock Test.delete()
; @ ec test-testing-e18
assert-error! t.num , "error"
; @ ec test-testing-e19
assert-error! t.num,"error"
; @ ec test-testing-e20
assert-error! t.num,  "error"
; @ ec test-testing-e21
assert-error! t.num, error
; @ eg test-testing-e22
mock new()->(var Bool res)
mock new()->(var Bool res)
; @ eg test-testing-e23
mock new()->(var Uint32 x)
; @ eg test-testing-e24
mock new()
; @ eg test-testing-e25
mock new(copy Uint32 x)->(var Bool res)
; @ eg test-testing-e26
mock new()->(var Bool res, var Uint32 x)
; @ eg test-testing-e27
mock delete(copy Uint32 x)
; @ eg test-testing-e28
mock delete()->(copy Uint32 x)
; @ eg test-testing-e29
func fun()
mock fun()
    fun.error
; @ eg test-testing-e30
class Test
    var Uint32 x
    func dynamic user meth()
mock Test.meth()
    self.meth.mocked()
; @ eg test-testing-e31
test
; @ eg test-testing-e32
struct Test
    owner Buffer s
    new!()
        self.s := Buffer{12}()!
mock ! Test.new()
; @ eg test-testing-e33
test ! fun()
; @ ec test-testing-e34
assert-error! fun0()
; @ ec test-testing-e35
assert-error! t!.num
; @ ec test-testing-e36
assert-error! t!
; @@ test-native
; @ g test-native-include0
native include "native.h"
; @ g test-native-include1
struct Test
    var Uint32 x
native include "first.h"
func fun()
native include "second.h"
; @ g test-native-func0
native func external()
func call()
    external()
; @ g test-native-func1
class Test
    var Uint32 x
    func dynamic user meth()
native func Uint32 external(
        copy Uint32 i, user String? s, user Array?{Uint32} a, user Test? t)
func call()
    var Uint32 i
    user String? s
    user Array?{Uint32} a
    user Test? t
    i := external(copy 5, user s, user a, user t)
    i := wraparound (2 * external(copy 5, user s, user a, user t)) + 3
    external(copy 5, user s, user a, user t)
; @ g test-native-func2
native func external() "SOME_External_func"
func call()
    external()
; @ g test-native-func3
struct Test
    var Uint32 x
native func Test? external()
func call()
    user Test? t
    t := external()
    external()
; @ g test-native-var0
native var Uint32 x
func use()
    x := 2
; @ g test-native-var1
native var Uint32 x "SOME_External_var"
func use()
    x := 2
; @ g test-native-const0
native const Int VALUE
native const Byte BYTE
func get()->(var Uint32 x)
    x := wraparound VALUE + BYTE
; @ g test-native-const1
native const Int VALUE "SOME_External_const"
func get()->(var Uint32 x)
    x := VALUE
; @ g test-native-type0
native type Native
native var Native native-var
native func Native get-native()
native func set-native(copy Native n)
func get()->(var Native n)
    n := get-native()
func call()
    var Native n
    set-native(copy native-var)
    get()->(var n)
    set-native(copy n)
; @ g test-native-type1
native type Native "SOME_External_type"
native func Native get-native() "SOME_External_get_func"
native func set-native(copy Native n) "SOME_External_set_func"
func call()
    var Native n
    n := get-native()
    set-native(copy n)
; @ g test-native-struct0
native struct Native "c_native_type_t"
    var cdef.Int x "c_x_field"
    var cdef.Uint y "c_y_field"
native func Native ext(copy Native n)
func fun(copy Native in)->(var Native out)
    var Native n(copy in)
    out := n
    out := ext(copy in)
    if in.y wraparound+ out.x > 100
    in.x := 0
    in.y := 0
    var Native def
    out := def
    ext(copy def)
; @ g test-native-struct1
native struct Test
    var cdef.Int x
native type TestRef
native struct Native
    var cdef.Int x
    var Test t
    var TestRef r
    var cdef.Pointer{Native} n
func ! fun(copy Test t, copy TestRef r, copy Native in)->(var Native out)
    if in.x = 0 and in.t.x = 0 and in.n!.x = 0
    in.x := 0
    in.t := t
    in.t.x := 0
    in.r := r
    in.n!.x := 0
    in.n.set-point-to(var in)
    out := in.n.get-pointed-at(copy 0)
    out := in
; @ g test-native-code0
var Uint32 x
native code "#define HAS_SOME_DEFINE"
var Uint32 y
; @ c test-native-code1
native "#ifdef __UNIX__"
io := 3
native "#else"
io := 4
native "#endif"
; @ lg test-native-export0
func local()
    second.func()
native export func()
    func()
; @-
module second
func local()
    ut.func()
native export func() "second_func"
    func()
; @ g test-native-export1
func local(copy Uint64 n, user String s)
native export cdef.Int func(copy cdef.Uint n, copy cdef.CharP s)
    var String str
    if-error cdef.copy-to-string(copy s, user str)
        return -1
    local(copy n, user str)
    return 0
native export cdef.CharP another() "second_func"
    try
        new String s
        return s.cdef-pointer()
    return _
; @ eg test-native-e0
native()
; @ eg test-native-e1
native error
; @ eg test-native-e2
native error #
; @ eg test-native-include-e0
native include native.h
; @ eg test-native-func-e0
native func error()
native func error()
; @ eg test-native-func-e1
native func Int ! error()
; @ eg test-native-func-e2
native func error()->(copy Uint32 x)
; @ eg test-native-func-e3
native func Uint32
; @ eg test-native-func-e4
native func error(owner String s)
; @ eg test-native-func-e5
native func error(weak String s)
; @ eg test-native-func-e6
native func error(strong String s)
; @ eg test-native-func-e7
native func error(s-var String s)
; @ eg test-native-func-e8
native func Uint32 fun()
func error(copy Uint32 i)
    fun()->(copy i)
; @ eg test-native-func-e9
native func fun()->(copy Uint32 res) error
; @ eg test-native-func-e10
native func Buffer? error()
; @ eg test-native-func-e11
native func Array?{Uint32} error()
; @ eg test-native-func-e12
class Error
    var Uint32 x
    func dynamic user meth()
native func Error? error()
; @ eg test-native-var-e0
native var String s
; @ eg test-native-var-e1
native var Uint32 x error
; @ eg test-native-const-e0
native const Int VALUE error
; @ eg test-native-const-e1
native const Bool VALUE
; @ eg test-native-const-e2
native const Int VALUE
var Buffer{VALUE} error
; @ eg test-native-type-e0
native type Native error
; @ eg test-native-type-e1
native type Native
native func Native external(copy Native in)
func error()
    var Native n
    n := external(copy n)
; @ eg test-native-struct-e0
native struct Native
    user String error
; @ eg test-native-struct-e1
native struct Native
    func error()
; @ eg test-native-struct-e2
native struct Native
    var String error
; @ eg test-native-code-e0
native code #define error
; @ ec test-native-code-e1
native #ifdef error
; @ eg test-native-export-e0
func error()
native export error()
; @ eg test-native-export-e1
native export Int ! error()
; @ eg test-native-export-e2
native export error()->(copy Uint32 x)
; @ eg test-native-export-e3
native export Uint32
; @ eg test-native-export-e4
native export error(owner String s)
; @ eg test-native-export-e5
native export error(weak String s)
; @ eg test-native-export-e6
native export error(strong String s)
; @ eg test-native-export-e7
native export error(s-var String s)
; @ eg test-native-export-e8
native export Uint32 fun()
    return 0
func error(copy Uint32 i)
    fun()->(copy i)
; @ eg test-native-export-e9
native export fun()->(copy Uint32 res) error
; @ eg test-native-export-e10
native export Buffer? error()
; @ eg test-native-export-e11
native export Array?{Uint32} error()
; @ eg test-native-export-e12
class Error
    var Uint32 x
    func dynamic user meth()
native export Error? error()
; @ eg test-native-export-e13
native export cdef.Int func()
; @ eg test-native-export-e14
native export cdef.Int func()
    return _
; @ eg test-native-export-e15
native export cdef.Uint func()
    return -1
; @ eg test-native-export-e16
native export func()
    raise!
; @@ test-parameter-type
; @ g test-parameter-type-0
struct Test{Generic}
    weak Generic? item
    func user ! set(weak Generic item)
        weak Generic x(weak item)
        self.item := x
        new Test{Generic} t!
        t.item := self.item
        self.item := t.item
; @ g test-parameter-type-1
struct Test{Generic}
    owner Generic? item
    func user get()->(user Generic? item)
        item := self.item
; @ g test-parameter-type-2
struct StructA
    var Uint32 x
struct StructB
    var Uint32 x
struct StructC
    var Uint32 x
struct Test{First:Second:Third}
    weak First? first
    weak Second? second
    weak Third? third
    func user set(weak First first, weak Second second, weak Third third)
        self.first := first
        self.second := second
        self.third := third
func use(weak StructA first, weak StructB second, weak StructC third)
    var Test{StructA:StructB:StructC} t
    t.first := first
    t.second := second
    t.third := third
    t.set(weak first, weak second, weak third)
; @ g test-parameter-type-3
struct Base
    var Uint32 x
struct Test{Generic}(Base)
; @ c test-parameter-type-4
d!.item := t
; @ c test-parameter-type-5
t := d!.item
; @ g test-parameter-type-6
struct Test{Generic}
    var Uint32 x
    var Func{(user Generic item, copy Func{(user Generic item)} fun)} fun
    func user meth(copy Func{(user Generic item,
            copy Func{(user Generic item)} fun)} fun)
        var Func{(user Generic item, copy Func{(user Generic item)} funa)} funv
; @ c test-parameter-type-8
var Array{5:Data{Test}} ad
t := ad[2].item
; @ c test-parameter-type-10
d!.set(owner _)
; @ c test-parameter-type-11
var Data{Data{Data{Test}}} dr
t := dr.item!.item!.item
; @ c test-parameter-type-12
d!.set(owner to)
; @ c test-parameter-type-13
d!.get()->(weak t)
d!.get()!.meth()
; @ c test-parameter-type-14
var Data dg
; @ c test-parameter-type-15
user Data? dg(user d!)
; @ c test-parameter-type-16
Data{Test}.set(user d!, owner to)
; @ g test-parameter-type-17
struct Test{Generic}
    weak Test?{Generic} next
    func user meth(weak Test{Generic} next)->(user Test?{Generic} out)
        self.next := next
        out := self
; @ c test-parameter-type-18
var Data{Tb} dt
dt.item := tc
ta := dt.item
owner Tc? otc
dt.set(owner otc)
dt.get()->(weak ta)
i := dt.get()!.numa
fun7(weak dt.item)->(weak dt.item)
user Tb? tb2(user dt.item!)
tb2 := dt.item!
; @ g test-parameter-type-19
struct MyStruct
    var Uint32 x
    func user meth()
struct Base{Generic}
    weak Generic? item
    func user get()->(weak Generic? item)
struct Test(Base{MyStruct})
    func user set(weak MyStruct? f)
        self.item := f
        self.get()->(weak f)
func ! fun(user Test test, weak MyStruct? f)
    test.item := f
    test.set(weak f)
    f := test.item
    test.get()->(weak f)
    test.get()!.meth()
; @ g test-parameter-type-20
struct MyStruct
    var Uint32 x
    func user meth()
class Base{Param}
    weak Param? item
    func dynamic user set(weak Param? item)
    func dynamic user get()->(weak Param? item)
class Test{Generic}(Base{Generic})
    func dynamic user set(weak Generic? item)
    func dynamic user get()->(weak Generic? item)
func ! mock(weak Test{MyStruct} test, weak MyStruct? f)
    test!.set(weak f)
    test!.get()->(weak f)
    test!.get()!.meth()
; @ g test-parameter-type-21
struct Test{Param}
    weak Param? item
    func user meth(weak Param? in)->(weak Param? out) _
func Test.meth(weak Param? in)->(weak Param? out)
    weak Param? p(weak in)
    out := p
    self.item := p
    self.meth(weak p)->(weak p)
; @ c test-parameter-type-22
user Data?{Tb} db
db!.item := tb
db!.item := _
ta := db!.item
db.set(owner tb)
db.set(owner _)
db.get()->(weak ta)
; @ c test-parameter-type-23
var Data{String} ds
owner String? os
weak String? ws
ds.item!.clear()
str := ds.item!
ds.set(owner os)
ds.get()->(weak ws)
; @ c test-parameter-type-24
var Data{Uint32} di
owner Uint32? oi
weak Uint32? wi
di.item := wi
wi := di.item
di.set(owner oi)
di.get()->(weak wi)
di.item!.value := 3
i := di.item!.value
; @ eg test-parameter-type-eg0
struct Test{First:Second:Third
; @ eg test-parameter-type-eg1
struct Test{Generic}
    var Generic error
; @ eg test-parameter-type-eg2
struct Test{Generic}
    weak Generic? item
    func user meth(copy Generic error)
; @ eg test-parameter-type-eg3
struct Test{Generic}
    weak Generic? item
    func user meth(weak String s)
        self.item := s
; @ eg test-parameter-type-eg4
struct Test{Generic}
    weak Generic? item
    func user ! meth()->(user String? s)
        s := self.item!
; @ eg test-parameter-type-eg5
struct Test{Generic}
    weak Generic? item
    func user meth()
        var Generic error
; @ eg test-parameter-type-eg6
struct Test{First:Second}
    weak First? first
    weak Second? second
    func user meth()
        self.first := self.second
; @ eg test-parameter-type-eg7
struct Test{error}
    var Uint32 x
; @ eg test-parameter-type-eg11
struct MyStruct
    var Uint32 x
struct Test{First:Second:Third}
    weak First first
    weak Second second
    weak Third third
func meth(user Test{MyStruct:MyStruct} t)
    user Test{MyStruct:MyStruct:MyStruct} error(user t)
; @ eg test-parameter-type-eg12
struct Base{Param}
    weak Param item
struct Error(Base)
; @ eg test-parameter-type-eg13
struct MyStruct
    var Uint32 x
struct Base
    weak Uint32 x
struct Error(Base{MyStruct})
; @ eg test-parameter-type-eg14
struct MyStruct
    var Uint32 x
struct Base{Param}
    weak Param item
struct Error(Base{MyStruct:MyStruct})
; @ eg test-parameter-type-eg15
struct MyStruct
    var Uint32 x
struct Base{Param0:Param1}
    weak Param0 item0
    weak Param1 item1
struct Error(Base{MyStruct})
; @ ec test-parameter-type-ec0
var Data{Test?} error
; @ ec test-parameter-type-ec1
var Data{Test:Test} error
; @ ec test-parameter-type-ec2
var Data{Error} error
; @ ec test-parameter-type-ec3
var Char{Test} error
; @ ec test-parameter-type-ec4
var Data dg
str := dg.item!
; @ ec test-parameter-type-ec5
s-var Data dg!
d := dg
; @ ec test-parameter-type-ec6
str := d!.item!
; @ ec test-parameter-type-ec7
var Data{Array{Uint32}} error
; @ ec test-parameter-type-ec8
var Data{Buffer} error
; @@ test-parameter-inheritance
; @ g test-parameter-inheritance-0
struct MyStruct
    var Uint32 x
struct Base{Generic}
    weak Generic? item
struct Test(Base{MyStruct})
    func user ! set(weak MyStruct f)
        self.item := f
        Test.set(user Test()!, weak f)!
func use(weak MyStruct f)
    var Test t
    t.item := f
; @ g test-parameter-inheritance-1
struct MyStruct
    var Uint32 x
struct Base{Generic}
    weak Generic? item
struct Test{Param}(Base{Param})
    func user ! set(weak Param i, weak MyStruct f)
        self.item := i
        Test{MyStruct}.set(user Test{MyStruct}()!, weak f, weak f)!
func use(weak MyStruct f)
    var Test{MyStruct} t
    t.item := f
; @ g test-parameter-inheritance-2
struct MyStruct
    var Uint32 x
struct Base{Pbase}
    weak Pbase? item
    func user set(weak Pbase i)
struct Mid{Pmid}(Base{Pmid})
    func user set(weak Pmid i)
struct Top(Mid{MyStruct})
    func user set(weak MyStruct f)
        base(weak f)
        self.item := f
struct Test(Top)
    func user ! set(weak MyStruct f)
        base(weak f)
        self.item := f
        Top.set(user Top()!, weak f)
        Test.set(user Test()!, weak f)!
        Mid{MyStruct}.set(user Top()!, weak f)
func use(weak MyStruct f)
    var Test t
    t.item := f
; @ g test-parameter-inheritance-3
struct MyStruct
    var Uint32 x
struct Base{Generic}
    weak Generic? item
struct Test{Generic}(Base{Generic})
    func user ! set(weak Generic i, weak MyStruct f)
        self.item := i
        Test{MyStruct}.set(user Test{MyStruct}()!, weak f, weak f)!
func use(weak MyStruct f)
    var Test{MyStruct} t
    t.item := f
; @ g test-parameter-inheritance-4
struct StructA
    var Uint32 x
struct StructB
    var Uint32 x
struct StructC
    var Uint32 x
struct Base{First:Second}
    weak First? first
    weak Second? second
struct Mid{Param:Third}(Base{Param:StructB})
    weak Third? third
    func user set(weak Param first, weak StructB second, weak Third third)
        self.first := first
        self.second := second
        self.third := third
struct Top{Generic}(Mid{Generic:StructC})
    func user set(weak Generic first, weak StructB second, weak StructC third)
        self.first := first
        self.second := second
        self.third := third
struct Test(Top{StructA})
    func user set(weak StructA first, weak StructB second, weak StructC third)
        self.first := first
        self.second := second
        self.third := third
func use(weak StructA first, weak StructB second, weak StructC third)
    var Test t
    t.first := first
    t.second := second
    t.third := third
; @ g test-parameter-inheritance-5
struct MyStruct
    var Uint32 x
struct First{FirstGeneric}
    weak FirstGeneric? item
struct Second{SecondGeneric}
    weak SecondGeneric? item
struct Test{Generic}(First{Second{Generic}})
    func user ! set(weak Generic g, weak Second{Generic} sg)
        self.item := sg
        self.item!.item := g
func ! use(weak MyStruct f, weak Second{MyStruct} ff)
    var Test{MyStruct} t
    t.item := ff
    t.item!.item := f
; @ g test-parameter-inheritance-6
struct BaseGen{FirstGeneric}
    weak FirstGeneric? item
struct TestGen{SecondGeneric}(BaseGen{SecondGeneric})
struct Base
    var Uint32 x
struct Test(Base)
func test()
    user BaseGen?{Base} bb
    user BaseGen?{Test} bt
    user TestGen?{Base} tb
    user TestGen?{Test} tt
    bb := tb
    bt := tt
    bb := bt
    tb := tt
    bb := tt
; @ g test-parameter-inheritance-7
struct MyStruct
    var Uint32 x
struct Base{Generic}
    weak Generic? first
struct Mid{First:Second}(Base{First})
    weak Second? second
struct Top{Generic}(Mid{MyStruct:Generic})
func fun(user Top?{MyStruct} t)
    user Mid?{MyStruct:MyStruct} m
    m := t
; @ eg test-parameter-inheritance-e0
struct Base{Generic}
    weak Generic item
struct Test{Param}(Base{Param})
    weak Generic error
; @ eg test-parameter-inheritance-e1
struct MyStruct
    var Uint32 x
struct Base{Generic}
    weak Generic? item
struct Test(Base{MyStruct})
    func user set(weak String error)
        self.item := error
; @ eg test-parameter-inheritance-e2
struct Base{Generic}
    weak Generic? item
struct Test{Param}(Base{Param})
    func user set(weak String error)
        self.item := error
; @ eg test-parameter-inheritance-e3
struct MyStruct
    var Uint32 x
struct Base{Pbase}
    weak Pbase? item
struct Mid{Pmid}(Base{Pmid})
struct Top(Mid{MyStruct})
struct Test(Top)
    func user set(weak String error)
        self.item := error
; @@ test-error-handling
; @ c test-error-handling-0
if-error i := t.num
    i := 0
; @ c test-error-handling-1
if-error fune()
    i := 0
else
    io := i
; @ c test-error-handling-2
if-ok i := t.num
    io := i
else
    i := 0
; @ c test-error-handling-3
if b
    io := 0
else-if-error fune()
    i := 0
else
    io := i
; @ c test-error-handling-4
if b
    io := 0
else-if-ok i := t.num
    io := i
else
    i := 0
; @ g test-error-handling-5
func fun(weak String s)->(var Bool fail)
    if-error s.clear()
        fail := true
; @ ec test-error-handling-e0
if-error t.num
    i := 0
; @ ec test-error-handling-e1
if-ok t.num
else
    i := 0
; @ ec test-error-handling-e2
if-error fun0()
    i := 0
; @ ec test-error-handling-e3
if-ok i := t.num
; @ ec test-error-handling-e4
if-error i := t.num
; @ ec test-error-handling-e5
if-ok i := t.num
else
; @ ec test-error-handling-e6
if-error i := t!.num
    i := 0
; @@ test-try-catch
; @ c test-try-catch-0
try
    t.num := 1
    fun0()
catch
    i := t!.num
    fun4(copy 2)
; @ c test-try-catch-1
try
    t.num := 1
    fun0()
; @ c test-try-catch-2
try
    t.num := 1
    try
        fune()
    catch
        fun4(copy 2)
catch
    try
        i := arr[3]
    catch
        i := t!.num
; @ c test-try-catch-3
try
    var Buffer{4} sa
    try
        s-var Buffer{4} sb
    catch
        s-var Buffer{4} sc
catch
    var Buffer{4} sd
    try
        s-var Buffer{4} se
    catch
        var Buffer{4} sf
; @ g test-try-catch-4
func fun(weak String s)
    try
        s.clear()
        assert true
        assert-error s.clear()
        raise
; @ ec test-try-catch-e0
try()
; @ ec test-try-catch-e1
catch
; @ ec test-try-catch-e2
try
catch()
; @ ec test-try-catch-e3
try
; @ ec test-try-catch-e4
try
    fune()
catch
; @ ec test-try-catch-e5
try
    fune()
i := 2
catch
    i := 3
; @ ec test-try-catch-e6
try
    i := 1
; @ ec test-try-catch-e7
try
    fune()!
; @ ec test-try-catch-e8
try
    assert! true
; @@ test-for-each
; @ g test-for-each-0
struct TestIterator
    var Uint32 counter
    new(copy Uint32 count)
    func user step()->(var Uint32 num, var Bool has-data)
func ! fun()->(var Uint32 i)
    for n in TestIterator(copy 6)!
        var Buffer{4} s
        i := n
; @ g test-for-each-1
struct TestIterator
    owner String? value
    func user step()->(user String? text, var Bool has-data)
        text := self.value
func fun(user TestIterator iter)
    user String? t
    user String? s
    for t in iter
        s := t
; @ g test-for-each-2
struct MyStruct
    var Uint32 x
struct TestIterator{Generic}
    weak Generic? item
    func user ! step()->(user Generic? item, var Bool has-data)
        item := self.item!
class Test
    var Uint32 x
    func dynamic user fun()
func ! fun(user TestIterator{MyStruct} fiter, user TestIterator{Test} titer)
    user MyStruct? of
    user Test? ot
    for f in fiter!
        of := f
    for t in titer!
        ot := t
; @ g test-for-each-3
struct MyStruct
    var Uint32 x
class TestIterator{Generic}
    weak Generic? item
    func dynamic user ! step()->(user Generic? item, var Bool has-data)
        item := self.item!
func ! f-mock(user TestIterator{MyStruct} iter)
    user MyStruct? f
    for t in iter!
        f := t
; @ g test-for-each-4
struct TestIterator
    owner String? value
    func user step()->(strong String? text, var Bool has-data)
        if-error text := String(user self.value)
            text := _
func fun(user TestIterator iter)
    owner String? s
    for t in iter
        s := t
; @ g test-for-each-5
struct TestIterator
    owner String? value
    func user step()->(user String? text, var Bool has-data)
        text := self.value
func fun(user TestIterator iter)
    var Uint32 x
    for _ in iter
        x := 1
; @ eg test-for-each-e0
struct TestIterator
    var Uint32 num
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e1
struct TestIterator
    var Uint32 num
    func user step(user Uint32 x)->(var Uint32 num, var Bool has-data)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e2
struct TestIterator
    var Uint32 num
    func user step()
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e3
struct TestIterator
    var Uint32 num
    func user step()->(var Uint32 num)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e4
struct TestIterator
    var Uint32 num
    func user step()->(var Uint32 num, var Bool has-data, var Uint32 error)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e5
struct TestIterator
    var Uint32 num
    func user step()->(var Uint32 num, var Uint32 has-data)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e6
struct TestIterator
    var Uint32 num
    func weak step()->(var Uint32 num, var Bool has-data)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e7
struct TestIterator
    var Uint32 num
    func user ! step()->(var Uint32 num, var Bool has-data)
func fun(user TestIterator iter)
    for n in iter
; @@ test-complex-fields
; @ g test-complex-fields-0
struct Test
    var Bstruct b
    s-var Bstruct sb
    func user ! test()
        weak Bstruct b(weak self.sb)
        b := self.sb
        self.b.meth()
        Bstruct.meth(user self.b)
        user Bstruct? b2(user self.b.b!)
        b2 := self.b.b!
        self.b.b!.meth()
        self.b.b := b
        Bstruct.meth(user self.b.b!)
        s-var Test t!
        self.b.x := 5
        Astruct.meth(user self.b)
        if self.b is b or b2 is-not self.b
        b := t.b
class Astruct
    var Uint32 x
    func dynamic user? meth()
class Bstruct(Astruct)
    weak Bstruct? b
    func dynamic user? meth()
; @ g test-complex-fields-1
struct Base
    var Uint32 x
struct Test
    var Buffer{10} s
    var Array{11:Uint32} ai
    var Array{12:Base} ab
    var Array{7:Buffer{8}} as
    var Array{4:Array{5:Array{6:Uint32}}} aai
    var Array{4:Array{5:Array{6:Base}}} aab
    var Array{4:Array{5:Buffer{6}}} aas
    func user ! test()->(var Byte c, var Uint32 i, user Base? b)
        c := self.s[3]
        i := self.ai[4]
        b := self.ab[5]
        c := self.as[4][5]
        i := self.aai[1][2][3]
        b := self.aab[1][2][3]
        c := self.aas[1][2][3]
; @ eg test-complex-fields-e0
var Uint32 x
struct Test
    var Buffer{x} error
; @ eg test-complex-fields-e1
var Uint32 x
struct Test
    var Array{x:Uint32} error
; @ eg test-complex-fields-e2
struct Test
    var Test error
; @ eg test-complex-fields-e3
struct Test
    var Base error
struct Base
    var Test t
; @ eg test-complex-fields-e4
struct Abase
    var Berror b
struct Aerror(Abase)
struct Bbase
    var Aerror a
struct Berror(Bbase)
; @ eg test-complex-fields-e5
struct Base
    var Uint32 x
struct Test
    var Base b
    func user test(user Base b)
        self.b := b
; @ eg test-complex-fields-e6
struct Base
    var Uint32 x
struct Test
    var Base b
    func user ! error()
        assert! self.b?
; @@ test-enum
; @ g test-enum-0
enum MyEnum
    VALUE
    ANOTHER-VALUE
    LAST-VALUE
func dummy()
    var Uint32 x(copy MyEnum.VALUE)
    x := MyEnum.ANOTHER-VALUE
    x := MyEnum.length
; @ g test-enum-1
enum MyEnum
    VALUE
    ANOTHER-VALUE
    LAST-VALUE
var Array{MyEnum.length:Uint32} arr
; @ eg test-enum-e0
enum MyEnum
    VALUE
func dummy()
    var Uint32 x(copy MyEnum.ERROR)
; @ ec test-enum-e1
i := Error.VALUE
; @ eg test-enum-e2
enum MyEnum
    VALUE
func dummy()
    var Uint32 x(copy MyEnum.error)
; @ eg test-enum-e3
enum My-Enum
; @ eg test-enum-e4
enum MyEnum
    Error
; @ eg test-enum-e5
enum MyEnum
    ERRoR
; @ eg test-enum-e6
enum
; @ eg test-enum-e7
enum MyEnum
    VALUE(0)
; @ eg test-enum-e8
enum MyEnum
; @ eg test-enum-e9
enum MyEnum
        VALUE
; @ eg test-enum-e10
enum Error
    VALUE
enum Error
; @ eg test-enum-e11
struct Error
    var Uint32 x
enum Error
; @ eg test-enum-e12
enum Error
    VALUE
struct Error
    var Uint32 x
; @@ test-constant
; @ g test-constant-0
const Int NUMBER 12
; @ g test-constant-1
const Int SIZE 12
var Array{SIZE + 3:Uint32} arr
func fun(user Array{Uint32} a)
    fun(user arr)
; @ g test-constant-2
const Int LARGE 1 - (- (2 * SMALL))
const Int SMALL 7
; @ g test-constant-3
enum MyEnum
    VALUE
const Int NUMBER MyEnum.VALUE
; @ g test-constant-4
const Int NUMBER (128 div 3) mod 10
const Int D-CHAR 'a' + 3
; @ g test-constant-5
var Array{Enum.VAL + Enum.length + LENGTH:Uint32} arr
const Int LENGTH 6
enum Enum
    VAL
; @ eg test-constant-e0
const
; @ eg test-constant-e1
const Bool ERROR 0
; @ eg test-constant-e2
const Int
; @ eg test-constant-e3
const Int Error
; @ eg test-constant-e4
const Int ERROR
; @ eg test-constant-e5
const Int NAME false
; @ eg test-constant-e6
var Uint32 x
const Int NAME x
; @ eg test-constant-e7
const Int ERROR ERROR + 1
; @ eg test-constant-e8
const Int A-ERROR B-ERROR
const Int B-ERROR - (2 * A-ERROR) + 1
; @ eg test-constant-e9
const Int NUMBER 12
func dummy()
    NUMBER := 3
; @ eg test-constant-e10
const Int NUMBER 12
func dummy()->(var Uint32 x)
    dummy()->(var NUMBER)
; @@ test-module
; @ tg test-module-0
enum Enum
    VALUE
const Int SIZE 12
struct Test
    var Uint32 x
    func user meth()
var Test t
func ! fun()
    t.x := Enum.VALUE + SIZE
    fun()!
    Test.meth(user t)
    second.t.x := second.Enum.VALUE + second.SIZE
    second.fun()!
    second.Test.meth(user second.t)
    new second.Test nt!
; @-
module second
enum Enum
    VALUE
const Int SIZE 12
struct Test(ut.Test)
    func user meth()
var Test t
func ! fun()
    t.x := Enum.VALUE + SIZE
    fun()!
    Test.meth(user t)
    ut.t.x := ut.Enum.VALUE + ut.SIZE
    ut.fun()!
    ut.Test.meth(user ut.t)
    new ut.Test nt!
test dummy()
; @ tg test-module-1
func fun()
struct Test
    var Uint32 x
    func user meth()
        fun()
        self.meth()
; @-
module second
mock ut.fun()
mock ut.Test.meth()
test dummy()
; @ tg test-module-2
native type Native
native var Uint32 x
native func external()
func fun()
    x := 0
; @-
module second
test use()
    var ut.Native n
    ut.x := 2
    ut.external()
; @ ec test-module-e0
ut.error
; @ eg test-module-e1
var Uint32 ut
; @ eg test-module-e2
func ut()
; @ eg test-module-e3
var error.Test x
; @ eg test-module-e4
var ut.Error x
; @ etg test-module-e5
; nothing
; @-
module(error)
; @ etg test-module-e6
; @-
module Error
; @ etg test-module-e7
; @-
module true
; @ etg test-module-e8
; @-
module ; some global function
; @ etg test-module-e9
; @-
func fun()
; @ ec test-module-e10
fun0().Error
; @ ec test-module-e11
i.Error
; @ ec test-module-e12
ut.Error.VALUE
; @@ test-memory-owner
; @ g test-memory-owner-0
struct Test
    owner String? s
    owner String str
    new!()
        self.str := String()!
        self.str.clear()
func use(user String? s)
func take(owner String? s)
func give()->(owner String? s)
func ! fun(owner String? s, user Test tu, owner Test to)
    s := _
    s := String()!
    s!.clear()
    to.s := String()!
    user String? su(user tu.s)
    use(user tu.s)
    take(owner to.s)
    var Array{12:Uint32} arr
    arr[4] := arr[8]
    loop
        give()->(owner s)
        while s?
; @ g test-memory-owner-1
struct TestStruct
    owner TestStruct? next
class TestClass
    strong TestClass? next
    func dynamic user fun()
func ! fun(
        owner TestStruct t,
        strong TestClass c,
        strong TestStruct tx,
        owner TestClass cx)
    t := t.next!
    t := t.next!.next!.next!
    t.next := t.next!.next!.next
    t.next!.next := t.next!.next!.next
    c := c.next!
    tx := tx.next!
    cx := cx.next!
; @ eg test-memory-owner-e0
struct Test
    owner String s
    new()
func ! fun(user Test t)
    t.s := String()!
; @ eg test-memory-owner-e1
struct Aa
    var Uint32 x
struct Bb
    owner Aa? a
func fun(user Bb b)
    owner Aa? a(owner b.a)
; @ eg test-memory-owner-e2
struct Aa
    var Uint32 x
struct Bb
    owner Aa? a
func take(owner Aa? a)
func fun(user Bb b)
    take(owner b.a)
; @ eg test-memory-owner-e3
struct Aa
    owner String? s
struct Bb
    weak Aa? a
func ! fun(owner Array{Bb} b)
    b[3]!.a!.s := _
; @ eg test-memory-owner-e4
struct Test
    owner String? s
func get-user()->(weak Test? t)
func ! fun()
    weak Test? t
    get-user()->(weak t)!.s := _
; @ eg test-memory-owner-e5
struct Test
    owner String? s
func get-weak()->(weak Test? t)
func ! fun()
    get-weak()!.s := _
; @ eg test-memory-owner-e6
struct Test
    owner String s
    new()
func fun(owner Test t)->(owner String? s)
    s := t.s
; @ eg test-memory-owner-e7
struct Test
    owner String s
    new()
func fun(owner Test t)
    owner String s(owner t.s)
; @ eg test-memory-owner-e8
struct Test
    owner String s
    new()
func take(owner String s)
func fun(owner Test t)->(owner String? s)
    take(owner t.s)
; @ ec test-memory-owner-e9
new String s!
new String sg!
ostr := sg
sg := s
ostr!.clear()
sg.clear()
s.clear()
; @ eg test-memory-owner-e12
struct Test
    owner Test? t
func ! fun(owner Test? t)
    t!.t := t
; @ eg test-memory-owner-e13
struct Test
    owner Test? t
func ! fun(owner Test? t)
    t!.t!.t := t!.t
; @ eg test-memory-owner-e14
struct Test
    owner String s
    new!()
        self.s := String()!
func fun(owner Test t, user Test tu, owner String s, user String su)
    t.s :=: s
    su.clear()
    s.clear()
    t.s.clear()
    tu.s :=: s
; @ ec test-memory-owner-e15
fun8(strong so)
so!.clear()
new String s!
fun8(strong s!)
s.clear()
; @ ec test-memory-owner-e16
new Test tgood!
owner Test tbad
if b
    tgood := to!
tgood.meth()
if b
    tbad := to!
tbad.meth()
; @ ec test-memory-owner-e17
new String s!
repeat 12
    s.clear()
    ostr := s
    if b
        continue
    s := String()!
; @ eg test-memory-owner-e18
func fun(owner String? s, owner String? s2)
    fun(owner s, owner s)
; @ eg test-memory-owner-e19
func fun()->(owner String? s, owner String? s2)
    fun()->(owner s, owner s2)
    fun()->(owner s, owner s)
; @ eg test-memory-owner-e20
func fun(owner String? s)->(owner String? s2)
    fun(owner s)->(owner s)
; @ eg test-memory-owner-e21
struct Test
    var Uint32 x
func ! fun(owner Test? t)->(var Uint32 x)
    x := wraparound fun(owner t)! + t!.x
; @ eg test-memory-owner-e22
struct Test
    var Uint32 x
func ! fun(owner Test? t)->(var Uint32 x)
    x := wraparound t!.x + fun(owner t)!
; @ eg test-memory-owner-e23
func ! fun(owner String s)->(var Uint32 x)
    for _ in fun(owner s)!:s.length()
; @ ec test-memory-owner-e24
new String s!
try
    owner String s2(owner s)
    if b
        raise
    s := s2
s.clear()
; @ eg test-memory-owner-e25
struct Test
    owner String? s
func error()
    var cdef.Pointer{Test} pt
    pt.get-ref-at(copy 0).s := _
; @@ test-memory-user
; @ g test-memory-user-0
func deleting()->(owner String? s)
    s := _
func fun(user String s)->(owner String? so)
    s.clear()
    deleting()->(owner so)
; @ g test-memory-user-1
func deleting()->(strong String? s)
    s := _
func ! fun()
    strong String? so(strong String()!)
    user String? s(user so)
    s!.clear()
    deleting()->(strong so)
; @ g test-memory-user-2
func deleting()->(strong String? s)
    s := _
func ! fun()
    strong String? so(strong String()!)
    weak String? s(weak so)
    deleting()->(strong so)
    s!.clear()
; @ c test-memory-user-3
user String? s
so := _
s := so
s!.clear()
; @ g test-memory-user-4
struct Test
    weak String? s
    func user ! get()->(user String? s) _
func ! Test.get()->(user String? s)
    s := self.s!
func ! fun(user Test t)
    user String? s
    owner String? sowner(owner _)
    t.get()->(user s)!
    s!.clear()
    s := t.get()!
    s!.clear()
; @ c test-memory-user-5
user String? s(user ostr)
ostr := _
for s in sarr!
    s!.clear()
; @ g test-memory-user-6
func get()->(user String? s)
    s := _
func ! fun()
    loop
        user String? s
        while get()->(user s)?
        s!.clear()
; @ ec test-memory-user-e0
user Buffer? s
buff := _
c := s![2]!
; @ ec test-memory-user-e1
user String? s
user String? s2
so := _
s2 := s
; @ ec test-memory-user-e2
user String? s
so := _
s!.length()->(var i)
; @ ec test-memory-user-e3
user String? s
so := _
String.clear(user s!)
; @ ec test-memory-user-e4
user String? s
so := _
b := not (false or s!.length() > 3)
; @ eg test-memory-user-e5
func deleting(owner String? s)
func fun(user String s)
    deleting(owner _)
    s.clear()
; @ eg test-memory-user-e6
func deleting()->(owner String? s)
    s := _
func proxy()
    deleting()
func fun(user String s)
    proxy()
    s.clear()
; @ eg test-memory-user-e7
func deleting()->(owner String? s)
    proxy()
    s := _
func proxy()
    deleting()
func fun(user String s)
    proxy()
    s.clear()
; @ eg test-memory-user-e8
struct Test
    var Uint32 x
    func user deleting()->(owner String? s)
        s := _
    func user fun(user String s)
        self.deleting()
        s.clear()
; @ eg test-memory-user-e9
func deleting()->(owner String? s)
    s := _
func fun(user String s)
    deleting()
    s.clear()
; @ eg test-memory-user-e10
func deleting()
    owner String? s
func fun(user String s)
    deleting()
    s.clear()
; @ eg test-memory-user-e11
func deleting()
    var String s
func fun(user String s)
    deleting()
    s.clear()
; @ eg test-memory-user-e12
func deleting()
    strong String? s
func fun(user String s)
    deleting()
    s.clear()
; @ ec test-memory-user-e13
user Array{Byte} a(user buff!)
buff := _
bt := a[2]!
; @ eg test-memory-user-e14
func ! deleting()
    var Uint32 x(copy String()!.length())
func ! fun(user String s)
    deleting()!
    s.clear()
; @ eg test-memory-user-e15
struct Test
    owner String? s
func ! deleting(owner Test? ta, owner Test? tb)
    ta!.s := tb!.s
func ! fun(user String s)
    deleting(owner _, owner _)!
    s.clear()
; @ ec test-memory-user-e16
user Test? tt
d!.set(owner _)
tt.meth()
; @ eg test-memory-user-e17
struct MyStruct
    var Uint32 x
    func user meth()
struct Base{Atype}
    var Uint32 x
    func user fun(owner Atype? a)
struct Test{Btype}(Base{Btype})
    func user fun()
        base(owner _)
func fun(user MyStruct f)
    var Test{MyStruct} t
    t.fun()
    f.meth()
; @ eg test-memory-user-e18
struct Base
    var Uint32 x
struct Test(Base)
func deleting(owner Base? b)
func fun(user Test t)
    deleting(owner _)
    t.x := 0
; @ eg test-memory-user-e19
struct Base
    var Uint32 x
struct Test(Base)
struct Other(Base)
func deleting(owner Test? t)
func fun(user Base b, user Other o)
    deleting(owner _)
    o.x := 0
    b.x := 0
; @ eg test-memory-user-e20
class Base
    var Uint32 x
    func dynamic user fun()
class Test(Base)
    func dynamic user fun()
        owner String? s
func fun(user String s, user Base b)
    b.fun()
    s.clear()
; @ eg test-memory-user-e21
class Base
    var Uint32 x
    func dynamic user fun()
class Test{Generic}(Base)
    func dynamic user fun()
func fun(user String s, user Base b)
    b.fun()
    s.clear()
; @ eg test-memory-user-e22
class Base
    var Uint32 x
    func dynamic user? fun(owner Base? b)
        recursive()
class Test{Generic}(Base)
    func dynamic user? fun(owner Base? b)
func recursive()
    Base.fun(user _, owner _)
func fun(user String s)
    recursive()
    s.clear()
; @ ec test-memory-user-e23
user String? s
t!.fun!()
s!.clear()
; @ eg test-memory-user-e24
func ! deleting(copy Func?{()} f)
    f!()
func ! fun(user String s)
    deleting(copy _)!
    s.clear()
; @ eg test-memory-user-e29
struct Test
    owner String? s
func fun(owner Test? t, user String s)
    t := _
    s.clear()
; @ eg test-memory-user-e30
struct Other
    owner String? s
struct Test
    owner Other? o
func fun(owner Test? t, user String s)
    t := _
    s.clear()
; @ eg test-memory-user-e31
struct MyStruct
    var Uint32 x
    func user meth()
struct Base
    owner String? s
struct Test(Base)
struct Other(Base)
    owner MyStruct? f
func fun(owner Test? t, user String s, user MyStruct f)
    t := _
    f.meth()
    s.clear()
; @ eg test-memory-user-e32
struct Base
    var Uint32 x
struct Test(Base)
    owner String? s
func fun(owner Base? b, user String s)
    b := _
    s.clear()
; @ eg test-memory-user-e33
struct MyStruct
    var Uint32 x
    func user meth()
struct Test{Generic}
    owner Generic? x
func fun(owner Test?{MyStruct} t, user MyStruct f)
    t := _
    f.meth()
; @ eg test-memory-user-e34
struct MyStruct
    var Uint32 x
    func user meth()
struct Base{Generic}
    owner Generic? x
struct Test{Data}(Base{Data})
func ! fun(owner Test?{MyStruct} t, user MyStruct f)
    t := _
    f.meth()
; @ eg test-memory-user-e35
main!
    owner String? so(owner String()!)
    user String? su(user so)
    so := _
    su!.clear()
; @ ec test-memory-user-e36
so := _
assert! str?
; @ ec test-memory-user-e37
so := _
assert-error! str.clear()
; @ ec test-memory-user-e38
so := _
if str?
; @ ec test-memory-user-e39
so := _
for _ in str!.length():2
; @ ec test-memory-user-e40
so := _
for _ in 2:str!.length()
; @ ec test-memory-user-e41
so := _
for _ in bfr!
; @ ec test-memory-user-e42
so := _
if b
    str!.clear()
; @ ec test-memory-user-e43
so := _
if false
    str := ostr
str!.clear()
; @ ec test-memory-user-e44
str := ostr
repeat 12
    str!.clear()
    ostr := _
    if b
        continue
    str := ostr
; @ ec test-memory-user-e45
str := ostr
try
    ostr := _
    if b
        raise
    str := ostr
str!.clear()
; @ ec test-memory-user-e46
bfr := buff
for n in bfr!
    buff := _
; @@ test-memory-temp
; @ g test-memory-temp-0
struct Test
    owner String? s
func fun(temp Test t)
    t.s := _
func use(owner Test t)
    fun(temp t)
    fun(temp t)
    temp Test tt(temp t)
    fun(temp tt)
    fun(temp tt)
    temp Test? tc
    tc := _
; @ g test-memory-temp-1
struct Test
    owner String? s
func fun(owner Test to)
    temp Test t(temp to)
    t.s := _
; @ g test-memory-temp-2
struct Test
    owner String? s
func fun(owner Test to, owner String s, owner String s2)
    temp String so(temp s)
    temp String so2(temp s2)
    if to.s?
        to.s := _
        temp Test t1(temp to)
        t1.s := _
        so.clear()
        so2 := so
        so2.clear()
        temp String si(temp so2)
    else
        to.s := _
        temp Test t2(temp to)
        t2.s := _
        so.clear()
        temp String si(temp so)
        so2 := si
        so2.clear()
    to.s := _
    temp Test t3(temp to)
    t3.s := _
    so.clear()
; @ g test-memory-temp-3
struct Test
    owner Test? next
func ! fun(owner Test to)
    temp Test t(temp to)
    loop
        while t.next?
        t := t.next!
; @ eg test-memory-temp-e0
func fun(temp String s)
func error(user String s)
    fun(temp s)
; @ eg test-memory-temp-e1
func fun(owner String s)
func error(temp String s)
    fun(owner s)
; @ eg test-memory-temp-e2
func error()->(temp String s)
; @ eg test-memory-temp-e3
func fun(temp String s1, temp String s2)
func error(owner String s)
    fun(temp s, temp s)
; @ eg test-memory-temp-e4
func fun(owner String so, temp String st)
func error(owner String s)
    fun(owner s, temp s)
; @ eg test-memory-temp-e5
func fun(temp String st, owner String so)
func error(owner String s)
    fun(temp s, owner s)
; @ eg test-memory-temp-e6
struct Sa
    owner Sb? sb
struct Sb
    owner Sa? sa
func fun(temp Sb sb, temp Sb x)
    sb.sa := x.sa
func ! error(owner Sb x)
    x.sa := Sa()!
    x.sa!.sb := Sb()!
    fun(temp x.sa!.sb!, temp x)
; @ ec test-memory-temp-e7
temp String? s1(temp so)
temp String? s2(temp so)
; @ ec test-memory-temp-e8
temp String? s(temp so)
so!.clear()
; @ ec test-memory-temp-e9
temp String? s1(temp so)
temp String? s2(temp s1)
s1!.clear()
; @ ec test-memory-temp-e10
temp String? s
if true
    s := so
s!.clear()
; @ ec test-memory-temp-e11
temp String? s
if true
    temp String? si(temp so)
    s := si
s!.clear()
; @ eg test-memory-temp-e12
struct Test
    owner Test? next
func ! fun(owner Test t)
    temp Test x(temp t.next!.next!)
    x.next := t
; @ eg test-memory-temp-e13
struct Test
    owner Test? next
func ! fun(owner Test t)
    temp Test x(temp t.next!.next!)
    x.next := t.next
; @ ec test-memory-temp-e14
temp String? s(temp ostr)
; @ eg test-memory-temp-e15
struct Test
    owner String? s
owner Test? t
func ! error()
    temp String? s(temp t!.s)
; @@ test-memory-output
; @ g test-memory-output-0
func ! fun()->(owner String s)
    s := String()!
    s.clear()
; @ eg test-memory-output-e0
func fun()->(user String s)
; @ eg test-memory-output-e1
func deleting()
    owner String? s
func fun()->(user String? s)
    s := _
    deleting()
; @ eg test-memory-output-e2
func fun(owner String so)->(user String? s)
    s := _
; @ eg test-memory-output-e3
func fun()->(user String? s)
    owner String? so
    s := _
; @ eg test-memory-output-e4
func fun(user String sin)->(user String sout)
    if false
        sout := sin
; @ eg test-memory-output-e5
func fun(user String sin)->(user String sout)
    if true
        return
    sout := sin
; @ eg test-memory-output-e6
func fun()->(owner String s)
    s.clear()
; @ eg test-memory-output-e7
func fun()->(owner String s)
; @ eg test-memory-output-e8
func ! fun()->(owner String s)
    if true
        s := String()!
; @ eg test-memory-output-e9
func ! fun()->(owner String s)
    if false
        return
    s := String()!
; @@ test-memory-constructor
; @ g test-memory-constructor-0
struct NoConstructor
    var String s
struct HasConstructor
    owner String s
    new!()
        self.s := String()!
struct Test
    var NoConstructor vnc
    var HasConstructor vhc
    s-var NoConstructor svnc
    s-var HasConstructor svhc
    new!()
        self.vnc.s.clear()
        self.svnc.s.clear()
        self.vhc.new()!
        self.vhc.s.clear()
        self.svhc.new()!
        self.svhc.s.clear()
; @ g test-memory-constructor-1
func fun1()
func fun2(copy Func{()} f)
struct Base
    owner String s
    new!()
        self.s := String()!
struct Mid(Base)
    new!()
        base()!
struct Test(Mid)
    owner Base? b
    new!()
        fun1()
        fun2(copy fun1)
        self.b!.new()!
        base()!
; @ g test-memory-constructor-2
struct Test
    var Int{1:100} a
    var Int{-30:-1} b
    var Int{0:100} c
    var Int{-30:0} d
    var Int{-10:10} e
    new()
        self.a := 1
        self.b := -1
; @ eg test-memory-constructor-e0
struct Error
    weak String s
; @ eg test-memory-constructor-e1
struct Error
    owner String s
    new()
; @ eg test-memory-constructor-e2
struct Error
    weak String s
    new!(strong String s)
        self.s!.clear()
        self.s := s
; @ eg test-memory-constructor-e3
struct Error
    owner String s
    new!()
        self.fun()
        self.s := String()!
    func user fun()
        self.s.clear()
; @ eg test-memory-constructor-e4
struct Error
    owner String s
    new!()
        error(user self)
        self.s := String()!
func error(user Error e)
    e.s.clear()
; @ eg test-memory-constructor-e5
struct Error
    owner String s
    new!()
        if false
            self.s := String()!
; @ eg test-memory-constructor-e6
struct Error
    owner String s
    new() _
func Error.new()
; @ eg test-memory-constructor-e7
struct Error
    owner String s
    new!()
        if true
            return
        self.s := String()!
; @ eg test-memory-constructor-e8
struct Test
    owner String s
    new!()
        self.s := String()!
struct Error
    var Test t
; @ eg test-memory-constructor-e9
struct Test
    owner String s
    new!()
        self.s := String()!
struct Error
    var Test t
    new()
; @ eg test-memory-constructor-e10
struct Base
    owner String s
    new!()
        self.s := String()!
struct Test(Base)
    new()
; @ eg test-memory-constructor-e11
struct Test
    owner String s
    new!()
        self.s := String()!
struct Error
    var Test t
    new!()
        self.t.s.clear()!
; @ eg test-memory-constructor-e12
struct Test
    owner String s
    new!()
        self.s := String()!
struct Error
    var Test t
    new!()
        if false
            self.t.new()!
        self.t.s.clear()!
; @ eg test-memory-constructor-e13
struct Test
    var Int{1:100} a
; @ eg test-memory-constructor-e14
struct Test
    var Int{1:100} a
    new()
; @ eg test-memory-constructor-e15
struct Test
    var Int{1:100} a
    new!()
        if self.a = 1
        self.a := 1
; @@ test-memory-error
; @ ec test-memory-error-e0
str := str
; @ eg test-memory-error-e1
struct Error
    user String? s
; @ eg test-memory-error-e2
struct Error
    temp String? s
; @ eg test-memory-error-e3
func error(var String s)
; @ eg test-memory-error-e4
func error()->(var String s)
; @@ test-c-objects
; @ c test-c-objects-0
var Uint16 u16
var Sint16 s16
var Uint32 u32
var Sint32 s32
var Uint64 u64
var Sint64 s64
var cdef.Char c-char
var cdef.Schar c-schar
var cdef.Uchar c-uchar
var cdef.Short c-short
var cdef.Ushort c-ushort
var cdef.Int c-int
var cdef.Uint c-uint
var cdef.Long c-long
var cdef.Ulong c-ulong
var cdef.Size c-size
var cdef.Float c-float
var cdef.Double c-double
var cdef.LongDouble c-long-double
; line 20
c-char := s16
s32 := c-char
c-schar := s16
s32 := c-schar
c-uchar := u16
u16 := c-uchar
c-short := s32
s64 := c-short
c-ushort := u32
u32 := c-ushort
c-int := s64
s64 := clamp c-int
c-uint := u64
u64 := c-uint
c-long := s64
s64 := clamp c-long
c-ulong := u64
u64 := c-ulong
c-size := u64
; line 40
u64 := c-size
c-float := s64
s64 := clamp c-float
c-double := s64
s64 := clamp c-double
c-long-double := s64
s64 := clamp c-long-double
; line 48
j := c-char clamp+ (c-schar clamp+ (c-uchar clamp+ (c-short clamp+
        (c-ushort clamp+ (c-int clamp+ (c-uint clamp+ (c-long clamp+
        (c-ulong clamp+ (c-size clamp+ (c-float clamp+ (c-double clamp+
        (c-long-double clamp+ (c-char)))))))))))))
; @ c test-c-objects-1
var cdef.Pointer p-void
var cdef.CharP p-char
var cdef.Pointer{cdef.Uint} p-uint
var cdef.Pointer{Test} p-test
var cdef.Pointer{cdef.Pointer{cdef.Int}} pp-int
var cdef.Pointer{cdef.Pointer{cdef.CharP}} ppp-char
p-void := p-char
p-uint := p-void
p-char := p-uint
b := p-void? or p-char? or p-test? or pp-int? or ppp-char?
p-void := str
; @ c test-c-objects-2
var cdef.Int cint
var cdef.Pointer{cdef.Int} p-int
var cdef.Pointer{cdef.Pointer{cdef.Int}} pp-int
user Array?{cdef.Int} arr-int
p-int := arr-int
p-int.set-point-to(var cint)
pp-int.set-point-to(var p-int)
p-int := pp-int.get-pointed-at(copy 0)
cint := p-int.get-pointed-at(copy 3)
p-int.get-pointed-at(copy 3) := 5
var Test test
user Test u-test(user test)
var cdef.Pointer{Test} p-test
user Array?{Test} arr-test
p-test := arr-test
p-test := test
u-test := p-test.get-ref-at(copy 5)
; @ g test-c-objects-3
native func ext(copy cdef.CharP p-char, copy cdef.Pointer{cdef.Uchar} p-uchar)
func proxy(copy cdef.CharP p-char, copy cdef.Pointer{cdef.Uchar} p-uchar)
func ! fun(user String str, user Buffer? buff)
    var cdef.CharP p-char
    var cdef.Pointer{cdef.Uchar} p-uchar
    p-char := str.cdef-pointer()
    p-uchar := buff
    ext(copy str.cdef-pointer(), copy buff)
    proxy(copy str.cdef-pointer(), copy buff)
    cdef.copy-to-string(copy p-char, user str)!
; @ c test-c-objects-4
var cdef.Pointer{cdef.Uchar} p-uchar
cdef.copy-to-buffer(copy p-uchar, user buff!)
; @ ec test-c-objects-e0
var cdef.Pointer{Ta} error
; @ ec test-c-objects-e1
var cdef.Pointer{Uint32} p-int
i := p-int.get-ref-at(copy 5)
; @ ec test-c-objects-e2
var Test tv
var cdef.Pointer{Test} p-test
tv := p-test.get-pointed-at(copy 0)
; @ ec test-c-objects-e3
var cdef.Pointer?{cdef.Int} error
; @ ec test-c-objects-e4
var cdef.Pointer{cdef.Int} ip(copy str)
; @@ test-cleanup-function
; @ g test-cleanup-function-0
struct Test
    owner String? s
    cleanup()
        try
            self.s.clear()
; @ g test-cleanup-function-1
class Base
    var Uint32 x
    func dynamic user meth()
    cleanup()
        self.meth()
class Test(Base)
    cleanup()
        self.meth()
; @ eg test-cleanup-function-e0
struct Test
    var Uint32 x
    cleanup()
    cleanup()
; @ eg test-cleanup-function-e1
struct Test
    var Uint32 x
    cleanup!()
; @ eg test-cleanup-function-e2
struct Test
    owner String? s
    cleanup()
        self.s!.clear()
; @ eg test-cleanup-function-e3
struct Test
    var Uint32 x
    cleanup(copy Uint32 error)
; @ eg test-cleanup-function-e4
struct Test
    var Uint32 x
    cleanup()->(var Uint32 error)
; @ eg test-cleanup-function-e5
struct Test
    var Uint32 x
    func temp cleanup()
; @