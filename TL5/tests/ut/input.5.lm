struct Test
    var Uint32 num
    weak Test? t
    var Func?{()} fun
    func user? meth()
class Ta(Test)
    var Uint32 numa
    func inst user? metha()
    func dynamic user? dyn()
class Tb(Ta)
    var Uint32 numb
    new!(copy Uint32 num)
    func inst user? methb()
    func dynamic user? dyn()
class Tc(Tb)
    var Uint32 numc
    func inst user? methc()
    func dynamic user? dyn()
struct Data{Generic}
    weak Generic? item
    func user? set(owner Generic? item)
    func user? get()->(weak Generic? item)

func fun0()
func fun1(copy Uint32 x, user String? s, owner String? o)
func fun2()->(strong String? s, var Uint32 x)
func fun3(copy Uint32 x)->(strong String? s)
func fun4(copy Uint32 x)
func fun5(copy Uint32 x)->(var Uint32 y)
func fun6(copy Uint32 x, copy Uint32 y)->(var Uint32 n, var Uint32 m)
func fun7(weak Tb? tb)->(weak Tb? tbo)
func fun8(strong String? s)
func ! fune()

var Uint32 i
var Sint32 j
var Byte bt
var Char c
var Bool b
owner String? ostr
owner Buffer? buff
weak Array?{Uint32} arr
weak Test? t
weak Ta? ta
strong Tb? tb
weak Tc? tc
weak Data?{Test} d
weak Array?{String} sarr
weak Array?{Buffer} barr

func ! mock(user String? str, user Buffer? bfr)->(strong String? so, var Uint32 io, strong Test? to, weak Tc? tco)
; @@ test-int-expression
; @ c test-int-expression-0
i := 0
; @ c test-int-expression-1
i := 9630
; @ c test-int-expression-2
j := -9630
; @ c test-int-expression-3
i := 07520
; @ c test-int-expression-4
j := -07520
; @ c test-int-expression-5
i := 0xfda940
; @ c test-int-expression-6
j := -0xfda940
; @ c test-int-expression-7
i := 0xFDA940
; @ c test-int-expression-8
j := -0xFDA940
; @ c test-int-expression-9
i := 0b100101
; @ c test-int-expression-10
j := -0b100101
; @ ec test-int-expression-e0
2a
; @ ec test-int-expression-e1
0a
; @ ec test-int-expression-e2
038
; @ ec test-int-expression-e3
0b021
; @ ec test-int-expression-e4
0xadg
; @@ test-byte-expression
; @ c test-byte-expression-0
bt := 0
; @ c test-byte-expression-1
bt := 127
; @ c test-byte-expression-2
bt := 075
; @ c test-byte-expression-3
bt := 0xfd
; @ c test-byte-expression-4
bt := 0xFD
; @ c test-byte-expression-5
bt := 0b10010100
; @@ test-char-expression
; @ c test-char-expression-0
c := 'a'
; @ c test-char-expression-1
c := '\''
; @ c test-char-expression-2
c := '\n'
; @ c test-char-expression-3
c := '\x0f'
; @ c test-char-expression-4
c := '\x7A'
; @ c test-char-expression-5
c := '\173'
; @ fec test-char-expression-e0
c := '''
; @ fec test-char-expression-e1
c := '\'
; @ fec test-char-expression-e2
c := 'aa
; @ ec test-char-expression-e3
c := '\c'
; @ ec test-char-expression-e4
c := 'aaaa'
; @ ec test-char-expression-e5
c := '\x6g'
; @ ec test-char-expression-e6
c := '\058'
; @ ec test-char-expression-e7
c := ''
; @ ec test-char-expression-e8
c := 'aa'
; @ ec test-char-expression-e9
c := 'aaa'
; @ ec test-char-expression-e10
c := 'aaaaa'
; @@ test-string-expression
; @ c test-string-expression-0
str := "some string"
; @ c test-string-expression-1
str := "\nstring'\t\"with\\\'formatting\n"
; @ c test-string-expression-2
str := "line\
        split\
        string\
        "
; @ c test-string-expression-3
str := "multi
        line
        string
        "
; @ c test-string-expression-4
str := "line\
         split"
; @ fec test-string-expression-e0
str := "aaa
; @ fec test-string-expression-e1
str := "
; @ ec test-string-expression-e2
"error"+"string"
; @ ec test-string-expression-e3
str := "indention
    too short"
; @ ec test-string-expression-e4
str := "indention\
    too short"
; @ g test-string-expression-large
func fun()
    user String s(user "\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789\
            012345678901234567890123456789012345678901234567890123456789")
; @@ test-buffer-expression
; @ c test-buffer-expression-0
bfr := `4a00e2ff59`
; @ c test-buffer-expression-1
bfr := `4a00
        e2ff
        59a8`
; @ c test-buffer-expression-2
bfr := `
        4a00
        e2ff
        59a8
        `
; @ fec test-buffer-expression-e0
bfr := `0000
; @ fec test-buffer-expression-e1
bfr := `
; @ ec test-buffer-expression-e2
bfr := `4a00
    e2ff
    59a8`
; @ ec test-buffer-expression-e3
bfr := `4a00e2fg59a8`
; @ ec test-buffer-expression-e4
bfr := `4a00e2ff59a`
; @ g test-buffer-expression-large
func fun()
    user Buffer b(user `
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899
            001122334455667788990011223344556677889900112233445566778899`)
; @@ test-empty-expression
; @ c test-empty-expression-0
str := _
; @ c test-empty-expression-1
t := _
; @ c test-empty-expression-2
so := _
; @ c test-empty-expression-3
b := t is _ or ta is-not _
; @ ec test-empty-expression-e0
i := _
; @@ test-member-expression
; @ c test-member-expression-0
i := t!.num
; @ c test-member-expression-1
i := tc!.numb
; @ c test-member-expression-2
i := tc!.num
; @ c test-member-expression-3
i := to!.num
; @ c test-member-expression-4
tco := tc
i := tco!.num
; @ c test-member-expression-5
i := t!.t!.num
; @ c test-member-expression-6
i := t!.t!.t!.num
; @ ec test-member-expression-e0
error
; @ ec test-member-expression-e1
(i := 1).error
; @ ec test-member-expression-e2
t.error
; @ ec test-member-expression-e3
5.error
; @@ test-slice-expression
; @ c test-slice-expression-0
c := ostr![13]!
bt := buff![13]!
; @ c test-slice-expression-1
user Array?{Char} x
x := ostr![2:6]!
user Array?{Byte} y
y := buff![2:6]!
; @ c test-slice-expression-2
i := arr![13]!
; @ c test-slice-expression-3
user Array?{Uint32} x
x := arr![2:i]!
; @ c test-slice-expression-4
ostr![4]! := c
buff![4]! := bt
; @ c test-slice-expression-5
arr![4]! := i
; @ c test-slice-expression-6
strong Array?{Test} tarr
t := tarr![3]!
; @ c test-slice-expression-7
var Array{8:String{5}} vsa
user String s(user vsa[3])
user Array{String} sa(user vsa[2:4])
var Array{8:Buffer{5}} vba
user Buffer bf(user vba[3])
user Array{Buffer} ba(user vba[2:4])
; @ g test-slice-expression-8
func ! fun(
        temp String s,
        strong Array{String} sa,
        temp Buffer b,
        strong Array{Buffer} ba)
    var Char c(copy s[5]!)
    user Array{Char} spart(user s[4:2]!)
    user String si(user sa[3]!)
    var Byte y(copy b[5]!)
    user Array{Byte} bpart(user b[4:2]!)
    user Buffer bi(user ba[3]!)
; @ c test-slice-expression-9
strong Array?{String} sa
sa![3]!.new(user "text")!
sa := _
strong Array?{Buffer} ba
ba![3]!.new(user `beef`)!
ba := _
; @ c test-slice-expression-10
strong Array?{Array{Uint32}} aai
arr := aai![3]!
weak Array?{Array{Uint32}} ua(weak aai![2:4]!)
; @ c test-slice-expression-11
strong Array?{Array{Array{Array{Uint32}}}} aai
weak Array?{Array{Array{Uint32}}} ua(weak aai![3]!)
weak Array?{Array{Array{Array{Uint32}}}} uaa(weak aai![2:4]!)
; @ c test-slice-expression-12
strong Array?{Array{Array{String}}} aas
weak Array?{Array{String}} wsa(weak aas![3]!)
weak Array?{Array{Array{String}}} wsaa(weak aas![2:4]!)
aas := _
strong Array?{Array{Array{Buffer}}} aab
weak Array?{Array{Buffer}} wba(weak aab![3]!)
weak Array?{Array{Array{Buffer}}} wbaa(weak aab![2:4]!)
aas := _
; @ c test-slice-expression-13
var Array{8:Array{7:Array{6:Array{5:Uint32}}}} aai
user Array?{Array{Array{Uint32}}} ua(user aai[3])
user Array?{Array{Array{Array{Uint32}}}} uaa(user aai[2:4])
; @ c test-slice-expression-14
var Array{8:Array{7:Array{6:String{5}}}} aas
user Array?{Array{String}} usa(user aas[i]!)
user Array?{Array{Array{String}}} usaa(user aas[2:4])
var Array{8:Array{7:Array{6:Buffer{5}}}} aab
user Array?{Array{Buffer}} uba(user aab[i]!)
user Array?{Array{Array{Buffer}}} ubaa(user aab[2:4])
; @ g test-slice-expression-15
func fun()
    var Array{8:Array{7:Array{6:String{5}}}} aas
    user String s(user aas[4][3][2])
    var Array{8:Array{7:Array{6:Buffer{5}}}} aab
    user Buffer b(user aab[4][3][2])
; @ c test-slice-expression-16
user Array?{Char} x
x := ostr
user Array?{Byte} y
y := buff
; @ c test-slice-expression-17
new String{12} s!
sys.print(user s)!
new Buffer{12} bf!
; @ g test-slice-expression-18
struct Test
    owner String? s
    owner Buffer? b
func fun()
    var Test t
    var Array{6:Test} a
; @ c test-slice-expression-19
new Array{i:Uint32} a!
var Sint8 x
var Int{-6:0} y
i := wraparound a[x:x]![y:y + 1]![x]! + a[i:i + 1]![0:y + 1]![y]! + a[0:1][i]!
var Int{100:200} length
new Array{length:Uint32} aa!
var Int{10:20} xx(copy 10)
var Int{0:8} yy
i := aa[xx:xx][yy]
var Array{12:Uint32} ab
i := ab[3:4][3]
; @ c test-slice-expression-20
i := str![2]! + buff![2]! + str![1:3]![2] + buff![1:3]![2]
; @ ec test-slice-expression-e0
arr[2
; @ ec test-slice-expression-e1
arr[2:3
; @ ec test-slice-expression-e2
(i := 3)[2]!
; @ ec test-slice-expression-e3
i[2]!
; @ ec test-slice-expression-e4
arr![str]!
; @ ec test-slice-expression-e5
arr![3:str]!
; @ ec test-slice-expression-e6
arr![i wraparound+= 3]!
; @ ec test-slice-expression-e7
str![2:5]! := so
; @ ec test-slice-expression-e8
arr![7:2]! := Array{5:Uint32}()!
; @ ec test-slice-expression-e9
user Array?{Test} at
at![0] := t
; @ ec test-slice-expression-e10
so := sarr![3]!
; @ ec test-slice-expression-e11
var Array{3:Tc} error
; @ eg test-slice-expression-e12
struct Test
    var Uint32 x
    new()
func func(user Array{Test} error)
; @ ec test-slice-expression-e13
i := arr![i]
; @ ec test-slice-expression-e14
var Array{0:Uint32} error
; @ ec test-slice-expression-e15
arr![-1]
; @ ec test-slice-expression-e16
var Int{-10:-2} x
arr![x]
; @ ec test-slice-expression-e17
arr![1:0]
; @ ec test-slice-expression-e18
var Int{-10:0} x
arr![1:x]
; @ ec test-slice-expression-e19
s-var Array{3:Uint32} a!
arr := a[1:3]
; @ ec test-slice-expression-e20
var Int{-10:10} length
new Array{length:Uint32} a!
var Int{8:80} x
arr := a[x:x]
; @@ test-call-expression
; @ c test-call-expression-0
fun0()
; @ c test-call-expression-1
fun1(copy 3, user ostr, owner _)
; @ c test-call-expression-2
fun2()->(strong so, var io)
; @ c test-call-expression-3
var Uint32 x
strong String? s
fun2()->(strong s, var x)
; @ c test-call-expression-4
fun3(copy 0)->(strong so)
; @ c test-call-expression-5
var Uint32 x
fun4(copy fun5(copy 3)->(var x))
; @ c test-call-expression-6
fun6(
        copy 2,
        copy 3)->(
        var io,
        var io)
; @ c test-call-expression-7
fun5(copy 4)
; @ c test-call-expression-8
io := fun5(copy 4)
; @ c test-call-expression-9
so := fun3(copy 7)
; @ c test-call-expression-10
t!.meth()
; @ c test-call-expression-11
to.meth()
; @ c test-call-expression-12
tc!.methc()
; @ c test-call-expression-13
tc!.methb()
; @ c test-call-expression-14
tc!.meth()
; @ c test-call-expression-15
tco := tc
tco!.meth()
; @ c test-call-expression-16
t!.t!.meth()
; @ c test-call-expression-17
fun1(copy 3, user ostr, owner so)
; @ c test-call-expression-18
fun3(copy 1)
fun5(copy 2)
; @ g test-call-expression-19
class Base
    var Uint32 x
    func dynamic user ! meth(owner Base b)
class Test(Base)
    func dynamic user ! meth(owner Base b)
        new Test t!
        base(owner t)!
; @ g test-call-expression-20
class Test
    var Uint32 x
    func dynamic user meth()
func ! mock()->(weak Test? t)
    mock()->(weak t)!.meth()
; @ g test-call-expression-21
class Test
    var Uint32 x
    func dynamic user ! meth()->(weak Test? t)
        self.meth()!.meth()!
; @ g test-call-expression-22
func fun()->(owner Array?{String} astr)
    fun()->(owner astr)
; @ g test-call-expression-23
func ! fun(temp String s)
    var String{12} vars
    s-var String{12} s-vars!
    owner String owners(owner String{12}()!)
    strong String strongs(strong String{12}()!)
    user String users(user s)
    fun(temp s)!
    fun(temp vars)!
    fun(temp s-vars)!
    fun(temp owners)!
    fun(temp strongs)!
    s.clear()
; @ c test-call-expression-24
strong String? s
weak String? sw
fun1(copy 0, user sw!, owner s)
; @ c test-call-expression-25
fun8(strong ostr)
; @ c test-call-expression-26
fune()!
; @ c test-call-expression-27
var Uint8 u8
var Sint8 s8
var Uint32 u32
var Sint32 s32
var Uint64 u64
var Sint64 s64
u8 := wraparound fun5(copy 0)
s8 := clamp fun5(copy 1)
fun5(copy 50)->(var u32)
s32 := clamp fun5(copy 2)
fun5(copy 3)->(var u64)
fun5(copy 4)->(var s64)
; @ g test-call-expression-28
func ! get()->(weak String res)
    weak String s
    get()->(weak s)!
    s!.clear()
    res := s
; @ ec test-call-expression-e0
function( copy 1)
; @ ec test-call-expression-e1
function(user)
; @ ec test-call-expression-e2
function(copy 4,copy 3)
; @ ec test-call-expression-e3
function(copy 2
; @ ec test-call-expression-e4
function(error 4)
; @ ec test-call-expression-e5
(i := 0)()
; @ ec test-call-expression-e6
i()
; @ ec test-call-expression-e7
fun5(copy 0)->(var 4)
; @ ec test-call-expression-e8
fun7(weak _)->(weak tc)
; @ ec test-call-expression-e9
fun5(copy i := 1)
; @ ec test-call-expression-e10
fun5(user 8)
; @ ec test-call-expression-e11
fun1(copy 3, user str, owner str)
; @ ec test-call-expression-e12
fun3(copy 3)->(strong str)
; @ ec test-call-expression-e13
fun7(weak _)->(weak tb)
; @ ec test-call-expression-e14
fun0(copy i)
; @ ec test-call-expression-e15
fun1()
; @ ec test-call-expression-e16
fun0()->(copy i)
; @ ec test-call-expression-e17
fun2()
; @ eg test-call-expression-e18
struct Base
    var Uint32 x
    func user meth(owner Base b)
struct Test(Base)
    func user meth(owner Test t)
        base(owner t)
; @ ec test-call-expression-e19
var String{16} text
fun1(copy 3, user str, owner text)
; @ ec test-call-expression-e20
owner Tb? tbo
fun7(weak tbo)
; @ ec test-call-expression-e21
fune()
; @ eg test-call-expression-e22
func ! fune()
func fun()
    fune()!
; @ ec test-call-expression-e23
strong String s
fun3(copy 0)->(strong s)
; @ eg test-call-expression-e24
func fun(weak String in)->(weak String out)
    weak String s
    s := fun(weak s)
    out := s
; @ ec test-call-expression-e25
fun0()->()
; @@ test-type-expression
; @ c test-type-expression-0
Test.meth(user t!)
; @ c test-type-expression-1
Tb.methb(user tc!)
; @ c test-type-expression-2
Tc.meth(user tc!)
; @ ec test-type-expression-3
Error
; @@ test-base-expression
; @ g test-base-expression-0
struct Base
    var Uint32 x
    func user methb()
struct Mid(Base)
    func user methm()
struct Top(Mid)
    func user methb()
    func user methm()
        base.methm()
; @ g test-base-expression-1
struct Base
    var Uint32 x
    func user methb()
struct Mid(Base)
    func user methm()
struct Top(Mid)
    func user methb()
    func user methm()
        base.methb()
; @ ec test-base-expression-e0
base
; @ eg test-base-expression-e1
struct Test
    var Uint32 x
    func user mock()
        base
; @ eg test-base-expression-e2
struct Base
    var Uint32 x
struct Test(Base)
    var Uint32 x
    func user mock()
        base()
; @ eg test-base-expression-e3
struct Base
    var Uint32 x
struct Test(Base)
    func user mock()
        base := self
; @ eg test-base-expression-e4
struct Base
    var Uint32 x
struct Test(Base)
    func user mock()->(var Uint32 x)
        x := base.x
; @@ test-block-expression
; @ c test-block-expression-0
i := 2 + (123)
; @ c test-block-expression-1
i := (123)
; @ c test-block-expression-2
i := wraparound (123 * (i - 4)) + 2
; @ ec test-block-expression-3
(error
; @@ test-unary-expression
; @ c test-unary-expression-0
j := - j
; @ c test-unary-expression-1
j := -
        j
; @ c test-unary-expression-2
i := - - i
; @ c test-unary-expression-3
b := not b
; @ c test-unary-expression-4
b := not i > 3
; @ c test-unary-expression-5
i := clamp i + 1
; @ c test-unary-expression-6
j := clamp j - 1
; @ c test-unary-expression-7
var Sint8 x(copy clamp j)
x := clamp j
; @ c test-unary-expression-8
i := clamp! i + 1
; @ c test-unary-expression-9
j := clamp! j - 1
; @ c test-unary-expression-10
j := clamp! j * 2
; @ c test-unary-expression-11
if-error i := clamp? i + 1
    i := 12
; @ c test-unary-expression-12
fun4(copy clamp i + 1)
new Tb ttb(copy clamp i + 1)!
ttb := Tb(copy clamp i + 1)!
; @ c test-unary-expression-13
fun4(copy clamp! i + 1)
; @ c test-unary-expression-14
if-error fun4(copy clamp? i + 1)
    i := 12
; @ c test-unary-expression-15
i := wraparound i + 1
; @ c test-unary-expression-16
fun4(copy wraparound i + 1)
new Tb ttb(copy wraparound i + 1)!
ttb := Tb(copy wraparound i + 1)!
; @ ec test-unary-expression-e0
{45}
; @ ec test-unary-expression-e1
-[
; @ ec test-unary-expression-e2
+ 2
; @ ec test-unary-expression-e3
- (i := 2)
; @ ec test-unary-expression-e4
- (i > 4)
; @ ec test-unary-expression-e5
not i
; @ ec test-unary-expression-e6
i := i + clamp i
; @ ec test-unary-expression-e7
fun4(copy - clamp i)
; @ ec test-unary-expression-e8
i := clamp i
; @ ec test-unary-expression-e9
fun4(copy clamp i)
; @ ec test-unary-expression-e10
i := clamp? i + 1
; @ eg test-unary-expression-e11
func error()->(var Uint32 i)
    i := clamp! i + 1
; @ eg test-unary-expression-e12
func error()->(var Uint32 i)
    i := clamp? i + 1
; @ ec test-unary-expression-e13
i clamp+= clamp -1
; @ ec test-unary-expression-e14
fun5(copy i)->(var clamp j)
; @ ec test-unary-expression-e15
i := i + wraparound i
; @ ec test-unary-expression-e16
i := wraparound i
; @@ test-binary-expression
; @ c test-binary-expression-0
i := 23 + 54
; @ c test-binary-expression-1
i clamp+= (100 * 2) - 37
i clamp*= 3
; @ c test-binary-expression-2
i clamp-= 12 *
        13
; @ c test-binary-expression-3
b := 3 < 5 or 23 > 37
; @ c test-binary-expression-4
b := 3 <= 5 and 23 >= 37
; @ c test-binary-expression-5
b := i = 5 or i <> 37
; @ c test-binary-expression-6
b := 2 < i < 12 = -2 * i
; @ c test-binary-expression-7
t := tc
; @ c test-binary-expression-8
owner String? s
s := so
; @ c test-binary-expression-9
str := so
; @ c test-binary-expression-10
b := t is ta or tc is-not tb
; @ c test-binary-expression-11
c := '0' + 4
; @ c test-binary-expression-12
b := fun0 is-not fun1
; @ c test-binary-expression-13
b := b = b
; @ c test-binary-expression-14
owner Tc? otc
tb := otc!
; @ c test-binary-expression-15
owner Array?{Test} otarr
otarr := _
; @ c test-binary-expression-16
io := (60 div i!) + (60 mod i!)
; @ c test-binary-expression-17
i := i bor 8
; @ c test-binary-expression-18
i := 10 band i
; @ c test-binary-expression-19
var Int{4:20} i8(copy 4)
var Int{100000000000:200000000000} i64(copy 100000000000)
i := bnot i wraparound+ bnot i8 wraparound+ bnot i64
; @ c test-binary-expression-20
i := i xor 16
; @ c test-binary-expression-21
i := 2 shr i
; @ c test-binary-expression-22
i := i shl 1
; @ c test-binary-expression-23
i := wraparound bnot i + (10 band i)
; @ c test-binary-expression-24
var Int{1:100} x(copy 1)
io := (60 div x) + (600 mod x)
; @ c test-binary-expression-25
i := i clamp+ i
i := i clamp+ j
j := j clamp+ i
j := j clamp+ j
; @ c test-binary-expression-26
i := i clamp- i
i := i clamp- j
j := j clamp- i
j := j clamp- j
; @ c test-binary-expression-27
i := i clamp* i
i := i clamp* j
j := j clamp* i
j := j clamp* j
; @ c test-binary-expression-28
b := i >= i or i < j or j > j or bt <= j
; @ c test-binary-expression-29
var Int{10:100} x(copy 50)
var Int{1000} y
var Uint64 z
i := x wraparound+ 1000
i := y wraparound- 2000
z := z wraparound* 2
z := z wraparound+ j wraparound+ (x wraparound- z)
; @ c test-binary-expression-30
i wraparound+= i
i wraparound-= i
i wraparound*= i
; @ c test-binary-expression-31
var Sint64 x
var Uint64 y
i := wraparound x +! j
i := wraparound x -! j
i := wraparound x *! j
y := y +! 3
i := wraparound x -! 3
if-error x := x +? 3
    x := 0
; @ ec test-binary-expression-e0
345 @ 2
; @ ec test-binary-expression-e1
80 +(
; @ ec test-binary-expression-e2
1 + 2 * 3
; @ ec test-binary-expression-e3
1 < i or 2 < i and 3 < i
; @ ec test-binary-expression-e4
1 not 2
; @ ec test-binary-expression-e5
1 := 2
; @ ec test-binary-expression-e6
1 clamp+= 2
; @ ec test-binary-expression-e7
1 clamp-= 2
; @ ec test-binary-expression-e8
so := str
; @ ec test-binary-expression-e9
b := 1 or 2
; @ ec test-binary-expression-e10
b := t > 3
; @ ec test-binary-expression-e11
b := 1 > 4 > t
; @ ec test-binary-expression-e12
i := 3 + t
; @ ec test-binary-expression-e13
t clamp+= 3
; @ ec test-binary-expression-e14
i clamp-= b
; @ ec test-binary-expression-e15
b := 3 is t
; @ ec test-binary-expression-e16
user Array?{Char} ca
ca := arr!
; @ ec test-binary-expression-e17
owner Test? ot
ot := tb
; @ ec test-binary-expression-e18
b := b is b
; @ ec test-binary-expression-e19
b := t is t < 2
; @ ec test-binary-expression-e20
user Test? tu
t := tu
; @ ec test-binary-expression-e21
var Test tv
user Test tu(user tv)
tu := t
; @ ec test-binary-expression-e22
io := 60 div i
; @ ec test-binary-expression-e23
io := 60 mod i
; @ ec test-binary-expression-e24
io := 60 div 0
; @ ec test-binary-expression-e25
io := 60 mod 0
; @ ec test-binary-expression-e26
var Int{-10:10} x
i := bnot x
; @ ec test-binary-expression-e27
var Int{-10:10} x
i := x xor 1
; @ ec test-binary-expression-e28
var Int{-10:10} x
i := 2 bor x
; @ ec test-binary-expression-e29
var Int{-10:10} x
i := x band 3
; @ ec test-binary-expression-e30
var Int{-10:10} x
i := x shr 4
; @ ec test-binary-expression-e31
var Int{-10:10} x
i := 5 shl x
; @ ec test-binary-expression-e32
var Int{-10:10} x
i := x div 6
; @ ec test-binary-expression-e33
var Int{-10:10} x
i := 7 mod x
; @ ec test-binary-expression-e34
var Uint64 u64
b := j < u64
; @ ec test-binary-expression-e35
var Int{10} x
i := x wraparound+ 100
; @ ec test-binary-expression-e36
var Int{200:220} x(copy 210)
i := x wraparound- 100
; @ ec test-binary-expression-e37
var Uint8 x
i := x wraparound* 1
; @ ec test-binary-expression-e38
var Int{1:255} x
x wraparound+= 1
; @ ec test-binary-expression-e39
var Int{254} x
x wraparound-= 1
; @ ec test-binary-expression-e40
var Uint64 x
x := x +? j
; @ ec test-binary-expression-e41
var Uint64 x
if-error x := x +! j
    x := 0
; @ eg test-binary-expression-e42
func error(copy Sint32 j)
    var Uint64 x
    x := x +! j
; @ ec test-binary-expression-e43
i := wraparound i +! 3
; @ ec test-binary-expression-e44
i := wraparound i +? 3
; @@ test-swap-expression
; @ c test-swap-expression-0
new Test t1!
new Test t2!
t1 :=: t2
; @ c test-swap-expression-1
strong Test t1(strong to!)
strong Test t2(strong to!)
t1 :=: t2
; @ c test-swap-expression-2
new Tc t1(copy 1)!
new Tc t2(copy 2)!
t1 :=: t2
; @ c test-swap-expression-3
strong Tc t1(strong Tc(copy 1)!)
strong Tc t2(strong Tc(copy 2)!)
t1 :=: t2
; @ c test-swap-expression-4
new Array{4:Uint32} a1!
new Array{6:Uint32} a2!
a1 :=: a2
; @ c test-swap-expression-5
strong Array{Uint32} a1(strong Array{4:Uint32}()!)
strong Array{Uint32} a2(strong Array{6:Uint32}()!)
a1 :=: a2
; @ c test-swap-expression-6
new String{4} s1!
new String{6} s2!
s1 :=: s2
; @ c test-swap-expression-7
strong String s1(strong String{4}()!)
strong String s2(strong String{6}()!)
s1 :=: s2
; @ g test-swap-expression-8
struct MyStruct
    var Uint32 x
struct Test
    owner MyStruct f
    new(owner MyStruct f)
        self.f := f
func fun(owner Test t1, owner Test t2)
    t1.f :=: t2.f
; @ c test-swap-expression-9
user Test t1(user t!)
user Test t2(user t!)
t1 :=: t2
; @ c test-swap-expression-10
weak Test t1(weak to!)
weak Test t2(weak to!)
t1 :=: t2
; @ c test-swap-expression-11
i :=: io
; @ c test-swap-expression-12
d!.item :=: t
; @ ec test-swap-expression-e0
t :=: to
; @ ec test-swap-expression-e1
new Test t1!
t1 :=: t1
; @ ec test-swap-expression-e2
new String{8} nstr!
ostr :=: nstr
; @ ec test-swap-expression-e3
weak Array{Char} a(weak so!)
a :=: so![1:2]!
; @ ec test-swap-expression-e4
ta :=: tc
; @ ec test-swap-expression-e5
new Test t1!
strong Test t2(strong to!)
t1 :=: t2
; @ ec test-swap-expression-e6
new String{4} valid!
owner String invalid
valid :=: invalid
; @ ec test-swap-expression-e7
new String{4} valid!
owner String invalid
invalid :=: valid
; @@ test-question-expression
; @ c test-question-expression-0
b := ostr?
; @ c test-question-expression-1
b := not arr?
; @ c test-question-expression-2
b := t!.fun?
; @ c test-question-expression-3
b := to?
; @ c test-question-expression-4
b := fun7(weak _)->(weak t)?
; @ c test-question-expression-5
weak Test tt(weak t!)
b := tt?
; @ g test-question-expression-6
struct Test
    weak String? s
    func user meth()->(var Bool res)
        res := self.s?
; @ ec test-question-expression-e0
(i := 2)?
; @ ec test-question-expression-e1
i?
; @ ec test-question-expression-e2
var Test tt
if tt?
; @@ test-exclamation-expression
; @ c test-exclamation-expression-0
user String s(user ostr!)
; @ c test-exclamation-expression-1
user Test tt(user t!.t!)
; @ c test-exclamation-expression-2
user Test? tu
tu := fun7(weak _)->(weak t)!
; @ c test-exclamation-expression-3
i := tb!.num
; @ c test-exclamation-expression-4
weak Test tt(weak t!)
; @ c test-exclamation-expression-5
new String{str!.length()} s!
; @ ec test-exclamation-expression-e0
user String s(user str)
; @ ec test-exclamation-expression-e1
user Test? tt(user t)
; @ ec test-exclamation-expression-e2
new String{4} s!
s := ostr
; @ ec test-exclamation-expression-e3
weak String? s
fun1(copy 0, user s, owner _)
; @ ec test-exclamation-expression-e4
t.num
; @ ec test-exclamation-expression-e5
t.meth()
; @ ec test-exclamation-expression-e6
var Func?{()} fun
fun()
; @ ec test-exclamation-expression-e7
i := arr[3]!
; @ ec test-exclamation-expression-e8
for _ in str
; @ ec test-exclamation-expression-e9
weak String? s
raise! s
; @ ec test-exclamation-expression-e10
new String{str.length()} s!
; @ ec test-exclamation-expression-e11
so := ostr
; @ ec test-exclamation-expression-eo0
raise! str!!
; @ ec test-exclamation-expression-en0
var String{8} s
so := s!
; @ ec test-exclamation-expression-en1
io := (2!) + 3
; @ ec test-exclamation-expression-en2
so! := str
; @ ec test-exclamation-expression-en3
"text"!.clear()
; @ ec test-exclamation-expression-en4
var Func{(user Test? self)} fun(copy Test!.meth)
; @ ec test-exclamation-expression-en5
var Test tv
i := tv!.num
; @ eg test-exclamation-expression-en6
struct Base
    var Uint32 x
    func user fun()
struct Test(Base)
    func user fun()
        base!()
; @ ec test-exclamation-expression-en7
fun0!()
; @ eg test-exclamation-expression-en8
func fun(user String s)
    fun(user s!)
; @ ec test-exclamation-expression-en9
var Func{()} fun(copy fun0)
fun!()
; @ ec test-exclamation-expression-en10
if not b!
; @ ec test-exclamation-expression-en11
io := 2 + 3!
; @ eg test-exclamation-expression-en12
func fun()
mock fun()
    fun!.active := false
; @ ec test-exclamation-expression-en13
ut!.fun0()
; @ ec test-exclamation-expression-en14
if t!?
; @ ec test-exclamation-expression-en15
if b!
; @ ec test-exclamation-expression-en16
loop
    while b!
; @ ec test-exclamation-expression-en17
for _ in 3!
; @ ec test-exclamation-expression-en18
for _ in 3!:4
; @ ec test-exclamation-expression-en19
for _ in 3:4!
; @ ec test-exclamation-expression-en20
var String{4} s
for _ in s!
; @ ec test-exclamation-expression-en21
var Array{4:Uint32} a
for _ in a!
; @ ec test-exclamation-expression-en22
user String? s(user str!)
; @ eg test-exclamation-expression-en23
const Int CONST 12!
; @ ec test-exclamation-expression-en24
assert! b!
; @ ec test-exclamation-expression-en26
var Array{4:Uint32} a
i := a![2]!
; @ ec test-exclamation-expression-en27
var Array{4:Uint32} a
i := a[2!]!
; @ ec test-exclamation-expression-en28
var Array{4:Uint32} a
i := a[2:3!]!
; @ ec test-exclamation-expression-en29
var Ref r
r := ostr!
; @ ec test-exclamation-expression-en30
raise! "error"!
; @ ec test-exclamation-expression-en31
raise! str!
; @ ec test-exclamation-expression-en32
var String{23!} s
; @ ec test-exclamation-expression-en33
`beaf`!.clear()
; @@ test-int-range
; @ g test-int-range-0
struct Test
    var Uint32 int-def
    var Uint8 u8b
    var Uint16 u16b
    var Uint32 u32b
    var Uint64 u64b
    var Sint8 s8b
    var Sint16 s16b
    var Sint32 s32b
    var Sint64 s64b
    var Int{32} ru8
    var Int{5:1000} ru16
    var Int{1000000} ru32
    var Int{100000000000:200000000000} ru64
    var Int{-100:100} rs8
    var Int{-1:1000} rs16
    var Int{-2000000:-1000000} rs32
    var Int{-100000000000:100000000000} rs64
    new()
        self.ru16 := 5
        self.ru32 := 1000000
        self.rs32 := -1000000
        self.ru64 := 100000000000
        self.rs64 := -100000000000
        self.u8b := 0xff
        self.s8b := 0x7f
        self.s8b := -0x7f
        self.u16b := 0xffff
        self.s16b := 0x7fff
        self.s16b := -0x7fff
        self.u32b := 0xffffffff
        self.s32b := 0x7fffffff
        self.s32b := -0x7fffffff
        self.u64b := 0xffffffffffffffff
        self.s64b := 0x7fffffffffffffff
        self.s64b := -0x7fffffffffffffff
; @ c test-int-range-1
var Int{0:255} u8
var Int{0:65535} u16
var Int{0:4294967295} u32
var Int{0:18446744073709551615} u64
var Int{-128:127} s8
var Int{-32768:32767} s16
var Int{-2147483648:2147483647} s32
var Int{-9223372036854775808:9223372036854775807} s64
; @ g test-int-range-2
const Int MAX 10000
enum Nums
    MIN
var Int{Nums.MIN - 12:MAX * 2} s16
struct Test
    var Uint32 x
func fun(user Test t)->(var Uint32 x)
    x := wraparound fun(user t) + t.x
; @ c test-int-range-3
var Uint8 u8
var Sint16 s16(copy -1000)
var Uint32 u32(copy 100000)
var Uint16 u16
u16 := 1000
var Sint32 s32
s32 := 100000
s32 := -100000
i := 20 + -20
; @ ec test-int-range-e0
var Int{12:11} error
; @ ec test-int-range-e1
var Int{0:18446744073709551616} error
; @ ec test-int-range-e2
var Int{-1:9223372036854775808} error
; @ ec test-int-range-e3
var Int{-9223372036854775809:1} error
; @ ec test-int-range-e4
var Int{0:str} error
; @ ec test-int-range-e5
var Int{0:i} error
; @ ec test-int-range-e6
var Int{-100} error
; @ ec test-int-range-e7
i := j
; @ ec test-int-range-e8
j := i
; @ ec test-int-range-e9
var Uint64 x
x := wraparound x + 1
; @@ test-dynamic
; @ c test-dynamic-0
var Ta a
; @ c test-dynamic-1
user Ta? a
; @ c test-dynamic-2
owner Ta nta(owner Ta()!)
; @ c test-dynamic-3
new Ta a!
; @ c test-dynamic-4
user Ta? a(user ta!)
; @ c test-dynamic-5
user Ta? x
x := ta!
; @ c test-dynamic-6
ta := tb
; @ c test-dynamic-7
ta := tc
; @ c test-dynamic-8
ta := _
; @ c test-dynamic-9
strong Array?{Ta} aa
ta := aa![4]!
; @ c test-dynamic-10
strong Array?{Tc} ca
ta := ca![4]!
; @ c test-dynamic-11
ta!.dyn()
; @ c test-dynamic-12
tb!.dyn()
; @ c test-dynamic-13
tc!.dyn()
; @ c test-dynamic-14
tco := tc
tco!.dyn()
; @ c test-dynamic-15
fun7(weak tc)->(weak ta)
; @ g test-dynamic-16
class Test
    var Uint32 x
    func dynamic user meth()
func ! mock()->(weak Test? t)
    t!.meth()
; @ g test-dynamic-17
class Base
    var Uint32 x
    func dynamic user meth()
class Test(Base)
    func inst user fun()
        self.meth()
; @ c test-dynamic-18
fun7(weak _)
; @ eg test-dynamic-e0
class Test
    var Uint32 x
    func dynamic weak? meth()
func fun()
    weak Test? t
    t.meth()
; @@ test-function-object
; @ c test-function-object-0
var Func{()} fun
fun := fun0
fun()
; @ c test-function-object-1
var Func{(copy Uint32 x)->(var Uint32 y)} fun(copy fun5)
var Uint32 x
fun(copy 9)->(var x)
; @ c test-function-object-2
var Func{(user Test? self)} fun(copy Test.meth)
fun(user t!)
; @ c test-function-object-3
var Func?{()} fun
fun := _
b := fun?
fun!()
; @ c test-function-object-4
t!.fun := fun0
t!.fun!()
; @ c test-function-object-5
var Array{38:Func{()}} farr
new Array{12:Func{(copy Uint32 x)->(var Uint32 y)}} farr1!
new Array{12:Func{:()}} farr2!
user Array{Func{:()}} ufarr
farr[3] := fun0
farr[3]()
; @ c test-function-object-6
var Func{(copy Uint32 x,
        copy Uint32 y)} fun
; @ g test-function-object-7
func fun()
func mock()->(var Func{()} f)
    f := fun
    f()
; @ g test-function-object-8
func ! fun(copy Uint32 x, copy Uint32 y)
func mock(copy Func?{(copy Uint32 x,
        copy Uint32 y)} fi)->(var Func{:(copy Uint32 x,
        copy Uint32 y)} fo)
    mock(copy _)
    fo := fun
func afun(user Array{Func{(copy Uint32 x)->(var Uint32 y)}} in)->(
        owner Array?{Func{:()}} out)
struct Test
    var Func{(copy Uint32 x,
            copy Uint32 y)} fun
    var Array{4:Func{:(copy Uint32 x)->(var Uint32 y)}} afun
    func user meth(copy Func{:(copy Uint32 x,
            copy Uint32 y)} fi)->(var Func{:(copy Uint32 x,
            copy Uint32 y)} fo)
        fo := fun
; @ c test-function-object-9
var Func{:()} fun
fun := fune
fun()!
; @ ec test-function-object-e0
var Func error
; @ ec test-function-object-e1
var Array{3:Func} error
; @ ec test-function-object-e2
var Func{} error
; @ ec test-function-object-e3
var Func{() } error
; @ ec test-function-object-e4
var Func{()} fun(copy fun1)
; @ ec test-function-object-e5
var Func{()->(var Uint32 x)} fun
fun := fun0
; @ ec test-function-object-e6
var Func{()} fun
fun()
; @ ec test-function-object-e7
var Func{()} fun(copy fun0)
fun := _
; @ ec test-function-object-e8
var Func{()} fun(copy fun0)
if fun?
; @ ec test-function-object-e9
var Func{()} fun(copy fune)
; @ ec test-function-object-e10
var Func{:()} fun(copy fun0)
; @@ test-builtin
; @ c test-builtin-int0
var Uint64 u64
var Sint64 s64
u64.str(user ostr!)!
s64.str(user ostr!)!
; @ c test-builtin-bool0
b := true
; @ c test-builtin-bool1
b := false
; @ ec test-builtin-char0
c := EOF
; @ c test-builtin-array0
arr!.length()->(var i)
; @ c test-builtin-string0
ostr!.length()->(var i)
; @ c test-builtin-string1
ostr!.clear()
; @ c test-builtin-string2
ostr!.equal(user ostr!)->(var b)
; @ c test-builtin-string3
ostr!.get(copy i)->(var c)!
; @ c test-builtin-string4
ostr!.set(copy i, copy c)!
; @ c test-builtin-string5
ostr!.append(copy c)!
; @ c test-builtin-string6
var String{12} sv
sv.new(user ostr!)!
; @ c test-builtin-string7
ostr!.concat(user ostr!)!
; @ c test-builtin-string8
ostr!.concat-int(copy i)!
; @ c test-builtin-string9
ostr!.find(user ostr!)->(var i)
; @ c test-builtin-string10
ostr!.has(copy c)->(var b)
; @ c test-builtin-string11
String.set(user ostr!, copy 0, copy 'a')!
; @ c test-builtin-string12
ostr!.max-length()->(var i)
; @ c test-builtin-buffer0
buff!.length()->(var i)
; @ c test-builtin-buffer1
buff!.clear()
; @ c test-builtin-buffer2
buff!.equal(user buff!)->(var b)
; @ c test-builtin-buffer3
buff!.get(copy i)->(var bt)!
; @ c test-builtin-buffer4
buff!.set(copy i, copy bt)!
; @ c test-builtin-buffer5
buff!.append(copy bt)!
; @ c test-builtin-buffer6
var Buffer{12} bv
bv.new(user buff!)!
; @ c test-builtin-buffer7
buff!.concat(user buff!)!
; @ c test-builtin-buffer8
buff!.find(user buff!)->(var i)
; @ c test-builtin-buffer9
buff!.has(copy bt)->(var b)
; @ c test-builtin-buffer10
Buffer.set(user buff!, copy 0, copy bt)!
; @ c test-builtin-buffer11
buff!.max-length()->(var i)
; @ c test-builtin-file0
try
    s-var FileReadText f(user ostr)
    f.get()->(var c, var b)
    f.getline(user ostr)->(var b)
    var Sint64 x
    f.tell()->(var x)
    f.seek-set(copy x)
    f.seek-cur(copy x)
    f.seek-end(copy x)
    f.flush()
    f.close()
    var Data{FileReadText} df
    df.item := f
; @ c test-builtin-file1
try
    new FileReadBinary f(user ostr)
    f.get()->(var bt, var b)
    f.read(user buff)->(var i)
    var Sint64 x
    f.tell()->(var x)
    f.seek-set(copy x)
    f.seek-cur(copy x)
    f.seek-end(copy x)
    f.flush()
    f.close()
    var Data{FileReadBinary} df
    df.set(owner f)
; @ c test-builtin-file2
try
    owner FileWriteText f(owner FileWriteText(user ostr, copy false))
    f.put(copy c)
    f.write(user ostr)->(var i)
    var Sint64 x
    f.tell()->(var x)
    f.seek-set(copy x)
    f.seek-cur(copy x)
    f.seek-end(copy x)
    f.flush()
    f.close()
    var Data{FileWriteText} df
    df.set(owner f)
; @ c test-builtin-file3
try
    strong FileWriteBinary f(strong FileWriteBinary(user ostr, copy true))
    f.put(copy bt)
    f.write(user buff)->(var i)
    var Sint64 x
    f.tell()->(var x)
    f.seek-set(copy x)
    f.seek-cur(copy x)
    f.seek-end(copy x)
    f.flush()
    f.close()
    var Data{FileWriteBinary} df
    df.item := f
; @ c test-builtin-file4
try
    s-var FileReadWriteText f(user ostr, copy true, copy true)
    f.get()->(var c, var b)
    f.getline(user ostr)->(var b)
    f.put(copy c)
    f.write(user ostr)->(var i)
    var Sint64 x
    f.tell()->(var x)
    f.seek-set(copy x)
    f.seek-cur(copy x)
    f.seek-end(copy x)
    f.flush()
    f.close()
    var Data{FileReadWriteText} df
    df.item := f
; @ c test-builtin-file5
try
    new FileReadWriteBinary f(user ostr, copy false, copy false)
    f.get()->(var bt, var b)
    f.read(user buff)->(var i)
    f.put(copy bt)
    f.write(user buff)->(var i)
    var Sint64 x
    f.tell()->(var x)
    f.seek-set(copy x)
    f.seek-cur(copy x)
    f.seek-end(copy x)
    f.flush()
    f.close()
    var Data{FileReadWriteBinary} df
    df.set(owner f)
; @ g test-builtin-file6
struct Data{Generic}
    weak Generic? item
    func user? set(owner Generic? item)
func ! fun(
        user File f,
        user FileReadText frt,
        user FileReadBinary frb,
        user FileWriteText fwt,
        user FileWriteBinary fwb,
        user FileReadWriteText frwt,
        user FileReadWriteBinary frwb)
    f := frt
    f := frb
    f := fwt
    f := fwb
    f := frwt
    f := frwb
    frt := frwt
    frb := frwb
    fwt := frwt
    fwb := frwb
    fun(
            user frt,
            user frwt,
            user frwb,
            user frwt,
            user frwb,
            user frwt,
            user frwb)!
    var Data{File} df
    owner File fo(owner FileWriteBinary(user "name", copy false)!)
    var Sint64 i
    fo.tell()->(var i)!
    fo.seek-set(copy i)!
    fo.seek-cur(copy i)!
    fo.seek-end(copy i)!
    fo.flush()!
    fo.close()!
    df.set(owner fo)
; @ c test-builtin-sys0
user Array{String} argv(user sys.argv)
; @ c test-builtin-sys1
sys.print(user ostr!)!
; @ c test-builtin-sys2
sys.println(user ostr!)!
; @ c test-builtin-sys3
sys.getchar()->(var c, var b)!
; @ c test-builtin-sys4
sys.getline(user ostr!)->(var b)!
; @ c test-builtin-sys5
sys.exit(copy j)!
; @ c test-builtin-sys6
sys.system(user ostr!)->(var j)!
; @ c test-builtin-sys7
sys.getenv(user ostr!, user ostr!)->(var b)!
; @ c test-builtin-sys8
sys.stdin.get()->(var c, var b)!
; @ c test-builtin-sys9
sys.stdout.put(copy c)!
; @ c test-builtin-sys10
sys.stderr.put(copy c)!
; @ ec test-builtin-file-e0
var FileReadText error
; @ ec test-builtin-file-e1
new FileReadText error!
; @ ec test-builtin-file-e2
FileReadText()
; @@ test-general
; @ g test-general-0
owner String? str
; @ g test-general-1


    #

var Uint32 x
; @ g test-general-2
; comment

var Uint32 x
; @ g test-general-3
~~~ documentation ~~~

var Uint32 x
; @ g test-general-4
[; multi #
 line #
 comment ;]

var Uint32 x
; @ g test-general-5
~~~ multi #
 line    #
 documentation
 confused by ~ or ~~ or ; or ~~ ~ ?
~~~

var Uint32 x
; @ g test-general-6
var String{12} s
s-var String{12} svs!
owner String cs(owner String{12}(user "global text")!)
owner Buffer cb(owner Buffer{12}(user `fade00beaf`)!)
strong String us(strong String{12}(user s)!)
weak String gs(weak us)
main!
    var Uint32 x(copy 6)
    x := 7
    new String{12} ls!
    ls :=: cs
; @ tg test-general-7
var String{12} s
func fun()
    s.clear()
; @-
module second
test dummy()
; @ tg test-general-8
func fun()
    fun()
main
    fun()
; @-
module test
test test-fun()
; @ eg test-general-e0
error #
; @ ec test-general-e1
1 + 2
; @ ec test-general-e2
return
i := 3
; @ ec test-general-e3
raise!
i := 3
; @ eg test-general-e4
[; comment ;]?
; @ eg test-general-e5
main(
; @ eg test-general-e6
    struct Test
; @ eg test-general-e7
func f()
    x :=
        y
; @ feg test-general-e8
var Uint32 x
; @ eg test-general-e9
var Uint32 name
var Uint32 name
; @ eg test-general-e10
func name()
var Uint32 name
; @ eg test-general-e11
user Error? error
; @ eg test-general-e12
var Uint32 x(copy error)
; @ eg test-general-e13
[ ; error
; @ eg test-general-e14
user String? error
; @ eg test-general-e15
temp String? error
; @ eg test-general-e16
weak String error
; @ eg test-general-e17
owner String error(owner String{12}()!)
func fun()->(owner String? s)
    s := error
main!
; @ eg test-general-e18
owner String error(owner String{12}()!)
func fun(owner String s)
main!
    fun(owner error)
; @@ test-struct
; @ g test-struct-0
struct Test
    var Uint32 x
; @ g test-struct-1
struct Test
    var Uint32 x
; @ g test-struct-2
struct Test1
    var Uint32 x
struct Test2
    var Uint32 x


struct Test3
    var Uint32 x
; @ g test-struct-3
struct Test2(Test1)
    var Uint32 y
struct Test1
    var Uint32 x
; @ g test-struct-4
struct Test
    owner Test? to
    strong Test? ts
    weak Test? tw
; @ eg test-struct-e0
struct(
; @ eg test-struct-e1
struct error
; @ eg test-struct-e2
struct ERror
; @ eg test-struct-e3
struct Error-name
; @ eg test-struct-e4
struct E
; @ eg test-struct-e5
struct Int
; @ eg test-struct-e6
struct Test
struct Test
; @ eg test-struct-e7
struct Test(Base
; @ eg test-struct-e8
struct Test
    error #
; @ feg test-struct-e9
struct Test
; @ eg test-struct-e10
struct Error
; @ eg test-struct-e11
struct Error
    new #
; @ eg test-struct-e12
struct Error
    new()
    new()
; @ eg test-struct-e13
struct Error
    var Uint32 x
    new()->(var Uint32 x)
; @ eg test-struct-e14
struct Error
    func temp new()
; @ eg test-struct-e15
struct Error(Error)
    var Uint32 x
; @ eg test-struct-e16
struct Aerror(Berror)
    var Uint32 x
struct Berror(Aerror)
    var Uint32 x
; @@ test-class
; @ g test-class-0
class Base
    var Uint32 x
    owner Base? b
    func inst user stat()
    func dynamic user dyn0()
    func dynamic user ! dyn1()
    func dynamic user dyn2()
class Mid(Base)
    var Uint32 y
    owner Mid? m
    func dynamic user dyn0()
    func dynamic user dyn3()
    func dynamic user ! dyn4()
class Top(Mid)
    var Uint32 z
    owner Top? t
    func dynamic user dyn0()
        base()
    func dynamic user ! dyn1()
        base()!
    func dynamic user dyn3()
        base()
    func dynamic user dyn5()
        base.dyn0()
; @ g test-class-1
class Test
    owner Test? to
    strong Test? ts
    weak Test? tw
    func dynamic user fun()
; @ eg test-class-e0
class(
; @ eg test-class-e1
class Error
    var Uint32 x
; @ eg test-class-e2
class Error
    func error f()
; @ eg test-class-e3
struct Base
    var Uint32 x
    func user meth()
class Error(Base)
    func dynamic user meth()
; @ eg test-class-e4
class Base
    var Uint32 x
    func dynamic user meth()
class Error(Base)
    func inst user meth()
; @ eg test-class-e5
class Base
    var Uint32 x
    func dynamic user meth()
class Error(Base)
    func dynamic user meth(copy Uint32 x)
; @ eg test-class-e6
class Base
    var Uint32 x
    func dynamic user meth()
class Error(Base)
    func dynamic user ! meth()
; @@ test-function
; @ g test-function-0
func name()
; @ g test-function-1
func name(user String self, user String text, copy Uint32 num)
; @ g test-function-2
func name()->(owner String? text, var Uint32 num)
; @ g test-function-3
func name(copy Char param)->(owner String? out)
; @ g test-function-4
func name(user Array{Uint32} array)
; @ g test-function-5
func some()
func name(copy Func{(copy Uint32 x)->(var Uint32 y)} fun)->(var Func{()} joy)
    joy := some
; @ g test-function-6
func name()
    var Uint32 x
; @ g test-function-7
func ! name(user String self, copy Uint32 px, user Array{Char} pu, owner String po)->(
        strong String? oself, var Uint32 ox, weak String? ou, owner String? oo)
    var Uint32 x
    user String? u
    user Buffer? b
    owner String? o
    var String{12} v
    new String{12} n!
    o := String{12}()!
    u := "constant string"
    b := `beef`
    pu := po[2:6]!
; @ g test-function-8
struct Struct
    owner Struct? s
    owner Array?{Struct} as
    owner Array?{String} astr
class Class
    owner Class? c
    owner Array?{Class} ac
    func dynamic user meth()
func name(
        owner Struct ps,
        owner Class pc,
        owner Array{Struct} pas,
        owner Array{Class} pac)
    owner Struct? s
    owner Class? c
    owner Array?{Struct} as
    owner Array?{Class} ac
    owner Array?{Uint32} ai
    owner Array?{String} astr
; @ g test-function-9
class Test
    var Uint32 x
    func dynamic user meth()
func name()->(owner Test? t)
    t := _
; @ g test-function-10
func name(user Array{Array{String}} ai)->(owner Array?{Array{Uint32}} ao)
; @ g test-function-11
func ! name()->(owner String so)
    so := String{12}()!
; @ g test-function-m0
main
    var Uint32 x
; @ g test-function-m1
main!
    owner String? s
    s!.clear()
; @ eg test-function-me0
main
    owner String? s
    s!.clear()
; @ eg test-function-e0
func(
; @ eg test-function-e1
func name
; @ eg test-function-e2
func Error()
; @ eg test-function-e3
func error_name()
; @ eg test-function-e4
func name()
func name()
; @ eg test-function-e5
var Uint32 name
func name()
; @ eg test-function-e6
func name( )
; @ eg test-function-e7
func name(user)
; @ eg test-function-e8
func name(user String
; @ eg test-function-e9
func name(error Uint32 x)
; @ eg test-function-e10
func name(user String str,user Uint32 x)
; @ eg test-function-e11
func name()-()
; @ feg test-function-e12
func name()
; @ eg test-function-e13
func name()
        var Uint32 x
; @ eg test-function-e14
func name(user Uint32 x)
; @ eg test-function-e15
func name()->(copy Uint32 x)
; @ eg test-function-e16
func name(copy String s)
; @ eg test-function-e17
func name(user Array error)
; @ eg test-function-e18
func name(copy Func error)
; @ eg test-function-e20
func name(
    copy Uint32 x)
; @ eg test-function-e21
func Type.Error.name()
; @ eg test-function-e22
func module.error.name()
; @ eg test-function-e23
func name(copy Uint32 error, copy Uint32 error)
; @ eg test-function-e24
func name(copy Uint32 error)->(var Uint32 error)
; @ eg test-function-e25
var Uint32 error
func name(copy Uint32 error)
; @ eg test-function-e26
func error()
func name(copy Uint32 error)
; @ eg test-function-e27
func error(copy Uint32 error)
; @ eg test-function-e28
func name(copy Uint32 Error)
; @ eg test-function-e29
func fun(weak String s)
    s!.clear()
; @ eg test-function-e30
func fun()
    raise!
; @ eg test-function-e31
func fun()
    assert! 1 = 2
; @ eg test-function-e32
func fun()
    assert-error! 1 = 2
; @ eg test-function-e33
func error()->()
; @@ test-members
; @ g test-members-0
struct Test
    var Uint32 x
    weak String? str
; @ g test-members-1
struct Test
    var Uint32 x
    func user name()
        self.x := 2
; @ g test-members-2
struct Test
    var Uint32 x
    func user name()
        var Uint32 x
        x := self.x
; @ g test-members-3
struct Test
    ; comment
    var Uint32 x
; @ g test-members-4
struct Test
    ~~~ documemtation ~~~
    var Uint32 x
; @ g test-members-5
struct Test
    [; multi #
    line #
    comment ;]
    var Uint32 x
; @ g test-members-6
struct Test
    ~~~ multi #
    line #
    documemtation
    ~~~
    var Uint32 x
; @ g test-members-7
var Uint32 name
func fun()
struct Test1
    var Uint32 name
    func user fun()
struct Test2
    var Uint32 fun
    func user name()
; @ g test-members-8
struct Test
    var Uint32 x
    func user fun()
        if self.x > 3
            self.x := 3
        loop
            for n in 4
                self.x := n
            while self.x < 30
; @ g test-members-9
struct Test
    var Uint32 x
    func user fun() _
func Test.fun()
    self.x := 3
; @ g test-members-10
func Test.fun(user String s)->(var Uint32 x)
    s.length()->(var x)
struct Test
    var Uint32 x
    func user fun(user String s)->(var Uint32 x) _
; @ g test-members-11
struct Test
    var Uint32 x
    new(copy Uint32 x) _
func Test.new(copy Uint32 x)
    self.x := x
; @ eg test-members-e0
struct Test
    var Uint32 name
    var Uint32 name
; @ eg test-members-e1
struct Test
    func user name()
    var Uint32 name
; @ eg test-members-e2
struct Test
    func user name()
    func user name()
; @ eg test-members-e3
struct Test
    var Uint32 name
    func user name()
; @ eg test-members-e4
struct Test
    var Uint32 x
    func user meth()
        owner Test? error
        error := self
; @ eg test-members-e5
struct Test
    var Uint32 x
    func user name() #
; @ eg test-members-e6
struct Test
    var Uint32 x
    func user error.name()
; @ eg test-members-e7
struct Test
    var Uint32 x
    func user fun()
func Test.fun()
; @ eg test-members-e8
func Test.fun()
struct Test
    var Uint32 x
    func user fun() _
func Test.fun()
; @ eg test-members-e9
struct Test
    var Uint32 x
    func user fun()
        self..x := 3
; @ ec test-members-e10
Test.num
; @ eg test-members-e11
struct Test
    var Uint32 x
    func error()
; @ eg test-members-e12
struct Test
    var Uint32 x
    func error?()
; @ eg test-members-e13
struct Test
    var Uint32 x
    func user fun()->(var Uint32 x) _
func Test.fun()
; @ eg test-members-e14
struct Test
    var Uint32 x
    func user ! fun() _
func Test.fun()
; @@ test-return
; @ g test-return-0
func name()
    return
; @ g test-return-1
func ! name()
    raise!
; @ g test-return-2
func ! name()
    raise! "some error"
; @ g test-return-3
func ! name(user Array{String} arr)
    raise! arr[3]!
; @ c test-return-4
weak String? s
raise! s!
; @ ec test-return-e0
return()
; @ ec test-return-e1
raise!()
; @ ec test-return-e2
raise! 2
; @ ec test-return-e3
raise! _
; @ ec test-return-e4
raise
; @@ test-code-variables
; @ c test-code-variables-0
var Uint32 x
; @ c test-code-variables-1
user String? s
; @ c test-code-variables-2
owner Array?{Uint32} a
; @ c test-code-variables-3
user Test? tt
; @ c test-code-variables-4
var String{12} s
; @ c test-code-variables-5
var Array{12:Uint32} a
; @ c test-code-variables-6
var Array{12:Test} a
; @ c test-code-variables-7
var Array{12:String{7}} sa
; @ c test-code-variables-8
new String{12} s!
so := s!
; @ c test-code-variables-9
var Array{12:Ta} a
; @ c test-code-variables-10
new Array{12:Uint32} a!
; @ c test-code-variables-11
new Array{12:String{7}} sa!
; @ c test-code-variables-12
var Array{3:Array{4:String{5}}} aa
; @ c test-code-variables-13
new Array{3:Array{4:String{5}}} aa!
; @ g test-code-variables-14
func ! fun()
    var String{4} sv
    if 1 > 2
        user Array{Char} su(user sv[1:2]!)
; @ ec test-code-variables-e0
var Int
; @ ec test-code-variables-e1
var Uint32 Error
; @ ec test-code-variables-e2
var Uint32 errorName
; @ ec test-code-variables-e3
var Uint32 name
var Uint32 name
; @ ec test-code-variables-e4
var Uint32 name
loop
    var Uint32 x
    loop
        var Uint32 name
; @ eg test-code-variables-e5
var Uint32 name
func mock()
    var Uint32 name
; @ eg test-code-variables-e6
func name()
func mock()
    var Uint32 name
; @ eg test-code-variables-e7
struct Test
    var Uint32 x(1)
; @ ec test-code-variables-e8
new
; @ ec test-code-variables-e9
var Array{i:Uint32} error
; @ ec test-code-variables-e10
var Uint32 error--name
; @ ec test-code-variables-e11
var Uint32 x #
; @ ec test-code-variables-e12
new Array{-2:Uint32} a!
; @@ test-initialize
; @ c test-initialize-0
tb := Tb(copy i)!
; @ c test-initialize-1
str := String{arr![0]}()!
buff := Buffer{arr![0]}()!
; @ c test-initialize-2
owner Array{Uint32} a(owner Array{arr![0]:Uint32}()!)
; @ c test-initialize-3
owner Array{Test} a(owner Array{arr![0]:Test}()!)
; @ c test-initialize-4
owner Array{String} sa(owner Array{arr![0]:String{arr![1]!}}()!)
owner Array{Buffer} ba(owner Array{arr![0]:Buffer{arr![1]!}}()!)
; @ c test-initialize-5
var Uint32 x(copy arr![0])
; @ c test-initialize-6
user String? s(user ostr)
user Buffer? bf(user buff)
; @ c test-initialize-7
var String{12} s(user "some string")!
var Buffer{12} bf(user `fade00beaf`)!
; @ c test-initialize-8
new String{i} s(user ostr!)!
new Buffer{i} bf(user buff!)!
; @ c test-initialize-9
user Test? tt(user tc!)
; @ c test-initialize-10
var Tc tt(copy 3)!
; @ c test-initialize-11
new Tc tt(copy 3)!
; @ c test-initialize-12
tb := Tc(copy 3)!
; @ c test-initialize-13
user Tb? tt(user tb)
; @ c test-initialize-14
owner Ta? ota(owner tb)
; @ c test-initialize-15
owner Array{Array{String}} sa(owner Array{arr![0]:Array{arr![1]!:String{arr![2]!}}}()!)
owner Array{Array{Buffer}} ba(owner Array{arr![0]:Array{arr![1]!:Buffer{arr![2]!}}}()!)
; @ g test-initialize-16
struct MyStruct
    var Uint32 x
func get()->(owner MyStruct? a)
    owner MyStruct? b(owner get())
; @ c test-initialize-17
owner Test? ot(owner to)
strong Test? st(strong ot!)
; @ c test-initialize-18
s-var Tc tt(copy 3)!
; @ c test-initialize-19
new Test t1!
s-var Test t2!
; @ g test-initialize-20
struct Test
    var Uint32 x
    new(copy Uint32 x)
func fun()
    var Test t(copy 3)
; @ g test-initialize-21
struct Base
    var Uint32 x
    new()
        self.x := 2
struct Test(Base)
    var Uint32 y
    new()
        base()
        self.y := 3
; @ ec test-initialize-e0
Uint32()
; @ ec test-initialize-e1
var String s
; @ ec test-initialize-e2
var Array{4:String} sa
; @ ec test-initialize-e3
new String s!
; @ ec test-initialize-e4
String()
; @ ec test-initialize-e5
user Array a
; @ ec test-initialize-e6
new Array a!
; @ ec test-initialize-e7
Array()
; @ ec test-initialize-e8
var Array{23} a
; @ eg test-initialize-e9
struct Test{Generic}
    owner Array{Generic} arr
; @ ec test-initialize-e10
var Array{1
; @ ec test-initialize-e11
var String{12
; @ ec test-initialize-e12
var Array{error:Uint32} a
; @ ec test-initialize-e13
var Array{"12":Uint32} a
; @ ec test-initialize-e14
user Uint32 x
; @ ec test-initialize-e15
new Uint32 x!
; @ ec test-initialize-e16
var Array{4:Uint32} a(copy 1)
; @ ec test-initialize-e17
var Bool x(var 1)
; @ ec test-initialize-e18
var Uint32 x(var 1, var 2)
; @ eg test-initialize-e19
struct Test
    var Uint32 x
func mock()
    Test(copy 1)
; @ ec test-initialize-e20
var Uint32 x(user 3)
; @ ec test-initialize-e21
owner String? s(user so)
; @ ec test-initialize-e22
owner String? s(owner str)
; @ ec test-initialize-e23
var Array{1:Uint32:Uint32} a
; @ ec test-initialize-e24
owner Test? ot(owner tb)
; @ ec test-initialize-e25
user String s
s.clear()
; @ ec test-initialize-e26
user String s(user _)
; @ ec test-initialize-e27
user String s(user str)
; @ ec test-initialize-e28
i := error
var Uint32 error
; @ ec test-initialize-e29
var Uint32 error(copy error)
; @ ec test-initialize-e30
error := 3
var Uint32 error
; @ ec test-initialize-e31
if b
    var Uint32 error
i := error
; @ ec test-initialize-e32
new Test? a!
; @ ec test-initialize-e33
to := Test?()
; @ ec test-initialize-e34
to := Test()
; @ ec test-initialize-e35
var Tb tt(copy 3)
; @ ec test-initialize-e36
user String s!
; @ eg test-initialize-e37
user String s!
; @ eg test-initialize-e38
struct Test
    weak String s!
; @ ec test-initialize-e39
arr := Buffer{-2}()!
; @ ec test-initialize-e40
var Int{10:20} x
i := x
; @@ test-comment
; @ c test-comment-0
; comment

var Uint32 x
; @ c test-comment-1
~~~ documemtation ~~~

var Uint32 x
; @ c test-comment-2
[; multi #
line #
comment ;]

var Uint32 x
; @ c test-comment-3
~~~ multi #
line #
documemtation
~~~

var Uint32 x
; @@ test-block
; @ c test-block-0
block
    new Test tt!
    i := 1
; @ c test-block-1
block
    return
; @ c test-block-2
block
    var Uint32 n
block
    var Uint32 n
; @ ec test-block-e0
block i
; @ ec test-block-e1
block
    break
; @ ec test-block-e2
block
    while b
; @ ec test-block-e3
block
    new Test tt!
tt.meth()
; @ ec test-block-e4
user Test tt
block
    var Test tvar
    tt := tvar
tt.meth()
; @@ test-if-else
; @ c test-if-else-0
if t!.num > 3
    i := 2
; @ c test-if-else-1
if i > 3
    i := 2
else
    i := 1
; @ c test-if-else-2
if i > 3
    i := 3
else-if t!.num > 2
    i := 2
else-if t!.num > 1
    i := 1
else
    i := 1
; @ c test-if-else-3
if b
    return
i := 3
; @ c test-if-else-4
if b and
        b
    i := 1
; @ c test-if-else-5
if b
    var String{4} sa
    if b
        var String{4} sb
    else-if b
        var String{4} sc
    else
        var String{4} sd
else-if b
    var String{4} se
else
    var String{4} sf
; @ ec test-if-else-e0
if 3
; @ ec test-if-else-e1
if b
    error
; @ ec test-if-else-e2
if b
    i := 0
else
    error
; @ ec test-if-else-e3
if b
    i := 0
else-if b
    error
; @ ec test-if-else-e4
if b
    return
    i := 3
; @ ec test-if-else-e5
if()
; @ ec test-if-else-e6
else
; @ ec test-if-else-e7
if false
    ; ...
else #
; @ ec test-if-else-e8
else-if b
; @ ec test-if-else-e9
if false
    ; ...
else-if()
; @ feg test-if-else-e10
func error()
    if b
; @@ test-loop
; @ c test-loop-0
loop
    var Uint32 x
    while b
; @ c test-loop-1
loop
    break
; @ c test-loop-2
loop
    while t!.num > 3
; @ c test-loop-3
loop
    continue
    while b
; @ c test-loop-4
loop
    if true
        while false
; @ c test-loop-5
loop
    var String{4} sa
    while b
    break
    continue
    if b
        return
    loop
        var String{4} sb
        while b
        break
        continue
        if b
            return
        loop
            var String{4} sc
            while b
            break
            continue
            if b
                return
; @ c test-loop-6
loop! 1024
    while b
; @ c test-loop-7
try
    loop ostr.length() + 2
        while b
; @ c test-loop-8
loop-infinite
    i := 1
; @ c test-loop-9
loop
    loop
        loop
            return
; @ ec test-loop-e0
loop!(
; @ ec test-loop-e1
while true
; @ ec test-loop-e2
continue
; @ ec test-loop-e3
loop
    while 2
; @ ec test-loop-e4
loop
    error
; @ ec test-loop-e6
loop
    while i := 3
; @ ec test-loop-e7
loop
    while
; @ ec test-loop-e8
loop
    continue error
; @ ec test-loop-e9
break
; @ ec test-loop-e10
loop
    break error
; @ ec test-loop-e11
loop
    i := 1
; @ ec test-loop-e12
loop
    loop
        break
; @ ec test-loop-e13
try
    loop! 64
        while b
; @@ test-for-loop
; @ c test-for-loop-0
for n in 5
    i := n
; @ c test-for-loop-1
for n in t!.num:ostr!.length() + 2
    i := wraparound n
; @ c test-for-loop-2
for ch in ostr!
    c := ch
for y in buff!
    bt := y
; @ c test-for-loop-3
for n in arr!
    i := n
; @ c test-for-loop-4
for s in sarr!
    s.clear()
for bf in barr!
    bf.clear()
; @ c test-for-loop-5
var Uint32 n
for n in 5
    i := n
; @ c test-for-loop-6
for n in 5
    i := n
for n in 7
    i := n
; @ c test-for-loop-7
for n in 1 +
        2
    i := n
; @ c test-for-loop-8
for n in 6
    var String{4} sa
    break
    continue
    if b
        return
    for ch in ostr!
        var String{4} sb
        break
        continue
        if b
            return
; @ c test-for-loop-9
user String s(user "text")
for ch in s
    c := ch
user Buffer bf(user `beaf`)
for y in bf
    bt := y
; @ c test-for-loop-10
var Array{3:String{4}} sa
for s in sa
    s.clear()
var Array{3:Buffer{4}} ba
for bf in ba
    bf.clear()
; @ c test-for-loop-11
for _ in 2:6
    i := 1
; @ c test-for-loop-12
for _ in ostr!
    i := 1
for _ in buff!
    i := 1
; @ c test-for-loop-13
for _ in ostr!.length():2
    i := 1
; @ c test-for-loop-14
repeat i - 4
    i := 1
; @ ec test-for-loop-e0
for(
; @ ec test-for-loop-e1
for n
; @ ec test-for-loop-e2
for n error
; @ ec test-for-loop-e3
for n in fun0()
; @ ec test-for-loop-e4
for n in str:8
; @ ec test-for-loop-e5
for n in 5
    error
; @ ec test-for-loop-e6
var Uint32 n
for n in arr!
    i := n
for n in sarr!
; @ ec test-for-loop-e7
for n in 7
    i := 1
var Uint32 n
; @@ test-testing
; @ c test-testing-a0
assert! t!.num = 2
; @ c test-testing-a1
assert-error! t.num
; @ c test-testing-a2
assert-error! fune()
; @ c test-testing-a3
assert-error! t.num, "expected error"
; @ c test-testing-a4
assert-error! fune(), "expected error in the function"
; @ c test-testing-a5
assert-error! t.num,
        "expected error in new line"
; @ c test-testing-a6
if b
    var String{4} s
    assert! b
    assert-error! s[i:2]
    repeat 3
        assert-error! s[i:2]
; @ g test-testing-m0
func ! fun()
    fun()!
mock ! fun()
    raise!
; @ g test-testing-m1
mock fun()
func fun()
    fun()
; @ g test-testing-m2
mock Test.meth(copy Uint32 x)
struct Test
    var Uint32 x
    func user meth(copy Uint32 x)
        self.meth(copy x)
; @ g test-testing-m3
mock Test.meth(copy Uint32 x)
class Test
    var Uint32 x
    func dynamic user meth(copy Uint32 x)
        self.meth(copy x)
; @ g test-testing-m4
func fun(copy Uint32 x)->(var Uint32 y)
mock fun(copy Uint32 x)->(var Uint32 y)
    fun.mocked(copy x)->(var y)
    fun.active := false
    fun(copy x)->(var y)
    fun.active := true
; @ g test-testing-m5
struct Test
    var Uint32 x
    func user meth(copy Uint32 x)->(var Uint32 y)
        self.meth(copy x)->(var y)
mock Test.meth(copy Uint32 x)->(var Uint32 y)
    self.meth.mocked(copy x)->(var y)
    Test.meth.mocked(user self, copy x)->(var y)
    self.meth.active := false
    Test.meth(user self, copy x)->(var y)
    Test.meth.active := true
; @ g test-testing-m6
class Test
    var Uint32 x
    func dynamic user meth(copy Uint32 x)->(var Uint32 y)
        self.meth(copy x)->(var y)
mock Test.meth(copy Uint32 x)->(var Uint32 y)
    Test.meth.mocked(user self, copy x)->(var y)
    Test.meth.active := false
    Test.meth(user self, copy x)->(var y)
    Test.meth.active := true
; @ g test-testing-m7
func ! fun()
    sys.print(user "mock print")!
    sys.print.mocked(user "really print")!
    sys.print.active := false
    sys.print.active := true
mock ! sys.print(user Array{Char} text)
; @ g test-testing-m8
struct Test
    var Uint32 x
    new(copy Uint32 x)
mock Test.new(copy Uint32 x)
func fun()
    var Test t(copy 2)
; @ tg test-testing-t0
func fun0()
    var Uint32 x(copy 4)
    x := 1
    var Uint32 y(copy 5)
    y := x
    if y > 3
        y := 3
    else-if y < 0
        y := 0
    else
        y := 1
    try
        x := 0
        sys.print(user "text")
        y := 0
    catch
        x := 1
        x := 2
    if x > 3
        return
    else
        x := 3
    loop
        while x > 1
        if x = 5
            continue
    for n in 3
        x := y
; @-
module ut
func fun1()
    fun0()
test fun2()
    fun1()
; @ tg test-testing-t1
func fun()
    var Uint32 x
main
    fun()
; @-
module second
test fun0()
test fun1()
; @ g test-testing-mg0
mock Test.delete()
    var Ref? r(copy self)
struct Test
    weak String? s
; @ g test-testing-mg1
mock delete()
    var Ref? r(copy self)
main
; @ g test-testing-mg2
mock new()->(var Bool allocate-success)
    allocate-success := false
main
; @ c test-testing-r0
var Ref r
; @ c test-testing-r1
var Ref r
r := ostr
; @ c test-testing-r2
var Ref? r
r := _
; @ c test-testing-r3
var Ref r(copy ostr)
; @ c test-testing-r4
var Ref r
assert! r is r
; @ ec test-testing-e0
assert! 3
; @ ec test-testing-e1
assert! error
; @ ec test-testing-e2
assert-error! error
; @ eg test-testing-e3
test fun(copy Uint32 x)
; @ eg test-testing-e4
test fun()->(copy Uint32 x)
; @ eg test-testing-e5
mock error()
; @ eg test-testing-e6
mock Error.fun()
; @ eg test-testing-e7
struct Test
    var Uint32 x
mock Test.error()
; @ eg test-testing-e8
mock fun(owner String s)
func fun(user String s)
; @ eg test-testing-e9
mock fun(user Uint32 s)
func fun(user String s)
; @ eg test-testing-e10
mock fun(user Array{Char} a)
func fun(user Array{Uint32} a)
; @ ec test-testing-e11
assert #
; @ ec test-testing-e12
assert-error #
; @ eg test-testing-e13
mock()
; @ eg test-testing-e14
func fun()
mock fun()
mock fun()
; @ eg test-testing-e15
struct Test
    var Uint32 x
    func user fun()
mock Test.fun()
mock Test.fun()
; @ eg test-testing-e16
mock delete()
mock delete()
; @ eg test-testing-e17
struct Test
    var Uint32 x
mock Test.delete()
mock Test.delete()
; @ ec test-testing-e18
assert-error! t.num , "error"
; @ ec test-testing-e19
assert-error! t.num,"error"
; @ ec test-testing-e20
assert-error! t.num,  "error"
; @ ec test-testing-e21
assert-error! t.num, error
; @ eg test-testing-e22
mock new()->(var Bool res)
mock new()->(var Bool res)
; @ eg test-testing-e23
mock new()->(var Uint32 x)
; @ eg test-testing-e24
mock new()
; @ eg test-testing-e25
mock new(copy Uint32 x)->(var Bool res)
; @ eg test-testing-e26
mock new()->(var Bool res, var Uint32 x)
; @ eg test-testing-e27
mock delete(copy Uint32 x)
; @ eg test-testing-e28
mock delete()->(copy Uint32 x)
; @ eg test-testing-e29
func fun()
mock fun()
    fun.error
; @ eg test-testing-e30
class Test
    var Uint32 x
    func dynamic user meth()
mock Test.meth()
    self.meth.mocked()
; @ eg test-testing-e31
test
; @ eg test-testing-e32
struct Test
    owner String s
    new!()
        self.s := String{12}()!
mock ! Test.new()
; @ eg test-testing-e33
test ! fun()
; @ ec test-testing-e34
assert-error! fun0()
; @ ec test-testing-e35
assert-error! t!.num
; @ ec test-testing-e36
assert-error! t!
; @@ test-native
; @ g test-native-i0
native include "native.h"
; @ g test-native-i1
struct Test
    var Uint32 x
native include "first.h"
func fun()
native include "second.h"
; @ g test-native-f0
native func external()
func call()
    external()
; @ g test-native-f1
class Test
    var Uint32 x
    func dynamic user meth()
native func Uint32 external(
        copy Uint32 i, user String? s, user Array?{Uint32} a, user Test? t)
func call()
    var Uint32 i
    user String? s
    user Array?{Uint32} a
    user Test? t
    i := external(copy 5, user s, user a, user t)
    i := wraparound (2 * external(copy 5, user s, user a, user t)) + 3
    external(copy 5, user s, user a, user t)
; @ g test-native-f2
native func external() "SOME_External_func"
func call()
    external()
; @ g test-native-f3
struct Test
    var Uint32 x
native func Test? external()
func call()
    user Test? t
    t := external()
    external()
; @ g test-native-v0
native var Uint32 x
func use()
    x := 2
; @ g test-native-v1
native var Uint32 x "SOME_External_var"
func use()
    x := 2
; @ g test-native-c0
native const Int VALUE
native const Byte BYTE
func get()->(var Uint32 x)
    x := wraparound VALUE + BYTE
; @ g test-native-c1
native const Int VALUE "SOME_External_const"
func get()->(var Uint32 x)
    x := VALUE
; @ g test-native-t0
native type Native
native var Native native-var
native func Native get-native()
native func set-native(copy Native n)
func get()->(var Native n)
    n := get-native()
func call()
    var Native n
    set-native(copy native-var)
    get()->(var n)
    set-native(copy n)
; @ g test-native-t1
native type Native "SOME_External_type"
native func Native get-native() "SOME_External_get_func"
native func set-native(copy Native n) "SOME_External_set_func"
func call()
    var Native n
    n := get-native()
    set-native(copy n)
; @ g test-native-b0
var Uint32 x
native code "#define HAS_SOME_DEFINE"
var Uint32 y
; @ c test-native-b1
native "#ifdef __UNIX__"
io := 3
native "#else"
io := 4
native "#endif"
; @ eg test-native-e0
native()
; @ eg test-native-e1
native error
; @ eg test-native-e2
native error #
; @ eg test-native-ei0
native include native.h
; @ eg test-native-ef0
native func error()
native func error()
; @ eg test-native-ef1
native func Int ! error()
; @ eg test-native-ef2
native func error()->(copy Uint32 x)
; @ eg test-native-ef3
native func Uint32
; @ eg test-native-ef4
native func error(owner String s)
; @ eg test-native-ef5
native func error(weak String s)
; @ eg test-native-ef6
native func error(strong String s)
; @ eg test-native-ef7
native func error(s-var String s)
; @ eg test-native-ef8
native func Uint32 fun()
func error(copy Uint32 i)
    fun()->(copy i)
; @ eg test-native-ef9
native func fun()->(copy Uint32 res) error
; @ eg test-native-ef10
native func String? error()
; @ eg test-native-ef11
native func Array?{Uint32} error()
; @ eg test-native-ef12
class Error
    var Uint32 x
    func dynamic user meth()
native func Error? error()
; @ eg test-native-ev0
native var String s
; @ eg test-native-ev1
native var Uint32 x error
; @ eg test-native-ec0
native const Int VALUE error
; @ eg test-native-ec1
native const Bool VALUE
; @ eg test-native-ec2
native const Int VALUE
var String{VALUE} error
; @ eg test-native-et0
native type Native error
; @ eg test-native-et1
native type Native
native func Native external(copy Native in)
func error()
    var Native n
    n := external(copy n)
; @ eg test-native-eb0
native code #define error
; @ ec test-native-eb1
native #ifdef error
; @@ test-parameter-type
; @ g test-parameter-type-0
struct Test{Generic}
    weak Generic? item
    func user ! set(weak Generic item)
        weak Generic x(weak item)
        self.item := x
        new Test{Generic} t!
        t.item := self.item
        self.item := t.item
; @ g test-parameter-type-1
struct Test{Generic}
    owner Generic? item
    func user get()->(user Generic? item)
        item := self.item
; @ g test-parameter-type-2
struct StructA
    var Uint32 x
struct StructB
    var Uint32 x
struct StructC
    var Uint32 x
struct Test{First:Second:Third}
    weak First? first
    weak Second? second
    weak Third? third
    func user set(weak First first, weak Second second, weak Third third)
        self.first := first
        self.second := second
        self.third := third
func use(weak StructA first, weak StructB second, weak StructC third)
    var Test{StructA:StructB:StructC} t
    t.first := first
    t.second := second
    t.third := third
    t.set(weak first, weak second, weak third)
; @ g test-parameter-type-3
struct Base
    var Uint32 x
struct Test{Generic}(Base)
; @ c test-parameter-type-4
d!.item := t
; @ c test-parameter-type-5
t := d!.item
; @ g test-parameter-type-6
struct Test{Generic}
    var Uint32 x
    var Func{(user Generic item, copy Func{(user Generic item)} fun)} fun
    func user meth(copy Func{(user Generic item,
            copy Func{(user Generic item)} fun)} fun)
        var Func{(user Generic item, copy Func{(user Generic item)} funa)} funv
; @ c test-parameter-type-8
var Array{5:Data{Test}} ad
t := ad[2].item
; @ c test-parameter-type-10
d!.set(owner _)
; @ c test-parameter-type-11
var Data{Data{Data{Test}}} dr
t := dr.item!.item!.item
; @ c test-parameter-type-12
d!.set(owner to)
; @ c test-parameter-type-13
d!.get()->(weak t)
d!.get()!.meth()
; @ c test-parameter-type-14
var Data dg
; @ c test-parameter-type-15
user Data? dg(user d!)
; @ c test-parameter-type-16
Data{Test}.set(user d!, owner to)
; @ g test-parameter-type-17
struct Test{Generic}
    weak Test?{Generic} next
    func user meth(weak Test{Generic} next)->(user Test?{Generic} out)
        self.next := next
        out := self
; @ c test-parameter-type-18
var Data{Tb} dt
dt.item := tc
ta := dt.item
owner Tc? otc
dt.set(owner otc)
dt.get()->(weak ta)
i := dt.get()!.numa
fun7(weak dt.item)->(weak dt.item)
user Tb? tb2(user dt.item!)
tb2 := dt.item!
; @ g test-parameter-type-19
struct MyStruct
    var Uint32 x
    func user meth()
struct Base{Generic}
    weak Generic? item
    func user get()->(weak Generic? item)
struct Test(Base{MyStruct})
    func user set(weak MyStruct? f)
        self.item := f
        self.get()->(weak f)
func ! fun(user Test test, weak MyStruct? f)
    test.item := f
    test.set(weak f)
    f := test.item
    test.get()->(weak f)
    test.get()!.meth()
; @ g test-parameter-type-20
struct MyStruct
    var Uint32 x
    func user meth()
class Base{Param}
    weak Param? item
    func dynamic user set(weak Param? item)
    func dynamic user get()->(weak Param? item)
class Test{Generic}(Base{Generic})
    func dynamic user set(weak Generic? item)
    func dynamic user get()->(weak Generic? item)
func ! mock(weak Test{MyStruct} test, weak MyStruct? f)
    test!.set(weak f)
    test!.get()->(weak f)
    test!.get()!.meth()
; @ g test-parameter-type-21
struct Test{Param}
    weak Param? item
    func user meth(weak Param? in)->(weak Param? out) _
func Test.meth(weak Param? in)->(weak Param? out)
    weak Param? p(weak in)
    out := p
    self.item := p
    self.meth(weak p)->(weak p)
; @ eg test-parameter-type-eg0
struct Test{First:Second:Third
; @ eg test-parameter-type-eg1
struct Test{Generic}
    var Generic error
; @ eg test-parameter-type-eg2
struct Test{Generic}
    weak Generic? item
    func user meth(copy Generic error)
; @ eg test-parameter-type-eg3
struct Test{Generic}
    weak Generic? item
    func user meth(weak String s)
        self.item := s
; @ eg test-parameter-type-eg4
struct Test{Generic}
    weak Generic? item
    func user ! meth()->(user String? s)
        s := self.item!
; @ eg test-parameter-type-eg5
struct Test{Generic}
    weak Generic? item
    func user meth()
        var Generic error
; @ eg test-parameter-type-eg6
struct Test{First:Second}
    weak First? first
    weak Second? second
    func user meth()
        self.first := self.second
; @ eg test-parameter-type-eg7
struct Test{error}
    var Uint32 x
; @ eg test-parameter-type-eg11
struct MyStruct
    var Uint32 x
struct Test{First:Second:Third}
    weak First first
    weak Second second
    weak Third third
func meth(user Test{MyStruct:MyStruct} t)
    user Test{MyStruct:MyStruct:MyStruct} error(user t)
; @ eg test-parameter-type-eg12
struct Base{Param}
    weak Param item
struct Error(Base)
; @ eg test-parameter-type-eg13
struct MyStruct
    var Uint32 x
struct Base
    weak Uint32 x
struct Error(Base{MyStruct})
; @ eg test-parameter-type-eg14
struct MyStruct
    var Uint32 x
struct Base{Param}
    weak Param item
struct Error(Base{MyStruct:MyStruct})
; @ eg test-parameter-type-eg15
struct MyStruct
    var Uint32 x
struct Base{Param0:Param1}
    weak Param0 item0
    weak Param1 item1
struct Error(Base{MyStruct})
; @ ec test-parameter-type-ec0
var Data{Uint32} error
; @ ec test-parameter-type-ec1
var Data{Test:Test} error
; @ ec test-parameter-type-ec2
var Data{Error} error
; @ ec test-parameter-type-ec3
var Char{Test} error
; @ ec test-parameter-type-ec4
var Data dg
str := dg.item!
; @ ec test-parameter-type-ec5
s-var Data dg!
d := dg
; @ ec test-parameter-type-ec6
str := d!.item!
; @ ec test-parameter-type-ec7
var Data{Array{Uint32}} error
; @ ec test-parameter-type-ec8
var Data{String} error
; @ ec test-parameter-type-ec8
var Data{Buffer} error
; @@ test-parameter-inheritance
; @ g test-parameter-inheritance-0
struct MyStruct
    var Uint32 x
struct Base{Generic}
    weak Generic? item
struct Test(Base{MyStruct})
    func user ! set(weak MyStruct f)
        self.item := f
        Test.set(user Test()!, weak f)!
func use(weak MyStruct f)
    var Test t
    t.item := f
; @ g test-parameter-inheritance-1
struct MyStruct
    var Uint32 x
struct Base{Generic}
    weak Generic? item
struct Test{Param}(Base{Param})
    func user ! set(weak Param i, weak MyStruct f)
        self.item := i
        Test{MyStruct}.set(user Test{MyStruct}()!, weak f, weak f)!
func use(weak MyStruct f)
    var Test{MyStruct} t
    t.item := f
; @ g test-parameter-inheritance-2
struct MyStruct
    var Uint32 x
struct Base{Pbase}
    weak Pbase? item
    func user set(weak Pbase i)
struct Mid{Pmid}(Base{Pmid})
    func user set(weak Pmid i)
struct Top(Mid{MyStruct})
    func user set(weak MyStruct f)
        base(weak f)
        self.item := f
struct Test(Top)
    func user ! set(weak MyStruct f)
        base(weak f)
        self.item := f
        Top.set(user Top()!, weak f)
        Test.set(user Test()!, weak f)!
        Mid{MyStruct}.set(user Top()!, weak f)
func use(weak MyStruct f)
    var Test t
    t.item := f
; @ g test-parameter-inheritance-3
struct MyStruct
    var Uint32 x
struct Base{Generic}
    weak Generic? item
struct Test{Generic}(Base{Generic})
    func user ! set(weak Generic i, weak MyStruct f)
        self.item := i
        Test{MyStruct}.set(user Test{MyStruct}()!, weak f, weak f)!
func use(weak MyStruct f)
    var Test{MyStruct} t
    t.item := f
; @ g test-parameter-inheritance-4
struct StructA
    var Uint32 x
struct StructB
    var Uint32 x
struct StructC
    var Uint32 x
struct Base{First:Second}
    weak First? first
    weak Second? second
struct Mid{Param:Third}(Base{Param:StructB})
    weak Third? third
    func user set(weak Param first, weak StructB second, weak Third third)
        self.first := first
        self.second := second
        self.third := third
struct Top{Generic}(Mid{Generic:StructC})
    func user set(weak Generic first, weak StructB second, weak StructC third)
        self.first := first
        self.second := second
        self.third := third
struct Test(Top{StructA})
    func user set(weak StructA first, weak StructB second, weak StructC third)
        self.first := first
        self.second := second
        self.third := third
func use(weak StructA first, weak StructB second, weak StructC third)
    var Test t
    t.first := first
    t.second := second
    t.third := third
; @ g test-parameter-inheritance-5
struct MyStruct
    var Uint32 x
struct First{FirstGeneric}
    weak FirstGeneric? item
struct Second{SecondGeneric}
    weak SecondGeneric? item
struct Test{Generic}(First{Second{Generic}})
    func user ! set(weak Generic g, weak Second{Generic} sg)
        self.item := sg
        self.item!.item := g
func ! use(weak MyStruct f, weak Second{MyStruct} ff)
    var Test{MyStruct} t
    t.item := ff
    t.item!.item := f
; @ g test-parameter-inheritance-6
struct BaseGen{FirstGeneric}
    weak FirstGeneric? item
struct TestGen{SecondGeneric}(BaseGen{SecondGeneric})
struct Base
    var Uint32 x
struct Test(Base)
func test()
    user BaseGen?{Base} bb
    user BaseGen?{Test} bt
    user TestGen?{Base} tb
    user TestGen?{Test} tt
    bb := tb
    bt := tt
    bb := bt
    tb := tt
    bb := tt
; @ g test-parameter-inheritance-7
struct MyStruct
    var Uint32 x
struct Base{Generic}
    weak Generic? first
struct Mid{First:Second}(Base{First})
    weak Second? second
struct Top{Generic}(Mid{MyStruct:Generic})
func fun(user Top?{MyStruct} t)
    user Mid?{MyStruct:MyStruct} m
    m := t
; @ eg test-parameter-inheritance-e0
struct Base{Generic}
    weak Generic item
struct Test{Param}(Base{Param})
    weak Generic error
; @ eg test-parameter-inheritance-e1
struct MyStruct
    var Uint32 x
struct Base{Generic}
    weak Generic? item
struct Test(Base{MyStruct})
    func user set(weak String error)
        self.item := error
; @ eg test-parameter-inheritance-e2
struct Base{Generic}
    weak Generic? item
struct Test{Param}(Base{Param})
    func user set(weak String error)
        self.item := error
; @ eg test-parameter-inheritance-e3
struct MyStruct
    var Uint32 x
struct Base{Pbase}
    weak Pbase? item
struct Mid{Pmid}(Base{Pmid})
struct Top(Mid{MyStruct})
struct Test(Top)
    func user set(weak String error)
        self.item := error
; @@ test-error-handling
; @ c test-error-handling-0
if-error i := t.num
    i := 0
; @ c test-error-handling-1
if-error fune()
    i := 0
else
    io := i
; @ c test-error-handling-2
if-ok i := t.num
    io := i
else
    i := 0
; @ c test-error-handling-3
if b
    io := 0
else-if-error fune()
    i := 0
else
    io := i
; @ c test-error-handling-4
if b
    io := 0
else-if-ok i := t.num
    io := i
else
    i := 0
; @ g test-error-handling-5
func fun(weak String s)->(var Bool fail)
    if-error s.clear()
        fail := true
; @ ec test-error-handling-e0
if-error t.num
    i := 0
; @ ec test-error-handling-e1
if-ok t.num
else
    i := 0
; @ ec test-error-handling-e2
if-error fun0()
    i := 0
; @ ec test-error-handling-e3
if-ok i := t.num
; @ ec test-error-handling-e4
if-error i := t.num
; @ ec test-error-handling-e5
if-ok i := t.num
else
; @ ec test-error-handling-e6
if-error i := t!.num
    i := 0
; @@ test-try-catch
; @ c test-try-catch-0
try
    t.num := 1
    fun0()
catch
    i := t!.num
    fun4(copy 2)
; @ c test-try-catch-1
try
    t.num := 1
    fun0()
; @ c test-try-catch-2
try
    t.num := 1
    try
        fune()
    catch
        fun4(copy 2)
catch
    try
        i := arr[3]
    catch
        i := t!.num
; @ c test-try-catch-3
try
    var String{4} sa
    try
        s-var String{4} sb
    catch
        s-var String{4} sc
catch
    var String{4} sd
    try
        s-var String{4} se
    catch
        var String{4} sf
; @ g test-try-catch-4
func fun(weak String s)
    try
        s.clear()
        assert true
        assert-error s.clear()
        raise
; @ ec test-try-catch-e0
try()
; @ ec test-try-catch-e1
catch
; @ ec test-try-catch-e2
try
catch()
; @ ec test-try-catch-e3
try
; @ ec test-try-catch-e4
try
    fune()
catch
; @ ec test-try-catch-e5
try
    fune()
i := 2
catch
    i := 3
; @ ec test-try-catch-e6
try
    i := 1
; @ ec test-try-catch-e7
try
    fune()!
; @ ec test-try-catch-e8
try
    assert! true
; @@ test-for-each
; @ g test-for-each-0
struct TestIterator
    var Uint32 counter
    new(copy Uint32 count)
    func user step()->(var Uint32 num, var Bool has-data)
func ! fun()->(var Uint32 i)
    for n in TestIterator(copy 6)!
        var String{4} s
        i := n
; @ g test-for-each-1
struct TestIterator
    owner String? value
    func user step()->(user String? text, var Bool has-data)
        text := self.value
func fun(user TestIterator iter)
    user String? t
    user String? s
    for t in iter
        s := t
; @ g test-for-each-2
struct MyStruct
    var Uint32 x
struct TestIterator{Generic}
    weak Generic? item
    func user ! step()->(user Generic? item, var Bool has-data)
        item := self.item!
class Test
    var Uint32 x
    func dynamic user fun()
func ! fun(user TestIterator{MyStruct} fiter, user TestIterator{Test} titer)
    user MyStruct? of
    user Test? ot
    for f in fiter!
        of := f
    for t in titer!
        ot := t
; @ g test-for-each-3
struct MyStruct
    var Uint32 x
class TestIterator{Generic}
    weak Generic? item
    func dynamic user ! step()->(user Generic? item, var Bool has-data)
        item := self.item!
func ! f-mock(user TestIterator{MyStruct} iter)
    user MyStruct? f
    for t in iter!
        f := t
; @ g test-for-each-4
struct TestIterator
    owner String? value
    func user step()->(strong String? text, var Bool has-data)
        if-error text := String{12}(user self.value)
            text := _
func fun(user TestIterator iter)
    owner String? s
    for t in iter
        s := t
; @ g test-for-each-5
struct TestIterator
    owner String? value
    func user step()->(user String? text, var Bool has-data)
        text := self.value
func fun(user TestIterator iter)
    var Uint32 x
    for _ in iter
        x := 1
; @ eg test-for-each-e0
struct TestIterator
    var Uint32 num
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e1
struct TestIterator
    var Uint32 num
    func user step(user Uint32 x)->(var Uint32 num, var Bool has-data)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e2
struct TestIterator
    var Uint32 num
    func user step()
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e3
struct TestIterator
    var Uint32 num
    func user step()->(var Uint32 num)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e4
struct TestIterator
    var Uint32 num
    func user step()->(var Uint32 num, var Bool has-data, var Uint32 error)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e5
struct TestIterator
    var Uint32 num
    func user step()->(var Uint32 num, var Uint32 has-data)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e6
struct TestIterator
    var Uint32 num
    func weak step()->(var Uint32 num, var Bool has-data)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e7
struct TestIterator
    var Uint32 num
    func user ! step()->(var Uint32 num, var Bool has-data)
func fun(user TestIterator iter)
    for n in iter
; @@ test-complex-fields
; @ g test-complex-fields-0
struct Test
    var Bstruct b
    s-var Bstruct sb
    func user ! test()
        weak Bstruct b(weak self.sb)
        b := self.sb
        self.b.meth()
        Bstruct.meth(user self.b)
        user Bstruct? b2(user self.b.b!)
        b2 := self.b.b!
        self.b.b!.meth()
        self.b.b := b
        Bstruct.meth(user self.b.b!)
        s-var Test t!
        self.b.x := 5
        Astruct.meth(user self.b)
        if self.b is b or b2 is-not self.b
        b := t.b
class Astruct
    var Uint32 x
    func dynamic user? meth()
class Bstruct(Astruct)
    weak Bstruct? b
    func dynamic user? meth()
; @ g test-complex-fields-1
struct Base
    var Uint32 x
struct Test
    var String{10} s
    var Array{11:Uint32} ai
    var Array{12:Base} ab
    var Array{7:String{8}} as
    var Array{4:Array{5:Array{6:Uint32}}} aai
    var Array{4:Array{5:Array{6:Base}}} aab
    var Array{4:Array{5:String{6}}} aas
    func user ! test()->(var Char c, var Uint32 i, user Base? b)
        c := self.s[3]!
        i := self.ai[4]
        b := self.ab[5]
        c := self.as[4][5]!
        i := self.aai[1][2][3]
        b := self.aab[1][2][3]
        c := self.aas[1][2][3]!
; @ eg test-complex-fields-e0
var Uint32 x
struct Test
    var String{x} error
; @ eg test-complex-fields-e1
var Uint32 x
struct Test
    var Array{x:Uint32} error
; @ eg test-complex-fields-e2
struct Test
    var Test error
; @ eg test-complex-fields-e3
struct Test
    var Base error
struct Base
    var Test t
; @ eg test-complex-fields-e4
struct Abase
    var Berror b
struct Aerror(Abase)
struct Bbase
    var Aerror a
struct Berror(Bbase)
; @ eg test-complex-fields-e5
struct Base
    var Uint32 x
struct Test
    var Base b
    func user test(user Base b)
        self.b := b
; @ eg test-complex-fields-e6
struct Base
    var Uint32 x
struct Test
    var Base b
    func user ! error()
        assert! self.b?
; @@ test-enum
; @ g test-enum-0
enum MyEnum
    VALUE
    ANOTHER-VALUE
    LAST-VALUE
func dummy()
    var Uint32 x(copy MyEnum.VALUE)
    x := MyEnum.ANOTHER-VALUE
    x := MyEnum.length
; @ g test-enum-1
enum MyEnum
    VALUE
    ANOTHER-VALUE
    LAST-VALUE
var Array{MyEnum.length:Uint32} arr
; @ eg test-enum-e0
enum MyEnum
    VALUE
func dummy()
    var Uint32 x(copy MyEnum.ERROR)
; @ ec test-enum-e1
i := Error.VALUE
; @ eg test-enum-e2
enum MyEnum
    VALUE
func dummy()
    var Uint32 x(copy MyEnum.error)
; @ eg test-enum-e3
enum My-Enum
; @ eg test-enum-e4
enum MyEnum
    Error
; @ eg test-enum-e5
enum MyEnum
    ERRoR
; @ eg test-enum-e6
enum
; @ eg test-enum-e7
enum MyEnum
    VALUE(0)
; @ eg test-enum-e8
enum MyEnum
; @ eg test-enum-e9
enum MyEnum
        VALUE
; @ eg test-enum-e10
enum Error
    VALUE
enum Error
; @ eg test-enum-e11
struct Error
    var Uint32 x
enum Error
; @ eg test-enum-e12
enum Error
    VALUE
struct Error
    var Uint32 x
; @@ test-constant
; @ g test-constant-0
const Int NUMBER 12
; @ g test-constant-1
const Int SIZE 12
var Array{SIZE + 3:Uint32} arr
func fun(user Array{Uint32} a)
    fun(user arr)
; @ g test-constant-2
const Int LARGE 1 - (- (2 * SMALL))
const Int SMALL 7
; @ g test-constant-3
enum MyEnum
    VALUE
const Int NUMBER MyEnum.VALUE
; @ g test-constant-4
const Int NUMBER (128 div 3) mod 10
const Int D-CHAR 'a' + 3
; @ g test-constant-5
var Array{Enum.VAL + Enum.length + LENGTH:Uint32} arr
const Int LENGTH 6
enum Enum
    VAL
; @ eg test-constant-e0
const
; @ eg test-constant-e1
const Bool ERROR 0
; @ eg test-constant-e2
const Int
; @ eg test-constant-e3
const Int Error
; @ eg test-constant-e4
const Int ERROR
; @ eg test-constant-e5
const Int NAME false
; @ eg test-constant-e6
var Uint32 x
const Int NAME x
; @ eg test-constant-e7
const Int ERROR ERROR + 1
; @ eg test-constant-e8
const Int A-ERROR B-ERROR
const Int B-ERROR - (2 * A-ERROR) + 1
; @ eg test-constant-e9
const Int NUMBER 12
func dummy()
    NUMBER := 3
; @ eg test-constant-e10
const Int NUMBER 12
func dummy()->(var Uint32 x)
    dummy()->(var NUMBER)
; @@ test-module
; @ tg test-module-0
enum Enum
    VALUE
const Int SIZE 12
struct Test
    var Uint32 x
    func user meth()
var Test t
func ! fun()
    t.x := Enum.VALUE + SIZE
    fun()!
    Test.meth(user t)
    second.t.x := second.Enum.VALUE + second.SIZE
    second.fun()!
    second.Test.meth(user second.t)
    new second.Test nt!
; @-
module second
enum Enum
    VALUE
const Int SIZE 12
struct Test(ut.Test)
    func user meth()
var Test t
func ! fun()
    t.x := Enum.VALUE + SIZE
    fun()!
    Test.meth(user t)
    ut.t.x := ut.Enum.VALUE + ut.SIZE
    ut.fun()!
    ut.Test.meth(user ut.t)
    new ut.Test nt!
test dummy()
; @ tg test-module-1
func fun()
struct Test
    var Uint32 x
    func user meth()
        fun()
        self.meth()
; @-
module second
mock ut.fun()
mock ut.Test.meth()
test dummy()
; @ tg test-module-2
native type Native
native var Uint32 x
native func external()
func fun()
    x := 0
; @-
module second
test use()
    var ut.Native n
    ut.x := 2
    ut.external()
; @ ec test-module-e0
ut.error
; @ eg test-module-e1
var Uint32 ut
; @ eg test-module-e2
func ut()
; @ eg test-module-e3
var error.Test x
; @ eg test-module-e4
var ut.Error x
; @ etg test-module-e5
; nothing
; @-
module(error)
; @ etg test-module-e6
; @-
module Error
; @ etg test-module-e7
; @-
module true
; @ etg test-module-e8
; @-
module ; some global function
; @ etg test-module-e9
; @-
func fun()
; @ ec test-module-e10
fun0().Error
; @ ec test-module-e11
i.Error
; @ ec test-module-e12
ut.Error.VALUE
; @@ test-memory-owner
; @ g test-memory-owner-0
struct Test
    owner String? s
    owner String str
    new!()
        self.str := String{12}()!
        self.str.clear()
func use(user String? s)
func take(owner String? s)
func give()->(owner String? s)
func ! fun(owner String? s, user Test tu, owner Test to)
    s := _
    s := String{12}()!
    s!.clear()
    to.s := String{12}()!
    user String? su(user tu.s)
    use(user tu.s)
    take(owner to.s)
    var Array{12:Uint32} arr
    arr[4] := arr[8]
    loop
        give()->(owner s)
        while s?
; @ g test-memory-owner-1
struct TestStruct
    owner TestStruct? next
class TestClass
    strong TestClass? next
    func dynamic user fun()
func ! fun(
        owner TestStruct t,
        strong TestClass c,
        strong TestStruct tx,
        owner TestClass cx)
    t := t.next!
    t := t.next!.next!.next!
    t.next := t.next!.next!.next
    t.next!.next := t.next!.next!.next
    c := c.next!
    tx := tx.next!
    cx := cx.next!
; @ eg test-memory-owner-e0
struct Test
    owner String s
    new()
func ! fun(user Test t)
    t.s := String{12}()!
; @ eg test-memory-owner-e1
struct Aa
    var Uint32 x
struct Bb
    owner Aa? a
func fun(user Bb b)
    owner Aa? a(owner b.a)
; @ eg test-memory-owner-e2
struct Aa
    var Uint32 x
struct Bb
    owner Aa? a
func take(owner Aa? a)
func fun(user Bb b)
    take(owner b.a)
; @ eg test-memory-owner-e3
struct Aa
    owner String? s
struct Bb
    weak Aa? a
func ! fun(owner Array{Bb} b)
    b[3]!.a!.s := _
; @ eg test-memory-owner-e4
struct Test
    owner String? s
func get-user()->(weak Test? t)
func ! fun()
    weak Test? t
    get-user()->(weak t)!.s := _
; @ eg test-memory-owner-e5
struct Test
    owner String? s
func get-weak()->(weak Test? t)
func ! fun()
    get-weak()!.s := _
; @ eg test-memory-owner-e6
struct Test
    owner String s
    new()
func fun(owner Test t)->(owner String? s)
    s := t.s
; @ eg test-memory-owner-e7
struct Test
    owner String s
    new()
func fun(owner Test t)
    owner String s(owner t.s)
; @ eg test-memory-owner-e8
struct Test
    owner String s
    new()
func take(owner String s)
func fun(owner Test t)->(owner String? s)
    take(owner t.s)
; @ ec test-memory-owner-e9
new String{12} s!
new String{12} sg!
ostr := sg
sg := s
ostr!.clear()
sg.clear()
s.clear()
; @ eg test-memory-owner-e12
struct Test
    owner Test? t
func ! fun(owner Test? t)
    t!.t := t
; @ eg test-memory-owner-e13
struct Test
    owner Test? t
func ! fun(owner Test? t)
    t!.t!.t := t!.t
; @ eg test-memory-owner-e14
struct Test
    owner String s
    new!()
        self.s := String{4}()!
func fun(owner Test t, user Test tu, owner String s, user String su)
    t.s :=: s
    su.clear()
    s.clear()
    t.s.clear()
    tu.s :=: s
; @ ec test-memory-owner-e15
fun8(strong so)
so!.clear()
new String{12} s!
fun8(strong s)
s.clear()
; @ ec test-memory-owner-e16
new Test tgood!
owner Test tbad
if b
    tgood := to!
tgood.meth()
if b
    tbad := to!
tbad.meth()
; @ ec test-memory-owner-e17
new String{12} s!
repeat 12
    s.clear()
    ostr := s
    if b
        continue
    s := String{12}()!
; @ eg test-memory-owner-e18
func fun(owner String? s, owner String? s2)
    fun(owner s, owner s)
; @ eg test-memory-owner-e19
func fun()->(owner String? s, owner String? s2)
    fun()->(owner s, owner s2)
    fun()->(owner s, owner s)
; @ eg test-memory-owner-e20
func fun(owner String? s)->(owner String? s2)
    fun(owner s)->(owner s)
; @ eg test-memory-owner-e21
struct Test
    var Uint32 x
func ! fun(owner Test? t)->(var Uint32 x)
    x := wraparound fun(owner t)! + t!.x
; @ eg test-memory-owner-e22
struct Test
    var Uint32 x
func ! fun(owner Test? t)->(var Uint32 x)
    x := wraparound t!.x + fun(owner t)!
; @ eg test-memory-owner-e23
func ! fun(owner String s)->(var Uint32 x)
    for _ in fun(owner s)!:s.length()
; @ ec test-memory-owner-e24
new String{12} s!
try
    owner String s2(owner s)
    if b
        raise
    s := s2
s.clear()
; @ eg test-memory-owner-e25
struct Test
    owner String? s
func error()
    var cdef.Pointer{Test} pt
    pt.get-ref-at(copy 0).s := _
; @@ test-memory-user
; @ g test-memory-user-0
func deleting()->(owner String? s)
    s := _
func fun(user String s)->(owner String? so)
    s.clear()
    deleting()->(owner so)
; @ g test-memory-user-1
func deleting()->(strong String? s)
    s := _
func ! fun()
    strong String? so(strong String{12}()!)
    user String? s(user so)
    s!.clear()
    deleting()->(strong so)
; @ g test-memory-user-2
func deleting()->(strong String? s)
    s := _
func ! fun()
    strong String? so(strong String{12}()!)
    weak String? s(weak so)
    deleting()->(strong so)
    s!.clear()
; @ c test-memory-user-3
user String? s
so := _
s := so
s!.clear()
; @ g test-memory-user-4
struct Test
    weak String? s
    func user ! get()->(user String? s) _
func ! Test.get()->(user String? s)
    s := self.s!
func ! fun(user Test t)
    user String? s
    owner String? sowner(owner _)
    t.get()->(user s)!
    s!.clear()
    s := t.get()!
    s!.clear()
; @ c test-memory-user-5
user String? s(user ostr)
ostr := _
for s in sarr!
    s!.clear()
; @ g test-memory-user-6
func get()->(user String? s)
    s := _
func ! fun()
    loop
        user String? s
        while get()->(user s)?
        s!.clear()
; @ ec test-memory-user-e0
user String? s
so := _
c := s![2]!
; @ ec test-memory-user-e1
user String? s
user String? s2
so := _
s2 := s
; @ ec test-memory-user-e2
user String? s
so := _
s!.length()->(var i)
; @ ec test-memory-user-e3
user String? s
so := _
String.clear(user s!)
; @ ec test-memory-user-e4
user String? s
so := _
b := not (false or s!.length() > 3)
; @ eg test-memory-user-e5
func deleting(owner String? s)
func fun(user String s)
    deleting(owner _)
    s.clear()
; @ eg test-memory-user-e6
func deleting()->(owner String? s)
    s := _
func proxy()
    deleting()
func fun(user String s)
    proxy()
    s.clear()
; @ eg test-memory-user-e7
func deleting()->(owner String? s)
    proxy()
    s := _
func proxy()
    deleting()
func fun(user String s)
    proxy()
    s.clear()
; @ eg test-memory-user-e8
struct Test
    var Uint32 x
    func user deleting()->(owner String? s)
        s := _
    func user fun(user String s)
        self.deleting()
        s.clear()
; @ eg test-memory-user-e9
func deleting()->(owner String? s)
    s := _
func fun(user String s)
    deleting()
    s.clear()
; @ eg test-memory-user-e10
func deleting()
    owner String? s
func fun(user String s)
    deleting()
    s.clear()
; @ eg test-memory-user-e11
func deleting()
    var String{12} s
func fun(user String s)
    deleting()
    s.clear()
; @ eg test-memory-user-e12
func deleting()
    strong String? s
func fun(user String s)
    deleting()
    s.clear()
; @ ec test-memory-user-e13
user Array{Char} a(user ostr!)
ostr := _
c := a[2]!
; @ eg test-memory-user-e14
func ! deleting()
    var Uint32 x(copy String{12}()!.length())
func ! fun(user String s)
    deleting()!
    s.clear()
; @ eg test-memory-user-e15
struct Test
    owner String? s
func ! deleting(owner Test? ta, owner Test? tb)
    ta!.s := tb!.s
func ! fun(user String s)
    deleting(owner _, owner _)!
    s.clear()
; @ ec test-memory-user-e16
user Test? tt
d!.set(owner _)
tt.meth()
; @ eg test-memory-user-e17
struct MyStruct
    var Uint32 x
    func user meth()
struct Base{Atype}
    var Uint32 x
    func user fun(owner Atype? a)
struct Test{Btype}(Base{Btype})
    func user fun()
        base(owner _)
func fun(user MyStruct f)
    var Test{MyStruct} t
    t.fun()
    f.meth()
; @ eg test-memory-user-e18
struct Base
    var Uint32 x
struct Test(Base)
func deleting(owner Base? b)
func fun(user Test t)
    deleting(owner _)
    t.x := 0
; @ eg test-memory-user-e19
struct Base
    var Uint32 x
struct Test(Base)
struct Other(Base)
func deleting(owner Test? t)
func fun(user Base b, user Other o)
    deleting(owner _)
    o.x := 0
    b.x := 0
; @ eg test-memory-user-e20
class Base
    var Uint32 x
    func dynamic user fun()
class Test(Base)
    func dynamic user fun()
        owner String? s
func fun(user String s, user Base b)
    b.fun()
    s.clear()
; @ eg test-memory-user-e21
class Base
    var Uint32 x
    func dynamic user fun()
class Test{Generic}(Base)
    func dynamic user fun()
func fun(user String s, user Base b)
    b.fun()
    s.clear()
; @ eg test-memory-user-e22
class Base
    var Uint32 x
    func dynamic user? fun(owner Base? b)
        recursive()
class Test{Generic}(Base)
    func dynamic user? fun(owner Base? b)
func recursive()
    Base.fun(user _, owner _)
func fun(user String s)
    recursive()
    s.clear()
; @ ec test-memory-user-e23
user String? s
t!.fun!()
s!.clear()
; @ eg test-memory-user-e24
func ! deleting(copy Func?{()} f)
    f!()
func ! fun(user String s)
    deleting(copy _)!
    s.clear()
; @ eg test-memory-user-e29
struct Test
    owner String? s
func fun(owner Test? t, user String s)
    t := _
    s.clear()
; @ eg test-memory-user-e30
struct Other
    owner String? s
struct Test
    owner Other? o
func fun(owner Test? t, user String s)
    t := _
    s.clear()
; @ eg test-memory-user-e31
struct MyStruct
    var Uint32 x
    func user meth()
struct Base
    owner String? s
struct Test(Base)
struct Other(Base)
    owner MyStruct? f
func fun(owner Test? t, user String s, user MyStruct f)
    t := _
    f.meth()
    s.clear()
; @ eg test-memory-user-e32
struct Base
    var Uint32 x
struct Test(Base)
    owner String? s
func fun(owner Base? b, user String s)
    b := _
    s.clear()
; @ eg test-memory-user-e33
struct MyStruct
    var Uint32 x
    func user meth()
struct Test{Generic}
    owner Generic? x
func fun(owner Test?{MyStruct} t, user MyStruct f)
    t := _
    f.meth()
; @ eg test-memory-user-e34
struct MyStruct
    var Uint32 x
    func user meth()
struct Base{Generic}
    owner Generic? x
struct Test{Data}(Base{Data})
func ! fun(owner Test?{MyStruct} t, user MyStruct f)
    t := _
    f.meth()
; @ eg test-memory-user-e35
main!
    owner String? so(owner String{12}()!)
    user String? su(user so)
    so := _
    su!.clear()
; @ ec test-memory-user-e36
so := _
assert! str?
; @ ec test-memory-user-e37
so := _
assert-error! str.clear()
; @ ec test-memory-user-e38
so := _
if str?
; @ ec test-memory-user-e39
so := _
for _ in str!.length():2
; @ ec test-memory-user-e40
so := _
for _ in 2:str!.length()
; @ ec test-memory-user-e41
so := _
for _ in str!
; @ ec test-memory-user-e42
so := _
if b
    str!.clear()
; @ ec test-memory-user-e43
so := _
if false
    str := ostr
str!.clear()
; @ ec test-memory-user-e44
str := ostr
repeat 12
    str!.clear()
    ostr := _
    if b
        continue
    str := ostr
; @ ec test-memory-user-e45
str := ostr
try
    ostr := _
    if b
        raise
    str := ostr
str!.clear()
; @ ec test-memory-user-e46
str := ostr
for n in str!
    ostr := _
; @@ test-memory-temp
; @ g test-memory-temp-0
struct Test
    owner String? s
func fun(temp Test t)
    t.s := _
func use(owner Test t)
    fun(temp t)
    fun(temp t)
    temp Test tt(temp t)
    fun(temp tt)
    fun(temp tt)
    temp Test? tc
    tc := _
; @ g test-memory-temp-1
struct Test
    owner String? s
func fun(owner Test to)
    temp Test t(temp to)
    t.s := _
; @ g test-memory-temp-2
struct Test
    owner String? s
func fun(owner Test to, owner String s, owner String s2)
    temp String so(temp s)
    temp String so2(temp s2)
    if to.s?
        to.s := _
        temp Test t1(temp to)
        t1.s := _
        so.clear()
        so2 := so
        so2.clear()
        temp String si(temp so2)
    else
        to.s := _
        temp Test t2(temp to)
        t2.s := _
        so.clear()
        temp String si(temp so)
        so2 := si
        so2.clear()
    to.s := _
    temp Test t3(temp to)
    t3.s := _
    so.clear()
; @ g test-memory-temp-3
struct Test
    owner Test? next
func ! fun(owner Test to)
    temp Test t(temp to)
    loop
        while t.next?
        t := t.next!
; @ eg test-memory-temp-e0
func fun(temp String s)
func error(user String s)
    fun(temp s)
; @ eg test-memory-temp-e1
func fun(owner String s)
func error(temp String s)
    fun(owner s)
; @ eg test-memory-temp-e2
func error()->(temp String s)
; @ eg test-memory-temp-e3
func fun(temp String s1, temp String s2)
func error(owner String s)
    fun(temp s, temp s)
; @ eg test-memory-temp-e4
func fun(owner String so, temp String st)
func error(owner String s)
    fun(owner s, temp s)
; @ eg test-memory-temp-e5
func fun(temp String st, owner String so)
func error(owner String s)
    fun(temp s, owner s)
; @ eg test-memory-temp-e6
struct Sa
    owner Sb? sb
struct Sb
    owner Sa? sa
func fun(temp Sb sb, temp Sb x)
    sb.sa := x.sa
func ! error(owner Sb x)
    x.sa := Sa()!
    x.sa!.sb := Sb()!
    fun(temp x.sa!.sb!, temp x)
; @ ec test-memory-temp-e7
temp String? s1(temp so)
temp String? s2(temp so)
; @ ec test-memory-temp-e8
temp String? s(temp so)
so!.clear()
; @ ec test-memory-temp-e9
temp String? s1(temp so)
temp String? s2(temp s1)
s1!.clear()
; @ ec test-memory-temp-e10
temp String? s
if true
    s := so
s!.clear()
; @ ec test-memory-temp-e11
temp String? s
if true
    temp String? si(temp so)
    s := si
s!.clear()
; @ eg test-memory-temp-e12
struct Test
    owner Test? next
func ! fun(owner Test t)
    temp Test x(temp t.next!.next!)
    x.next := t
; @ eg test-memory-temp-e13
struct Test
    owner Test? next
func ! fun(owner Test t)
    temp Test x(temp t.next!.next!)
    x.next := t.next
; @ ec test-memory-temp-e14
temp String? s(temp ostr)
; @ eg test-memory-temp-e15
struct Test
    owner String? s
owner Test? t
func ! error()
    temp String? s(temp t!.s)
; @@ test-memory-output
; @ g test-memory-output-0
func ! fun()->(owner String s)
    s := String{12}()!
    s.clear()
; @ eg test-memory-output-e0
func fun()->(user String s)
; @ eg test-memory-output-e1
func deleting()
    owner String? s
func fun()->(user String? s)
    s := _
    deleting()
; @ eg test-memory-output-e2
func fun(owner String so)->(user String? s)
    s := _
; @ eg test-memory-output-e3
func fun()->(user String? s)
    owner String? so
    s := _
; @ eg test-memory-output-e4
func fun(user String sin)->(user String sout)
    if false
        sout := sin
; @ eg test-memory-output-e5
func fun(user String sin)->(user String sout)
    if true
        return
    sout := sin
; @ eg test-memory-output-e6
func fun()->(owner String s)
    s.clear()
; @ eg test-memory-output-e7
func fun()->(owner String s)
; @ eg test-memory-output-e8
func ! fun()->(owner String s)
    if true
        s := String{4}()!
; @ eg test-memory-output-e9
func ! fun()->(owner String s)
    if false
        return
    s := String{4}()!
; @@ test-memory-constructor
; @ g test-memory-constructor-0
struct NoConstructor
    var String{12} s
struct HasConstructor
    owner String s
    new!()
        self.s := String{12}()!
struct Test
    var NoConstructor vnc
    var HasConstructor vhc
    s-var NoConstructor svnc
    s-var HasConstructor svhc
    new!()
        self.vnc.s.clear()
        self.svnc.s.clear()
        self.vhc.new()!
        self.vhc.s.clear()
        self.svhc.new()!
        self.svhc.s.clear()
; @ g test-memory-constructor-1
func fun1()
func fun2(copy Func{()} f)
struct Base
    owner String s
    new!()
        self.s := String{12}()!
struct Mid(Base)
    new!()
        base()!
struct Test(Mid)
    owner Base? b
    new!()
        fun1()
        fun2(copy fun1)
        self.b!.new()!
        base()!
; @ g test-memory-constructor-2
struct Test
    var Int{1:100} a
    var Int{-30:-1} b
    var Int{0:100} c
    var Int{-30:0} d
    var Int{-10:10} e
    new()
        self.a := 1
        self.b := -1
; @ eg test-memory-constructor-e0
struct Error
    weak String s
; @ eg test-memory-constructor-e1
struct Error
    owner String s
    new()
; @ eg test-memory-constructor-e2
struct Error
    weak String s
    new!(strong String s)
        self.s!.clear()
        self.s := s
; @ eg test-memory-constructor-e3
struct Error
    owner String s
    new!()
        self.fun()
        self.s := String{12}()!
    func user fun()
        self.s.clear()
; @ eg test-memory-constructor-e4
struct Error
    owner String s
    new!()
        error(user self)
        self.s := String{12}()!
func error(user Error e)
    e.s.clear()
; @ eg test-memory-constructor-e5
struct Error
    owner String s
    new!()
        if false
            self.s := String{12}()!
; @ eg test-memory-constructor-e6
struct Error
    owner String s
    new() _
func Error.new()
; @ eg test-memory-constructor-e7
struct Error
    owner String s
    new!()
        if true
            return
        self.s := String{12}()!
; @ eg test-memory-constructor-e8
struct Test
    owner String s
    new!()
        self.s := String{12}()!
struct Error
    var Test t
; @ eg test-memory-constructor-e9
struct Test
    owner String s
    new!()
        self.s := String{12}()!
struct Error
    var Test t
    new()
; @ eg test-memory-constructor-e10
struct Base
    owner String s
    new!()
        self.s := String{12}()!
struct Test(Base)
    new()
; @ eg test-memory-constructor-e11
struct Test
    owner String s
    new!()
        self.s := String{12}()!
struct Error
    var Test t
    new!()
        self.t.s.clear()!
; @ eg test-memory-constructor-e12
struct Test
    owner String s
    new!()
        self.s := String{12}()!
struct Error
    var Test t
    new!()
        if false
            self.t.new()!
        self.t.s.clear()!
; @ eg test-memory-constructor-e13
struct Test
    var Int{1:100} a
; @ eg test-memory-constructor-e14
struct Test
    var Int{1:100} a
    new()
; @ eg test-memory-constructor-e15
struct Test
    var Int{1:100} a
    new!()
        if self.a = 1
        self.a := 1
; @@ test-memory-error
; @ ec test-memory-error-e0
str := str
; @ eg test-memory-error-e1
struct Error
    user String? s
; @ eg test-memory-error-e2
struct Error
    temp String? s
; @ eg test-memory-error-e3
func error(var String s)
; @ eg test-memory-error-e4
func error()->(var String s)
; @@ test-c-objects
; @ c test-c-objects-0
var Uint16 u16
var Sint16 s16
var Uint32 u32
var Sint32 s32
var Uint64 u64
var Sint64 s64
var cdef.Char c-char
var cdef.Schar c-schar
var cdef.Uchar c-uchar
var cdef.Short c-short
var cdef.Ushort c-ushort
var cdef.Int c-int
var cdef.Uint c-uint
var cdef.Long c-long
var cdef.Ulong c-ulong
var cdef.Size c-size
var cdef.Float c-float
var cdef.Double c-double
var cdef.LongDouble c-long-double
; line 20
c-char := s16
s32 := c-char
c-schar := s16
s32 := c-schar
c-uchar := u16
u16 := c-uchar
c-short := s32
s64 := c-short
c-ushort := u32
u32 := c-ushort
c-int := s64
s64 := clamp c-int
c-uint := u64
u64 := c-uint
c-long := s64
s64 := clamp c-long
c-ulong := u64
u64 := c-ulong
c-size := u64
; line 40
u64 := c-size
c-float := s64
s64 := clamp c-float
c-double := s64
s64 := clamp c-double
c-long-double := s64
s64 := clamp c-long-double
; line 48
j := c-char clamp+ (c-schar clamp+ (c-uchar clamp+ (c-short clamp+
        (c-ushort clamp+ (c-int clamp+ (c-uint clamp+ (c-long clamp+
        (c-ulong clamp+ (c-size clamp+ (c-float clamp+ (c-double clamp+
        (c-long-double clamp+ (c-char)))))))))))))
; @ c test-c-objects-1
var cdef.Pointer p-void
var cdef.Pointer{cdef.Char} p-char
var cdef.Pointer{cdef.Uint} p-uint
var cdef.Pointer{Test} p-test
var cdef.Pointer{cdef.Pointer{cdef.Int}} pp-int
var cdef.Pointer{cdef.Pointer{cdef.Pointer{cdef.Char}}} ppp-char
p-void := p-char
p-uint := p-void
p-char := p-uint
; @ c test-c-objects-2
var cdef.Int cint
var cdef.Pointer{cdef.Int} p-int
var cdef.Pointer{cdef.Pointer{cdef.Int}} pp-int
user Array?{cdef.Int} arr-int
p-int.set-from-array(user arr-int!)
p-int.set-point-to(var cint)
pp-int.set-point-to(var p-int)
p-int := pp-int.get-pointed-at(copy 0)
cint := p-int.get-pointed-at(copy 3)
var Test test
user Test u-test(user test)
var cdef.Pointer{Test} p-test
user Array?{Test} arr-test
p-test.set-from-array(user arr-test!)
p-test.set-from-ref(user test)
u-test := p-test.get-ref-at(copy 5)
; @ c test-c-objects-3
var cdef.Pointer{Char} p-char
p-char.set-from-array(user ostr!)
cdef.copy-to-string(copy p-char, user ostr!)!
cdef.set-null-term-length(user ostr!)
; @ c test-c-objects-4
var cdef.Pointer{Byte} p-byte
cdef.copy-to-buffer(copy p-byte, copy 4, user buff!)!
; @ ec test-c-objects-e0
var cdef.Pointer{Ta} error
; @ ec test-c-objects-e1
var cdef.Pointer{Uint32} p-int
i := p-int.get-ref-at(copy 5)
; @ ec test-c-objects-e2
var Test tv
var cdef.Pointer{Test} p-test
tv := p-test.get-pointed-at(copy 0)
; @@ test-cleanup-function
; @ g test-cleanup-function-0
struct Test
    owner String? s
    cleanup()
        try
            self.s.clear()
; @ g test-cleanup-function-1
class Base
    var Uint32 x
    func dynamic user meth()
    cleanup()
        self.meth()
class Test(Base)
    cleanup()
        self.meth()
; @ eg test-cleanup-function-e0
struct Test
    var Uint32 x
    cleanup()
    cleanup()
; @ eg test-cleanup-function-e1
struct Test
    var Uint32 x
    cleanup!()
; @ eg test-cleanup-function-e2
struct Test
    owner String? s
    cleanup()
        self.s!.clear()
; @ eg test-cleanup-function-e3
struct Test
    var Uint32 x
    cleanup(copy Uint32 error)
; @ eg test-cleanup-function-e4
struct Test
    var Uint32 x
    cleanup()->(var Uint32 error)
; @ eg test-cleanup-function-e5
struct Test
    var Uint32 x
    func temp cleanup()
; @