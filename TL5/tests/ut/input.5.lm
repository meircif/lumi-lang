struct Test
    var Int num
    weak Test? t
    var Func?{()} fun
    func user? meth()
class Ta(Test)
    var Int numa
    func inst user? metha()
    func dynamic user? dyn()
class Tb(Ta)
    var Int numb
    new!(copy Int num)
    func inst user? methb()
    func dynamic user? dyn()
class Tc(Tb)
    var Int numc
    func inst user? methc()
    func dynamic user? dyn()
struct Data{Generic}
    weak Generic? item
    func user? set(owner Generic? item)
    func user? get()->(weak Generic? item)

func fun0()
func fun1(copy Int x, user String? s, owner String? o)
func fun2()->(strong String? s, var Int x)
func fun3(copy Int x)->(strong String? s)
func fun4(copy Int x)
func fun5(copy Int x)->(var Int y)
func fun6(copy Int x, copy Int y)->(var Int n, var Int m)
func fun7(weak Tb? tb)->(weak Tb? tbo)
func fun8(strong String? s)
func ! fune()

var Int i
var Byte bt
var Char c
var Bool b
user String? str
owner String? ostr
weak Array?{Int} arr
owner File? fobj
weak Test? t
weak Ta? ta
strong Tb? tb
weak Tc? tc
weak Data?{Test} d
weak Array?{String} sarr

func ! mock()->(strong String? so, var Int io, strong Test? to, weak Tc? tco)
; @@ test-int-expression
; @ c test-int-expression-0
i := 0
; @ c test-int-expression-1
i := 9630
; @ c test-int-expression-2
i := -9630
; @ c test-int-expression-3
i := 07520
; @ c test-int-expression-4
i := -07520
; @ c test-int-expression-5
i := 0xfda940
; @ c test-int-expression-6
i := -0xfda940
; @ c test-int-expression-7
i := 0xFDA940
; @ c test-int-expression-8
i := -0xFDA940
; @ c test-int-expression-9
i := 0b100101
; @ c test-int-expression-10
i := -0b100101
; @ ec test-int-expression-e0
2a
; @ ec test-int-expression-e1
0a
; @ ec test-int-expression-e2
038
; @ ec test-int-expression-e3
0b021
; @ ec test-int-expression-e4
0xadg
; @@ test-byte-expression
; @ c test-byte-expression-0
bt := 0
; @ c test-byte-expression-1
bt := 127
; @ c test-byte-expression-2
bt := 075
; @ c test-byte-expression-3
bt := 0xfd
; @ c test-byte-expression-4
bt := 0xFD
; @ c test-byte-expression-5
bt := 0b10010100
; @@ test-char-expression
; @ c test-char-expression-0
c := 'a'
; @ c test-char-expression-1
c := '\''
; @ c test-char-expression-2
c := '\n'
; @ c test-char-expression-3
c := '\x0f'
; @ c test-char-expression-4
c := '\xA9'
; @ c test-char-expression-5
c := '\270'
; @ fec test-char-expression-e0
c := '''
; @ fec test-char-expression-e1
c := '\'
; @ fec test-char-expression-e2
c := 'aa
; @ ec test-char-expression-e3
c := '\c'
; @ ec test-char-expression-e4
c := 'aaaa'
; @ ec test-char-expression-e5
c := '\x6g'
; @ ec test-char-expression-e6
c := '\058'
; @ ec test-char-expression-e7
c := ''
; @ ec test-char-expression-e8
c := 'aa'
; @ ec test-char-expression-e9
c := 'aaa'
; @ ec test-char-expression-e10
c := 'aaaaa'
; @@ test-string-expression
; @ c test-string-expression-0
str := "some string"
; @ c test-string-expression-1
str := "\nstring\t\"with\\formatting\n"
; @ c test-string-expression-2
str := "line\
        split\
        string\
        "
; @ c test-string-expression-3
str := "multi
        line
        string
        "
; @ c test-string-expression-4
str := "line\
         split"
; @ fec test-string-expression-e0
str := "aaa
; @ fec test-string-expression-e1
str := "
; @ ec test-string-expression-e2
"error"+"string"
; @ ec test-string-expression-e3
str := "indention
    too short"
; @ ec test-string-expression-e4
str := "indention\
    too short"
; @@ test-empty-expression
; @ c test-empty-expression-0
str := _
; @ c test-empty-expression-1
t := _
; @ c test-empty-expression-2
so := _
; @ c test-empty-expression-3
b := t is _ or ta is-not _
; @ ec test-empty-expression-e0
i := _
; @@ test-member-expression
; @ c test-member-expression-0
i := t!.num
; @ c test-member-expression-1
i := tc!.numb
; @ c test-member-expression-2
i := tc!.num
; @ c test-member-expression-3
i := to!.num
; @ c test-member-expression-4
tco := tc
i := tco!.num
; @ c test-member-expression-5
i := t!.t!.num
; @ c test-member-expression-6
i := t!.t!.t!.num
; @ ec test-member-expression-e0
error
; @ ec test-member-expression-e1
(i := 1).error
; @ ec test-member-expression-e2
t.error
; @ ec test-member-expression-e3
5.error
; @@ test-slice-expression
; @ c test-slice-expression-0
c := ostr![13]!
; @ c test-slice-expression-1
user Array?{Char} x
x := ostr![2:6]!
; @ c test-slice-expression-2
i := arr![13]!
; @ c test-slice-expression-3
user Array?{Int} x
x := arr![2:i]!
; @ c test-slice-expression-4
ostr![4]! := c
; @ c test-slice-expression-5
arr![4]! := i
; @ c test-slice-expression-6
strong Array?{Test} tarr
t := tarr![3]!
; @ c test-slice-expression-7
var Array{8:String{5}} vsa
user String s(user vsa[3])
user Array{String} sa(user vsa[2:4])
; @ g test-slice-expression-8
func ! fun(temp String s, strong Array{String} sa)
    var Char c(copy s[5]!)
    user Array{Char} part(user s[4:2]!)
    user String si(user sa[3]!)
; @ c test-slice-expression-9
strong Array?{String} sa
sa![3]!.copy(user "text")!
sa := _
; @ c test-slice-expression-10
strong Array?{Array{Int}} aai
arr := aai![3]!
weak Array?{Array{Int}} ua(weak aai![2:4]!)
; @ c test-slice-expression-11
strong Array?{Array{Array{Array{Int}}}} aai
weak Array?{Array{Array{Int}}} ua(weak aai![3]!)
weak Array?{Array{Array{Array{Int}}}} uaa(weak aai![2:4]!)
; @ c test-slice-expression-12
strong Array?{Array{Array{String}}} aas
weak Array?{Array{String}} ua(weak aas![3]!)
weak Array?{Array{Array{String}}} uaa(weak aas![2:4]!)
aas := _
; @ c test-slice-expression-13
var Array{8:Array{7:Array{6:Array{5:Int}}}} aai
user Array?{Array{Array{Int}}} ua(user aai[3])
user Array?{Array{Array{Array{Int}}}} uaa(user aai[2:4])
; @ c test-slice-expression-14
var Array{8:Array{7:Array{6:String{5}}}} aas
user Array?{Array{String}} ua(user aas[i]!)
user Array?{Array{Array{String}}} uaa(user aas[2:4])
; @ g test-slice-expression-15
func fun()
    var Array{8:Array{7:Array{6:String{5}}}} aas
    user String s(user aas[4][3][2])
; @ c test-slice-expression-16
user Array?{Char} x
x := ostr
; @ c test-slice-expression-17
new String{12} s!
sys.print(user s)!
; @ g test-slice-expression-18
struct Test
    owner String? s
func fun()
    var Test t
    var Array{6:Test} a
; @ ec test-slice-expression-e0
arr[2
; @ ec test-slice-expression-e1
arr[2:3
; @ ec test-slice-expression-e2
(i := 3)[2]!
; @ ec test-slice-expression-e3
i[2]!
; @ ec test-slice-expression-e4
arr![str]!
; @ ec test-slice-expression-e5
arr![3:str]!
; @ ec test-slice-expression-e6
arr![i += 3]!
; @ ec test-slice-expression-e7
str![2:5]! := so
; @ ec test-slice-expression-e8
arr![7:2]! := Array{5:Int}()!
; @ ec test-slice-expression-e9
user Array?{Test} at
at![0] := t
; @ ec test-slice-expression-e10
so := sarr![3]!
; @ ec test-slice-expression-e11
var Array{3:Tc} error
; @ eg test-slice-expression-e12
struct Test
    var Int x
    new()
func func(user Array{Test} error)
; @ ec test-slice-expression-e13
i := arr![i]
; @ ec test-slice-expression-e14
var Array{0:Int} error
; @ ec test-slice-expression-e15
arr![-1]
; @ ec test-slice-expression-e16
arr![1:0]
; @ ec test-slice-expression-e17
s-var Array{3:Int} a!
arr := a[1:3]
; @@ test-call-expression
; @ c test-call-expression-0
fun0()
; @ c test-call-expression-1
fun1(copy 3, user ostr, owner _)
; @ c test-call-expression-2
fun2()->(strong so, var io)
; @ c test-call-expression-3
var Int x
strong String? s
fun2()->(strong s, var x)
; @ c test-call-expression-4
fun3(copy 0)->(strong so)
; @ c test-call-expression-5
var Int x
fun4(copy fun5(copy 3)->(var x))
; @ c test-call-expression-6
fun6(
        copy 2,
        copy 3)->(
        var io,
        var io)
; @ c test-call-expression-7
fun5(copy 4)
; @ c test-call-expression-8
io := fun5(copy 4)
; @ c test-call-expression-9
so := fun3(copy 7)
; @ c test-call-expression-10
t!.meth()
; @ c test-call-expression-11
to.meth()
; @ c test-call-expression-12
tc!.methc()
; @ c test-call-expression-13
tc!.methb()
; @ c test-call-expression-14
tc!.meth()
; @ c test-call-expression-15
tco := tc
tco!.meth()
; @ c test-call-expression-16
t!.t!.meth()
; @ c test-call-expression-17
fun1(copy 3, user ostr, owner so)
; @ c test-call-expression-18
fun3(copy 1)
fun5(copy 2)
; @ g test-call-expression-19
class Base
    var Int x
    func dynamic user ! meth(owner Base b)
class Test(Base)
    func dynamic user ! meth(owner Base b)
        new Test t!
        base(owner t)!
; @ g test-call-expression-20
class Test
    var Int x
    func dynamic user meth()
func ! mock()->(weak Test? t)
    mock()->(weak t)!.meth()
; @ g test-call-expression-21
class Test
    var Int x
    func dynamic user ! meth()->(weak Test? t)
        self.meth()!.meth()!
; @ g test-call-expression-22
func fun()->(owner Array?{String} astr)
    fun()->(owner astr)
; @ g test-call-expression-23
func ! fun(temp String s)
    var String{12} vars
    s-var String{12} s-vars!
    owner String owners(owner String{12}()!)
    strong String strongs(strong String{12}()!)
    user String users(user s)
    fun(temp s)!
    fun(temp vars)!
    fun(temp s-vars)!
    fun(temp owners)!
    fun(temp strongs)!
    s.clear()
; @ c test-call-expression-24
strong String? s
weak String? sw
fun1(copy 0, user sw!, owner s)
; @ c test-call-expression-25
fun8(strong ostr)
; @ c test-call-expression-26
fune()!
; @ ec test-call-expression-e0
function( copy 1)
; @ ec test-call-expression-e1
function(user)
; @ ec test-call-expression-e2
function(copy 4,copy 3)
; @ ec test-call-expression-e3
function(copy 2
; @ ec test-call-expression-e4
function(error 4)
; @ ec test-call-expression-e5
(i := 0)()
; @ ec test-call-expression-e6
i()
; @ ec test-call-expression-e7
fun5(copy 0)->(var 4)
; @ ec test-call-expression-e8
fun7(weak _)->(weak tc)
; @ ec test-call-expression-e9
fun5(copy i := 1)
; @ ec test-call-expression-e10
fun5(user 8)
; @ ec test-call-expression-e11
fun1(copy 3, user str, owner str)
; @ ec test-call-expression-e12
fun3(copy 3)->(strong str)
; @ ec test-call-expression-e13
fun7(weak _)->(weak tb)
; @ ec test-call-expression-e14
fun0(copy i)
; @ ec test-call-expression-e15
fun1()
; @ ec test-call-expression-e16
fun0()->(copy i)
; @ ec test-call-expression-e17
fun2()
; @ eg test-call-expression-e18
struct Base
    var Int x
    func user meth(owner Base b)
struct Test(Base)
    func user meth(owner Test t)
        base(owner t)
; @ ec test-call-expression-e19
var String{16} text
fun1(copy 3, user str, owner text)
; @ ec test-call-expression-e20
owner Tb? tbo
fun7(weak tbo)
; @ ec test-call-expression-e21
fune()
; @ eg test-call-expression-e22
func ! fune()
func fun()
    fune()!
; @@ test-type-expression
; @ c test-type-expression-0
Test.meth(user t!)
; @ c test-type-expression-1
Tb.methb(user tc!)
; @ c test-type-expression-2
Tc.meth(user tc!)
; @ ec test-type-expression-3
Error
; @@ test-base-expression
; @ g test-base-expression-0
struct Base
    var Int x
    func user methb()
struct Mid(Base)
    func user methm()
struct Top(Mid)
    func user methb()
    func user methm()
        base.methm()
; @ g test-base-expression-1
struct Base
    var Int x
    func user methb()
struct Mid(Base)
    func user methm()
struct Top(Mid)
    func user methb()
    func user methm()
        base.methb()
; @ ec test-base-expression-e0
base
; @ eg test-base-expression-e1
struct Test
    var Int x
    func user mock()
        base
; @ eg test-base-expression-e2
struct Base
    var Int x
struct Test(Base)
    var Int x
    func user mock()
        base()
; @ eg test-base-expression-e3
struct Base
    var Int x
struct Test(Base)
    func user mock()
        base := self
; @ eg test-base-expression-e4
struct Base
    var Int x
struct Test(Base)
    func user mock()->(var Int x)
        x := base.x
; @@ test-block-expression
; @ c test-block-expression-0
i := 2 + (123)
; @ c test-block-expression-1
i := (123)
; @ c test-block-expression-2
i := (123 * (i - 4)) + 2
; @ ec test-block-expression-3
(error
; @@ test-unary-expression
; @ c test-unary-expression-0
i := - i
; @ c test-unary-expression-1
i := -
        i
; @ c test-unary-expression-2
i := - - i
; @ c test-unary-expression-3
b := not b
; @ c test-unary-expression-4
b := not i > 3
; @ ec test-unary-expression-5
{45}
; @ ec test-unary-expression-6
-[
; @ ec test-unary-expression-7
+ 2
; @ ec test-unary-expression-8
- (i := 2)
; @ ec test-unary-expression-9
- (i > 4)
; @ ec test-unary-expression-10
not i
; @@ test-binary-expression
; @ c test-binary-expression-0
i := 23 + 54
; @ c test-binary-expression-1
i += (100 * 2) - 37
i *= 3
; @ c test-binary-expression-2
i -= 12 *
        13
; @ c test-binary-expression-3
b := 3 < 5 or 23 > 37
; @ c test-binary-expression-4
b := 3 <= 5 and 23 >= 37
; @ c test-binary-expression-5
b := i = 5 or i <> 37
; @ c test-binary-expression-6
b := 2 < i < 12 = 2 * i
; @ c test-binary-expression-7
t := tc
; @ c test-binary-expression-8
owner String? s
s := so
; @ c test-binary-expression-9
str := so
; @ c test-binary-expression-10
b := t is ta or tc is-not tb
; @ c test-binary-expression-11
c := '0' + 4
; @ c test-binary-expression-12
b := fun0 is-not fun1
; @ c test-binary-expression-13
b := b = b
; @ c test-binary-expression-14
owner Tc? otc
tb := otc!
; @ c test-binary-expression-15
owner Array?{Test} otarr
otarr := _
; @ c test-binary-expression-16
io := (60 div i!) + (60 mod i!)
; @ c test-binary-expression-17
i := i bor 8
; @ c test-binary-expression-18
i := i band 10
; @ c test-binary-expression-19
i := bnot i
; @ c test-binary-expression-20
i := i xor 16
; @ c test-binary-expression-21
i := i shr 2
; @ c test-binary-expression-22
i := i shl 1
; @ ec test-binary-expression-e0
345 @ 2
; @ ec test-binary-expression-e1
80 +(
; @ ec test-binary-expression-e2
1 + 2 * 3
; @ ec test-binary-expression-e3
1 < i or 2 < i and 3 < i
; @ ec test-binary-expression-e4
1 not 2
; @ ec test-binary-expression-e5
1 := 2
; @ ec test-binary-expression-e6
1 += 2
; @ ec test-binary-expression-e7
1 -= 2
; @ ec test-binary-expression-e8
so := str
; @ ec test-binary-expression-e9
b := 1 or 2
; @ ec test-binary-expression-e10
b := t > 3
; @ ec test-binary-expression-e11
b := 1 > 4 > t
; @ ec test-binary-expression-e12
i := 3 + t
; @ ec test-binary-expression-e13
t += 3
; @ ec test-binary-expression-e14
i -= b
; @ ec test-binary-expression-e15
b := 3 is t
; @ ec test-binary-expression-e16
user Array?{Char} ca
ca := arr!
; @ ec test-binary-expression-e17
owner Test? ot
ot := tb
; @ ec test-binary-expression-e18
b := b is b
; @ ec test-binary-expression-e19
b := t is t < 2
; @ ec test-binary-expression-e20
user Test? tu
t := tu
; @ ec test-binary-expression-e21
var Test tv
user Test tu(user tv)
tu := t
; @ ec test-binary-expression-e22
io := 60 div i
; @ ec test-binary-expression-e23
io := 60 mod i
; @ ec test-binary-expression-e24
io := 60 div 0
; @ ec test-binary-expression-e25
io := 60 mod 0
; @@ test-swap-expression
; @ c test-swap-expression-0
new Test t1!
new Test t2!
t1 :=: t2
; @ c test-swap-expression-1
strong Test t1(strong to!)
strong Test t2(strong to!)
t1 :=: t2
; @ c test-swap-expression-2
new Tc t1(copy 1)!
new Tc t2(copy 2)!
t1 :=: t2
; @ c test-swap-expression-3
strong Tc t1(strong Tc(copy 1)!)
strong Tc t2(strong Tc(copy 2)!)
t1 :=: t2
; @ c test-swap-expression-4
new Array{4:Int} a1!
new Array{6:Int} a2!
a1 :=: a2
; @ c test-swap-expression-5
strong Array{Int} a1(strong Array{4:Int}()!)
strong Array{Int} a2(strong Array{6:Int}()!)
a1 :=: a2
; @ c test-swap-expression-6
new String{4} s1!
new String{6} s2!
s1 :=: s2
; @ c test-swap-expression-7
strong String s1(strong String{4}()!)
strong String s2(strong String{6}()!)
s1 :=: s2
; @ g test-swap-expression-8
struct Test
    owner File f
    new(owner File f)
        self.f := f
func fun(owner Test t1, owner Test t2)
    t1.f :=: t2.f
; @ c test-swap-expression-9
user Test t1(user t!)
user Test t2(user t!)
t1 :=: t2
; @ c test-swap-expression-10
weak Test t1(weak to!)
weak Test t2(weak to!)
t1 :=: t2
; @ c test-swap-expression-11
i :=: io
; @ c test-swap-expression-12
d!.item :=: t
; @ ec test-swap-expression-e0
t :=: to
; @ ec test-swap-expression-e1
new Test t1!
t1 :=: t1
; @ ec test-swap-expression-e2
new String{8} nstr!
ostr :=: nstr
; @ ec test-swap-expression-e3
weak Array{Char} a(weak so!)
a :=: so![1:2]!
; @ ec test-swap-expression-e4
ta :=: tc
; @ ec test-swap-expression-e5
new Test t1!
strong Test t2(strong to!)
t1 :=: t2
; @@ test-question-expression
; @ c test-question-expression-0
b := ostr?
; @ c test-question-expression-1
b := not arr?
; @ c test-question-expression-2
b := t!.fun?
; @ c test-question-expression-3
b := to?
; @ c test-question-expression-4
b := fun7(weak _)->(weak t)?
; @ c test-question-expression-5
weak Test tt(weak t!)
b := tt?
; @ g test-question-expression-6
struct Test
    weak String? s
    func user meth()->(var Bool res)
        res := self.s?
; @ ec test-question-expression-e0
(i := 2)?
; @ ec test-question-expression-e1
i?
; @ ec test-question-expression-e2
var Test tt
if tt?
; @@ test-exclamation-expression
; @ c test-exclamation-expression-0
user String s(user ostr!)
; @ c test-exclamation-expression-1
user Test tt(user t!.t!)
; @ c test-exclamation-expression-2
user Test? tu
tu := fun7(weak _)->(weak t)!
; @ c test-exclamation-expression-3
i := tb!.num
; @ c test-exclamation-expression-4
weak Test tt(weak t!)
; @ c test-exclamation-expression-5
new String{str!.length()} s!
; @ ec test-exclamation-expression-e0
user String s(user str)
; @ ec test-exclamation-expression-e1
user Test? tt(user t)
; @ ec test-exclamation-expression-e2
new String{4} s!
s := ostr
; @ ec test-exclamation-expression-e3
weak String? s
fun1(copy 0, user s, owner _)
; @ ec test-exclamation-expression-e4
t.num
; @ ec test-exclamation-expression-e5
t.meth()
; @ ec test-exclamation-expression-e6
var Func?{()} fun
fun()
; @ ec test-exclamation-expression-e7
i := arr[3]!
; @ ec test-exclamation-expression-e8
for _ in str
; @ ec test-exclamation-expression-e9
weak String? s
raise! s
; @ ec test-exclamation-expression-e10
new String{str.length()} s!
; @ ec test-exclamation-expression-e11
so := ostr
; @ ec test-exclamation-expression-eo0
raise! str!!
; @ ec test-exclamation-expression-en0
var String{8} s
so := s!
; @ ec test-exclamation-expression-en1
io := (2!) + 3
; @ ec test-exclamation-expression-en2
so! := str
; @ ec test-exclamation-expression-en3
"text"!.clear()
; @ ec test-exclamation-expression-en4
var Func{(user Test? self)} fun(copy Test!.meth)
; @ ec test-exclamation-expression-en5
var Test tv
i := tv!.num
; @ eg test-exclamation-expression-en6
struct Base
    var Int x
    func user fun()
struct Test(Base)
    func user fun()
        base!()
; @ ec test-exclamation-expression-en7
fun0!()
; @ eg test-exclamation-expression-en8
func fun(user String s)
    fun(user s!)
; @ ec test-exclamation-expression-en9
var Func{()} fun(copy fun0)
fun!()
; @ ec test-exclamation-expression-en10
if not b!
; @ ec test-exclamation-expression-en11
io := 2 + 3!
; @ eg test-exclamation-expression-en12
func fun()
mock fun()
    fun!.active := false
; @ ec test-exclamation-expression-en13
ut!.fun0()
; @ ec test-exclamation-expression-en14
if t!?
; @ ec test-exclamation-expression-en15
if b!
; @ ec test-exclamation-expression-en16
loop
    while b!
; @ ec test-exclamation-expression-en17
for _ in 3!
; @ ec test-exclamation-expression-en18
for _ in 3!:4
; @ ec test-exclamation-expression-en19
for _ in 3:4!
; @ ec test-exclamation-expression-en20
var String{4} s
for _ in s!
; @ ec test-exclamation-expression-en21
var Array{4:Int} a
for _ in a!
; @ ec test-exclamation-expression-en22
user String? s(user str!)
; @ eg test-exclamation-expression-en23
const Int CONST 12!
; @ ec test-exclamation-expression-en24
assert! b!
; @ ec test-exclamation-expression-en26
var Array{4:Int} a
i := a![2]!
; @ ec test-exclamation-expression-en27
var Array{4:Int} a
i := a[2!]!
; @ ec test-exclamation-expression-en28
var Array{4:Int} a
i := a[2:3!]!
; @ ec test-exclamation-expression-en29
var Ref r
r := ostr!
; @ ec test-exclamation-expression-en30
raise! "error"!
; @ ec test-exclamation-expression-en31
raise! str!
; @ ec test-exclamation-expression-en32
var String{23!} s
; @@ test-dynamic
; @ c test-dynamic-0
var Ta a
; @ c test-dynamic-1
user Ta? a
; @ c test-dynamic-2
owner Ta nta(owner Ta()!)
; @ c test-dynamic-3
new Ta a!
; @ c test-dynamic-4
user Ta? a(user ta!)
; @ c test-dynamic-5
user Ta? x
x := ta!
; @ c test-dynamic-6
ta := tb
; @ c test-dynamic-7
ta := tc
; @ c test-dynamic-8
ta := _
; @ c test-dynamic-9
strong Array?{Ta} aa
ta := aa![4]!
; @ c test-dynamic-10
strong Array?{Tc} ca
ta := ca![4]!
; @ c test-dynamic-11
ta!.dyn()
; @ c test-dynamic-12
tb!.dyn()
; @ c test-dynamic-13
tc!.dyn()
; @ c test-dynamic-14
tco := tc
tco!.dyn()
; @ c test-dynamic-15
fun7(weak tc)->(weak ta)
; @ g test-dynamic-16
class Test
    var Int x
    func dynamic user meth()
func ! mock()->(weak Test? t)
    t!.meth()
; @ g test-dynamic-17
class Base
    var Int x
    func dynamic user meth()
class Test(Base)
    func inst user fun()
        self.meth()
; @ c test-dynamic-18
fun7(weak _)
; @ eg test-dynamic-e0
class Test
    var Int x
    func dynamic weak? meth()
func fun()
    weak Test? t
    t.meth()
; @@ test-function-object
; @ c test-function-object-0
var Func{()} fun
fun := fun0
fun()
; @ c test-function-object-1
var Func{(copy Int x)->(var Int y)} fun(copy fun5)
var Int x
fun(copy 9)->(var x)
; @ c test-function-object-2
var Func{(user Test? self)} fun(copy Test.meth)
fun(user t!)
; @ c test-function-object-3
var Func?{()} fun
fun := _
b := fun?
fun!()
; @ c test-function-object-4
t!.fun := fun0
t!.fun!()
; @ c test-function-object-5
var Array{38:Func{()}} farr
new Array{12:Func{(copy Int x)->(var Int y)}} farr1!
new Array{12:Func{:()}} farr2!
user Array{Func{:()}} ufarr
farr[3] := fun0
farr[3]()
; @ c test-function-object-6
var Func{(copy Int x,
        copy Int y)} fun
; @ g test-function-object-7
func mock()->(var Func{()} f)
    f()
; @ g test-function-object-8
func fun(copy Func?{(copy Int x,
        copy Int y)} fi)->(var Func{:(copy Int x,
        copy Int y)} fo)
    fun(copy _)
func afun(user Array{Func{(copy Int x)->(var Int y)}} in)->(
        owner Array?{Func{:()}} out)
struct Test
    var Func{(copy Int x,
            copy Int y)} fun
    var Array{4:Func{:(copy Int x)->(var Int y)}} afun
    func user meth(copy Func{:(copy Int x,
            copy Int y)} fi)->(var Func{(copy Int x,
            copy Int y)} fo)
; @ c test-function-object-9
var Func{:()} fun
fun := fune
fun()!
; @ ec test-function-object-e0
var Func error
; @ ec test-function-object-e1
var Array{3:Func} error
; @ ec test-function-object-e2
var Func{} error
; @ ec test-function-object-e3
var Func{() } error
; @ ec test-function-object-e4
var Func{()} fun(copy fun1)
; @ ec test-function-object-e5
var Func{()->(var Int x)} fun
fun := fun0
; @ ec test-function-object-e6
var Func{()} fun
fun()
; @ ec test-function-object-e7
var Func{()} fun(copy fun0)
fun := _
; @ ec test-function-object-e8
var Func{()} fun(copy fun0)
if fun?
; @ ec test-function-object-e9
var Func{()} fun(copy fune)
; @ ec test-function-object-e10
var Func{:()} fun(copy fun0)
; @@ test-builtin
; @ c test-builtin-i0
i.str(user ostr!)!
; @ c test-builtin-b0
b := true
; @ c test-builtin-b1
b := false
; @ ec test-builtin-0
c := EOF
; @ c test-builtin-a0
arr!.length()->(var i)
; @ c test-builtin-s0
ostr!.length()->(var i)
; @ c test-builtin-s1
ostr!.clear()
; @ c test-builtin-s2
ostr!.equal(user ostr!)->(var b)
; @ c test-builtin-s3
ostr!.get(copy i)->(var c)!
; @ c test-builtin-s4
ostr!.set(copy i, copy c)!
; @ c test-builtin-s5
ostr!.append(copy c)!
; @ c test-builtin-s6
var String{12} sv
sv.copy(user ostr!)!
; @ c test-builtin-s7
ostr!.concat(user ostr!)!
; @ c test-builtin-s8
ostr!.concat-int(copy i)!
; @ c test-builtin-s9
ostr!.find(user ostr!)->(var i)
; @ c test-builtin-s10
ostr!.has(copy c)->(var b)
; @ c test-builtin-s11
String.set(user ostr!, copy 0, copy 'a')!
; @ c test-builtin-s12
ostr!.max-length()->(var i)
; @ c test-builtin-f0
file-open-read(user ostr!)->(owner fobj)!
; @ c test-builtin-f1
file-open-write(user ostr!)->(owner fobj)!
; @ c test-builtin-f2
file-close(owner fobj!)!
; @ c test-builtin-f3
fobj!.getc()->(var c, var b)!
; @ c test-builtin-f4
fobj!.putc(copy c)!
; @ c test-builtin-f5
fobj!.write(user ostr!)!
; @ c test-builtin-y0
user Array{String} argv(user sys.argv)
; @ c test-builtin-y1
sys.print(user ostr!)!
; @ c test-builtin-y2
sys.println(user ostr!)!
; @ c test-builtin-y3
sys.getchar()->(var c, var b)
; @ c test-builtin-y4
sys.getline(user ostr!)!
; @ c test-builtin-y5
sys.exit(copy i)!
; @ c test-builtin-y6
sys.system(user ostr!)->(var i)!
; @ c test-builtin-y7
sys.getenv(user ostr!, user ostr!)->(var b)!
; @ c test-builtin-y8
sys.stdout.putc(copy c)!
; @ c test-builtin-y9
sys.stdin.getc()->(var c, var b)!
; @ c test-builtin-y10
sys.stderr.putc(copy c)!
; @ ec test-builtin-ef0
var File error
; @ ec test-builtin-ef1
new File error!
; @ ec test-builtin-ef2
File()
; @ ec test-builtin-ef3
user File? f
file-open-read(user "name")->(owner fobj)!
f!.putc(copy 'a')!
; @ ec test-builtin-ef4
user File? f
file-open-write(user "name")->(owner fobj)!
f!.putc(copy 'a')!
; @ ec test-builtin-ef5
user File? f
file-close(owner fobj!)!
f!.putc(copy 'a')!
; @ ec test-builtin-ef6
owner File f(owner fobj!)
file-open-read(user "name")->(owner f)!
; @ ec test-builtin-ey0
var Sys error
; @ ec test-builtin-ey1
new Sys error!
; @ ec test-builtin-ey2
Sys()
; @@ test-general
; @ g test-general-0
user String str
; @ g test-general-1


    #

var Int x
; @ g test-general-2
; comment

var Int x
; @ g test-general-3
~~~ documentation ~~~

var Int x
; @ g test-general-4
[; multi #
 line #
 comment ;]

var Int x
; @ g test-general-5
~~~ multi #
 line    #
 documentation
 confused by ~ or ~~ or ; or ~~ ~ ?
~~~

var Int x
; @ g test-general-6
var String{12} s
user String us(user s)
user String gs(user "global text")
main
    var Int x(copy 6)
    x := 7
; @ tg test-general-7
var String{12} s
user String us(user s)
func fun()
    s.clear()
; @-
module second
test dummy()
; @ tg test-general-8
func fun()
    fun()
main
    fun()
; @-
module test
test test-fun()
; @ eg test-general-e0
error #
; @ ec test-general-e1
1 + 2
; @ ec test-general-e2
return
i := 3
; @ ec test-general-e3
raise!
i := 3
; @ eg test-general-e4
[; comment ;]?
; @ eg test-general-e5
main(
; @ eg test-general-e6
    struct Test
; @ eg test-general-e7
func f()
    x :=
        y
; @ feg test-general-e8
var Int x
; @ eg test-general-e9
var Int name
var Int name
; @ eg test-general-e10
func name()
var Int name
; @ eg test-general-e11
user Error error
; @ eg test-general-e12
var Int x(copy error)
; @ eg test-general-e13
[ ; error
; @@ test-struct
; @ g test-struct-0
struct Test
    var Int x
; @ g test-struct-1
struct Test
    var Int x
; @ g test-struct-2
struct Test1
    var Int x
struct Test2
    var Int x


struct Test3
    var Int x
; @ g test-struct-3
struct Test2(Test1)
    var Int y
struct Test1
    var Int x
; @ g test-struct-4
struct Test
    owner Test? to
    strong Test? ts
    weak Test? tw
; @ eg test-struct-e0
struct(
; @ eg test-struct-e1
struct error
; @ eg test-struct-e2
struct ERror
; @ eg test-struct-e3
struct Error-name
; @ eg test-struct-e4
struct E
; @ eg test-struct-e5
struct Int
; @ eg test-struct-e6
struct Test
struct Test
; @ eg test-struct-e7
struct Test(Base
; @ eg test-struct-e8
struct Test
    error #
; @ feg test-struct-e9
struct Test
; @ eg test-struct-e10
struct Error
; @ eg test-struct-e11
struct Error
    new #
; @ eg test-struct-e12
struct Error
    new()
    new()
; @ eg test-struct-e13
struct Error
    var Int x
    new()->(var Int x)
; @ eg test-struct-e14
struct Error(Error)
    var Int x
; @ eg test-struct-e15
struct Aerror(Berror)
    var Int x
struct Berror(Aerror)
    var Int x
; @@ test-class
; @ g test-class-0
class Base
    var Int x
    owner Base? b
    func inst user stat()
    func dynamic user dyn0()
    func dynamic user ! dyn1()
    func dynamic user dyn2()
class Mid(Base)
    var Int y
    owner Mid? m
    func dynamic user dyn0()
    func dynamic user dyn3()
    func dynamic user ! dyn4()
class Top(Mid)
    var Int z
    owner Top? t
    func dynamic user dyn0()
        base()
    func dynamic user ! dyn1()
        base()!
    func dynamic user dyn3()
        base()
    func dynamic user dyn5()
        base.dyn0()
; @ g test-class-1
class Test
    owner Test? to
    strong Test? ts
    weak Test? tw
    func dynamic user fun()
; @ eg test-class-e0
class(
; @ eg test-class-e1
class Error
    var Int x
; @ eg test-class-e2
class Error
    func error f()
; @ eg test-class-e3
struct Base
    var Int x
    func user meth()
class Error(Base)
    func dynamic user meth()
; @ eg test-class-e4
class Base
    var Int x
    func dynamic user meth()
class Error(Base)
    func inst user meth()
; @ eg test-class-e5
class Base
    var Int x
    func dynamic user meth()
class Error(Base)
    func dynamic user meth(copy Int x)
; @ eg test-class-e6
class Base
    var Int x
    func dynamic user meth()
class Error(Base)
    func dynamic user ! meth()
; @@ test-function
; @ g test-function-0
func name()
; @ g test-function-1
func name(user String self, user String text, copy Int num)
; @ g test-function-2
func name()->(owner String? text, var Int num)
; @ g test-function-3
func name(copy Char param)->(owner String? out)
; @ g test-function-4
func name(user Array{Int} array)
; @ g test-function-5
func name(copy Func{(copy Int x)->(var Int y)} fun)->(var Func{()} joy)
; @ g test-function-6
func name()
    var Int x
; @ g test-function-7
func ! name(user String self, copy Int px, user Array{Char} pu, owner String po)->(
        strong String? oself, var Int ox, weak String? ou, owner String? oo)
    var Int x
    user String? u
    owner String? o
    var String{12} v
    new String{12} n!
    o := String{12}()!
    u := "constant string"
    pu := po[2:6]!
; @ g test-function-8
struct Struct
    owner Struct? s
    owner Array?{Struct} as
    owner Array?{String} astr
class Class
    owner Class? c
    owner Array?{Class} ac
    func dynamic user meth()
func name(
        owner Struct ps,
        owner Class pc,
        owner Array{Struct} pas,
        owner Array{Class} pac)
    owner Struct? s
    owner Class? c
    owner Array?{Struct} as
    owner Array?{Class} ac
    owner Array?{Int} ai
    owner Array?{File} af
    owner Array?{String} astr
; @ g test-function-9
class Test
    var Int x
    func dynamic user meth()
func name()->(owner Test? t)
    t := _
; @ g test-function-10
func name(user Array{Array{String}} ai)->(owner Array?{Array{Int}} ao)
; @ g test-function-m0
main
    var Int x
; @ eg test-function-e0
func(
; @ eg test-function-e1
func name
; @ eg test-function-e2
func Error()
; @ eg test-function-e3
func error_name()
; @ eg test-function-e4
func name()
func name()
; @ eg test-function-e5
var Int name
func name()
; @ eg test-function-e6
func name( )
; @ eg test-function-e7
func name(user)
; @ eg test-function-e8
func name(user String
; @ eg test-function-e9
func name(error Int x)
; @ eg test-function-e10
func name(user String str,user Int x)
; @ eg test-function-e11
func name()-()
; @ feg test-function-e12
func name()
; @ eg test-function-e13
func name()
        var Int x
; @ eg test-function-e14
func name(user Int x)
; @ eg test-function-e15
func name()->(copy Int x)
; @ eg test-function-e16
func name(copy String s)
; @ eg test-function-e17
func name(user Array error)
; @ eg test-function-e18
func name(copy Func error)
; @ eg test-function-e20
func name(
    copy Int x)
; @ eg test-function-e21
func Type.Error.name()
; @ eg test-function-e22
func module.error.name()
; @ eg test-function-e23
func name(copy Int error, copy Int error)
; @ eg test-function-e24
func name(copy Int error)->(var Int error)
; @ eg test-function-e25
var Int error
func name(copy Int error)
; @ eg test-function-e26
func error()
func name(copy Int error)
; @ eg test-function-e27
func error(copy Int error)
; @ eg test-function-e28
func name(copy Int Error)
; @ eg test-function-e29
func name()->(owner String s)
; @ eg test-function-e30
func fun(weak String s)
    s!.clear()
; @ eg test-function-e31
func fun()
    raise!
; @ eg test-function-e32
func fun()
    assert! 1 = 2
; @ eg test-function-e33
func fun()
    assert-error! 1 = 2
; @@ test-members
; @ g test-members-0
struct Test
    var Int x
    weak String? str
; @ g test-members-1
struct Test
    var Int x
    func user name()
        self.x := 2
; @ g test-members-2
struct Test
    var Int x
    func user name()
        var Int x
        x := self.x
; @ g test-members-3
struct Test
    ; comment
    var Int x
; @ g test-members-4
struct Test
    ~~~ documemtation ~~~
    var Int x
; @ g test-members-5
struct Test
    [; multi #
    line #
    comment ;]
    var Int x
; @ g test-members-6
struct Test
    ~~~ multi #
    line #
    documemtation
    ~~~
    var Int x
; @ g test-members-7
var Int name
func fun()
struct Test1
    var Int name
    func user fun()
struct Test2
    var Int fun
    func user name()
; @ g test-members-8
struct Test
    var Int x
    func user fun()
        if self.x > 3
            self.x := 3
        loop
            for n in 4
                self.x += n
            while self.x < 30
; @ g test-members-9
struct Test
    var Int x
    func user fun() _
func Test.fun()
    self.x := 3
; @ g test-members-10
func Test.fun(user String s)->(var Int x)
    s.length()->(var x)
struct Test
    var Int x
    func user fun(user String s)->(var Int x) _
; @ g test-members-11
struct Test
    var Int x
    new(copy Int x) _
func Test.new(copy Int x)
    self.x := x
; @ eg test-members-e0
struct Test
    var Int name
    var Int name
; @ eg test-members-e1
struct Test
    func user name()
    var Int name
; @ eg test-members-e2
struct Test
    func user name()
    func user name()
; @ eg test-members-e3
struct Test
    var Int name
    func user name()
; @ eg test-members-e4
struct Test
    var Int x
    func user meth()
        owner Test? error
        error := self
; @ eg test-members-e5
struct Test
    var Int x
    func user name() #
; @ eg test-members-e6
struct Test
    var Int x
    func user error.name()
; @ eg test-members-e7
struct Test
    var Int x
    func user fun()
func Test.fun()
; @ eg test-members-e8
func Test.fun()
struct Test
    var Int x
    func user fun() _
func Test.fun()
; @ eg test-members-e9
struct Test
    var Int x
    func user fun()
        self..x := 3
; @ ec test-members-e10
Test.num
; @ eg test-members-e11
struct Test
    var Int x
    func error()
; @ eg test-members-e12
struct Test
    var Int x
    func error?()
; @ eg test-members-e13
struct Test
    var Int x
    func user fun()->(var Int x) _
func Test.fun()
; @ eg test-members-e14
struct Test
    var Int x
    func user ! fun() _
func Test.fun()
; @@ test-return
; @ g test-return-0
func name()
    return
; @ g test-return-1
func ! name()
    raise!
; @ g test-return-2
func ! name()
    raise! "some error"
; @ g test-return-3
func ! name(user Array{String} arr)
    raise! arr[3]!
; @ c test-return-4
weak String? s
raise! s!
; @ ec test-return-e0
return()
; @ ec test-return-e1
raise!()
; @ ec test-return-e2
raise! 2
; @ ec test-return-e3
raise! _
; @ ec test-return-e4
raise
; @@ test-code-variables
; @ c test-code-variables-0
var Int x
; @ c test-code-variables-1
user String? s
; @ c test-code-variables-2
owner Array?{Int} a
; @ c test-code-variables-3
user Test? tt
; @ c test-code-variables-4
var String{12} s
; @ c test-code-variables-5
var Array{12:Int} a
; @ c test-code-variables-6
var Array{12:Test} a
; @ c test-code-variables-7
var Array{12:String{7}} sa
; @ c test-code-variables-8
new String{12} s!
so := s!
; @ c test-code-variables-9
var Array{12:Ta} a
; @ c test-code-variables-10
new Array{12:Int} a!
; @ c test-code-variables-11
new Array{12:String{7}} sa!
; @ c test-code-variables-12
var Array{3:Array{4:String{5}}} aa
; @ c test-code-variables-13
new Array{3:Array{4:String{5}}} aa!
; @ g test-code-variables-14
func ! fun()
    var String{4} sv
    if 1 > 2
        user Array{Char} su(user sv[1:2]!)
; @ ec test-code-variables-e0
var Int
; @ ec test-code-variables-e1
var Int Error
; @ ec test-code-variables-e2
var Int errorName
; @ ec test-code-variables-e3
var Int name
var Int name
; @ ec test-code-variables-e4
var Int name
loop
    var Int x
    loop
        var Int name
; @ eg test-code-variables-e5
var Int name
func mock()
    var Int name
; @ eg test-code-variables-e6
func name()
func mock()
    var Int name
; @ eg test-code-variables-e7
struct Test
    var Int x(1)
; @ ec test-code-variables-e8
new
; @ ec test-code-variables-e9
var Array{i:Int} error
; @ ec test-code-variables-e10
var Int error--name
; @ ec test-code-variables-e11
var Int x #
; @@ test-initialize
; @ c test-initialize-0
tb := Tb(copy i)!
; @ c test-initialize-1
str := String{arr![0]}()!
; @ c test-initialize-2
owner Array{Int} a(owner Array{arr![0]:Int}()!)
; @ c test-initialize-3
owner Array{Test} a(owner Array{arr![0]:Test}()!)
; @ c test-initialize-4
owner Array{String} sa(owner Array{arr![0]:String{arr![1]!}}()!)
; @ c test-initialize-5
var Int x(copy arr![0])
; @ c test-initialize-6
user String? s(user ostr)
; @ c test-initialize-7
var String{12} s(user "some string")!
; @ c test-initialize-8
new String{i} s(user ostr!)!
; @ c test-initialize-9
user Test? tt(user tc!)
; @ c test-initialize-10
var Tc tt(copy 3)!
; @ c test-initialize-11
new Tc tt(copy 3)!
; @ c test-initialize-12
tb := Tc(copy 3)!
; @ c test-initialize-13
user Tb? tt(user tb)
; @ c test-initialize-14
owner Ta? ota(owner tb)
; @ c test-initialize-15
owner Array{Array{String}} sa(owner Array{arr![0]:Array{arr![1]!:String{arr![2]!}}}()!)
; @ g test-initialize-16
func get()->(owner File? a)
    owner File? b(owner get())
; @ c test-initialize-17
owner Test? ot(owner to)
strong Test? st(strong ot!)
; @ c test-initialize-18
s-var Tc tt(copy 3)!
; @ c test-initialize-19
new Test t1!
s-var Test t2!
; @ g test-initialize-20
struct Test
    var Int x
    new(copy Int x)
func fun()
    var Test t(copy 3)
; @ g test-initialize-21
struct Base
    var Int x
    new()
        self.x := 2
struct Test(Base)
    var Int y
    new()
        base()
        self.y := 3
; @ ec test-initialize-e0
Int()
; @ ec test-initialize-e1
var String s
; @ ec test-initialize-e2
var Array{4:String} sa
; @ ec test-initialize-e3
new String s!
; @ ec test-initialize-e4
String()
; @ ec test-initialize-e5
user Array a
; @ ec test-initialize-e6
new Array a!
; @ ec test-initialize-e7
Array()
; @ ec test-initialize-e8
var Array{23} a
; @ eg test-initialize-e9
struct Test{Generic}
    owner Array{Generic} arr
; @ ec test-initialize-e10
var Array{1
; @ ec test-initialize-e11
var String{12
; @ ec test-initialize-e12
var Array{error:Int} a
; @ ec test-initialize-e13
var Array{"12":Int} a
; @ ec test-initialize-e14
user Int x
; @ ec test-initialize-e15
new Int x!
; @ ec test-initialize-e16
var Array{4:Int} a(copy 1)
; @ ec test-initialize-e17
var Bool x(var 1)
; @ ec test-initialize-e18
var Int x(var 1, var 2)
; @ eg test-initialize-e19
struct Test
    var Int x
func mock()
    Test(copy 1)
; @ ec test-initialize-e20
var Int x(user 3)
; @ ec test-initialize-e21
owner String? s(user so)
; @ ec test-initialize-e22
owner String? s(owner str)
; @ ec test-initialize-e23
var Array{1:Int:Int} a
; @ ec test-initialize-e24
owner Test? ot(owner tb)
; @ ec test-initialize-e25
user String s
s.clear()
; @ ec test-initialize-e26
user String s(user _)
; @ ec test-initialize-e27
user String s(user str)
; @ ec test-initialize-e28
i := error
var Int error
; @ ec test-initialize-e29
var Int error(copy error)
; @ ec test-initialize-e30
error := 3
var Int error
; @ ec test-initialize-e31
if b
    var Int error
i := error
; @ ec test-initialize-e32
new Test? a!
; @ ec test-initialize-e33
to := Test?()
; @ ec test-initialize-e34
to := Test()
; @ ec test-initialize-e35
var Tb tt(copy 3)
; @ ec test-initialize-e36
user String s!
; @ eg test-initialize-e37
user String s!
; @ eg test-initialize-e38
struct Test
    weak String s!
; @@ test-comment
; @ c test-comment-0
; comment

var Int x
; @ c test-comment-1
~~~ documemtation ~~~

var Int x
; @ c test-comment-2
[; multi #
line #
comment ;]

var Int x
; @ c test-comment-3
~~~ multi #
line #
documemtation
~~~

var Int x
; @@ test-block
; @ c test-block-0
block
    new Test tt!
    i += 1
; @ c test-block-1
block
    return
; @ c test-block-2
block
    var Int n
block
    var Int n
; @ ec test-block-e0
block i
; @ ec test-block-e1
block
    break
; @ ec test-block-e2
block
    while b
; @ ec test-block-e3
block
    new Test tt!
tt.meth()
; @ ec test-block-e4
user Test tt
block
    var Test tvar
    tt := tvar
tt.meth()
; @@ test-if-else
; @ c test-if-else-0
if t!.num > 3
    i -= 2
; @ c test-if-else-1
if i > 3
    i -= 2
else
    i += 1
; @ c test-if-else-2
if i > 3
    i -= 3
else-if t!.num > 2
    i -= 2
else-if t!.num > 1
    i -= 1
else
    i += 1
; @ c test-if-else-3
if b
    return
i := 3
; @ c test-if-else-4
if b and
        b
    i += 1
; @ c test-if-else-5
if b
    var String{4} sa
    if b
        var String{4} sb
    else-if b
        var String{4} sc
    else
        var String{4} sd
else-if b
    var String{4} se
else
    var String{4} sf
; @ ec test-if-else-e0
if 3
; @ ec test-if-else-e1
if b
    error
; @ ec test-if-else-e2
if b
    i := 0
else
    error
; @ ec test-if-else-e3
if b
    i := 0
else-if b
    error
; @ ec test-if-else-e4
if b
    return
    i := 3
; @ ec test-if-else-e5
if()
; @ ec test-if-else-e6
else
; @ ec test-if-else-e7
if false
    ; ...
else #
; @ ec test-if-else-e8
else-if b
; @ ec test-if-else-e9
if false
    ; ...
else-if()
; @ feg test-if-else-e10
func error()
    if b
; @@ test-loop
; @ c test-loop-0
loop
    var Int x
    while b
; @ c test-loop-1
loop
    break
; @ c test-loop-2
loop
    while t!.num > 3
; @ c test-loop-3
loop
    continue
    while b
; @ c test-loop-4
loop
    if true
        while false
; @ c test-loop-5
loop
    var String{4} sa
    while b
    break
    continue
    if b
        return
    loop
        var String{4} sb
        while b
        break
        continue
        if b
            return
        loop
            var String{4} sc
            while b
            break
            continue
            if b
                return
; @ c test-loop-6
loop! 1024
    while b
; @ c test-loop-7
try
    loop ostr.length() + 2
        while b
; @ c test-loop-8
loop-infinite
    i += 1
; @ c test-loop-9
loop
    loop
        loop
            return
; @ ec test-loop-e0
loop!(
; @ ec test-loop-e1
while true
; @ ec test-loop-e2
continue
; @ ec test-loop-e3
loop
    while 2
; @ ec test-loop-e4
loop
    error
; @ ec test-loop-e6
loop
    while i := 3
; @ ec test-loop-e7
loop
    while
; @ ec test-loop-e8
loop
    continue error
; @ ec test-loop-e9
break
; @ ec test-loop-e10
loop
    break error
; @ ec test-loop-e11
loop
    i += 1
; @ ec test-loop-e12
loop
    loop
        break
; @ ec test-loop-e13
try
    loop! 64
        while b
; @@ test-for-loop
; @ c test-for-loop-0
for n in 5
    i += n
; @ c test-for-loop-1
for n in t!.num:ostr!.length() + 2
    i += n
; @ c test-for-loop-2
for ch in ostr!
    c := ch
; @ c test-for-loop-3
for n in arr!
    i += n
; @ c test-for-loop-4
for s in sarr!
    s.clear()
; @ c test-for-loop-5
var Int n
for n in 5
    i += n
; @ c test-for-loop-6
for n in 5
    i += n
for n in 7
    i += n
; @ c test-for-loop-7
for n in 1 +
        2
    i += n
; @ c test-for-loop-8
for n in 6
    var String{4} sa
    break
    continue
    if b
        return
    for ch in ostr!
        var String{4} sb
        break
        continue
        if b
            return
; @ c test-for-loop-9
user String s(user "text")
for ch in s
    c := ch
; @ c test-for-loop-10
var Array{3:String{4}} sa
for s in sa
    s.clear()
; @ c test-for-loop-11
for _ in 2:6
    i += 1
; @ c test-for-loop-12
for _ in ostr!
    i += 1
; @ c test-for-loop-13
repeat i + 4
    i += 1
; @ ec test-for-loop-e0
for(
; @ ec test-for-loop-e1
for n
; @ ec test-for-loop-e2
for n error
; @ ec test-for-loop-e3
for n in fun0()
; @ ec test-for-loop-e4
for n in str:8
; @ ec test-for-loop-e5
for n in 5
    error
; @ ec test-for-loop-e6
var Int n
for n in arr!
    i += n
for n in sarr!
; @ ec test-for-loop-e7
for n in 7
    i += 1
var Int n
; @@ test-testing
; @ c test-testing-a0
assert! t!.num = 2
; @ c test-testing-a1
assert-error! t.num
; @ c test-testing-a2
assert-error! fune()
; @ c test-testing-a3
assert-error! t.num, "expected error"
; @ c test-testing-a4
assert-error! fune(), "expected error in the function"
; @ c test-testing-a5
assert-error! t.num,
        "expected error in new line"
; @ c test-testing-a6
if b
    var String{4} s
    assert! b
    assert-error! s[i:2]
    repeat 3
        assert-error! s[i:2]
; @ g test-testing-m0
func ! fun()
    fun()!
mock ! fun()
    raise!
; @ g test-testing-m1
mock fun()
func fun()
    fun()
; @ g test-testing-m2
mock Test.meth(copy Int x)
struct Test
    var Int x
    func user meth(copy Int x)
        self.meth(copy x)
; @ g test-testing-m3
mock Test.meth(copy Int x)
class Test
    var Int x
    func dynamic user meth(copy Int x)
        self.meth(copy x)
; @ g test-testing-m4
func fun(copy Int x)->(var Int y)
mock fun(copy Int x)->(var Int y)
    fun.mocked(copy x)->(var y)
    fun.active := false
    fun(copy x)->(var y)
    fun.active := true
; @ g test-testing-m5
struct Test
    var Int x
    func user meth(copy Int x)->(var Int y)
        self.meth(copy x)->(var y)
mock Test.meth(copy Int x)->(var Int y)
    self.meth.mocked(copy x)->(var y)
    Test.meth.mocked(user self, copy x)->(var y)
    self.meth.active := false
    Test.meth(user self, copy x)->(var y)
    Test.meth.active := true
; @ g test-testing-m6
class Test
    var Int x
    func dynamic user meth(copy Int x)->(var Int y)
        self.meth(copy x)->(var y)
mock Test.meth(copy Int x)->(var Int y)
    Test.meth.mocked(user self, copy x)->(var y)
    Test.meth.active := false
    Test.meth(user self, copy x)->(var y)
    Test.meth.active := true
; @ g test-testing-m7
func ! fun()
    sys.print(user "mock print")!
    sys.print.mocked(user "really print")!
    Sys.print.active := false
    sys.print.active := true
mock ! Sys.print(user Array{Char} text)
; @ g test-testing-m8
struct Test
    var Int x
    new(copy Int x)
mock Test.new(copy Int x)
func fun()
    var Test t(copy 2)
; @ tg test-testing-t0
func fun0()
    var Int x(copy 4)
    x += 1
    var Int y(copy 5)
    y := x
    if y > 3
        y := 3
    else-if y < 0
        y := 0
    else
        y += 1
    try
        x := 0
        sys.print(user "text")
        y := 0
    catch
        x := 1
        x := 2
    if x > 3
        return
    else
        x := 3
    loop
        while x > 1
        if x = 5
            continue
    for n in 3
        x += y
; @-
module ut
func fun1()
    fun0()
test fun2()
    fun1()
; @ tg test-testing-t1
func fun()
    var Int x
main
    fun()
; @-
module second
test fun0()
test fun1()
; @ g test-testing-mg0
mock Test.delete()
    var Ref? r(copy self)
struct Test
    weak String? s
; @ g test-testing-mg1
mock delete()
    var Ref? r(copy self)
main
; @ g test-testing-mg2
mock new()->(var Bool allocate-success)
    allocate-success := false
main
; @ c test-testing-r0
var Ref r
; @ c test-testing-r1
var Ref r
r := ostr
; @ c test-testing-r2
var Ref r
r := _
; @ c test-testing-r3
var Ref r(copy ostr)
; @ c test-testing-r4
var Ref r
assert! r is r
; @ ec test-testing-e0
assert! 3
; @ ec test-testing-e1
assert! error
; @ ec test-testing-e2
assert-error! error
; @ eg test-testing-e3
test fun(copy Int x)
; @ eg test-testing-e4
test fun()->(copy Int x)
; @ eg test-testing-e5
mock error()
; @ eg test-testing-e6
mock Error.fun()
; @ eg test-testing-e7
struct Test
    var Int x
mock Test.error()
; @ eg test-testing-e8
mock fun(owner String s)
func fun(user String s)
; @ eg test-testing-e9
mock fun(user Int s)
func fun(user String s)
; @ eg test-testing-e10
mock fun(user Array{Char} a)
func fun(user Array{Int} a)
; @ ec test-testing-e11
assert #
; @ ec test-testing-e12
assert-error #
; @ eg test-testing-e13
mock()
; @ eg test-testing-e14
func fun()
mock fun()
mock fun()
; @ eg test-testing-e15
struct Test
    var Int x
    func user fun()
mock Test.fun()
mock Test.fun()
; @ eg test-testing-e16
mock delete()
mock delete()
; @ eg test-testing-e17
struct Test
    var Int x
mock Test.delete()
mock Test.delete()
; @ ec test-testing-e18
assert-error! t.num , "error"
; @ ec test-testing-e19
assert-error! t.num,"error"
; @ ec test-testing-e20
assert-error! t.num,  "error"
; @ ec test-testing-e21
assert-error! t.num, error
; @ eg test-testing-e22
mock new()->(var Bool res)
mock new()->(var Bool res)
; @ eg test-testing-e23
mock new()->(var Int x)
; @ eg test-testing-e24
mock new()
; @ eg test-testing-e25
mock new(copy Int x)->(var Bool res)
; @ eg test-testing-e26
mock new()->(var Bool res, var Int x)
; @ eg test-testing-e27
mock delete(copy Int x)
; @ eg test-testing-e28
mock delete()->(copy Int x)
; @ eg test-testing-e29
func fun()
mock fun()
    fun.error
; @ eg test-testing-e30
class Test
    var Int x
    func dynamic user meth()
mock Test.meth()
    self.meth.mocked()
; @ eg test-testing-e31
test
; @ eg test-testing-e32
struct Test
    owner String s
    new!()
        self.s := String{12}()!
mock ! Test.new()
; @ eg test-testing-e33
test ! fun()
; @ ec test-testing-e34
assert-error! fun0()
; @ ec test-testing-e35
assert-error! t!.num
; @ ec test-testing-e36
assert-error! t!
; @@ test-native
; @ g test-native-i0
native include "native.h"
; @ g test-native-i1
struct Test
    var Int x
native include "first.h"
func fun()
native include "second.h"
; @ g test-native-f0
native func external()
func call()
    external()
; @ g test-native-f1
class Test
    var Int x
    func dynamic user meth()
native func external(
        copy Int i, user String? s, user Array?{Int} a, user Test? t)->(
        copy Int res)
func call()
    var Int i
    user String? s
    user Array?{Int} a
    user Test? t
    i := external(copy 5, user s, user a, user t)
    i := (2 * external(copy 5, user s, user a, user t)) + 3
    external(copy 5, user s, user a, user t)
; @ g test-native-f2
native func external() "SOME_External_func"
func call()
    external()
; @ g test-native-f3
struct Test
    var Int x
native func external()->(user Test? t)
func call()
    user Test? t
    t := external()
    external()
; @ g test-native-v0
native var Int x
func use()
    x := 2
; @ g test-native-v1
native var Int x "SOME_External_var"
func use()
    x := 2
; @ g test-native-c0
native const Int VALUE
func get()->(var Int x)
    x := VALUE
; @ g test-native-c1
native const Int VALUE "SOME_External_const"
func get()->(var Int x)
    x := VALUE
; @ g test-native-t0
native type Native
native func external(copy Native n)->(copy Native no)
func call()
    var Native n
    n := external(copy n)
; @ g test-native-t1
native type Native "SOME_External_type"
native func external(copy Native n)->(copy Native no) "SOME_External_func"
func call()
    var Native n
    n := external(copy n)
; @ g test-native-b0
var Int x
native code "#define HAS_SOME_DEFINE"
var Int y
; @ c test-native-b1
native "#ifdef __UNIX__"
io := 3
native "#else"
io := 4
native "#endif"
; @ eg test-native-e0
native()
; @ eg test-native-e1
native error
; @ eg test-native-e2
native error #
; @ eg test-native-ei0
native include native.h
; @ eg test-native-ef0
native func error()
native func error()
; @ eg test-native-ef1
native func ! error()
; @ eg test-native-ef2
native func error()->(copy Int a, copy Int b)
; @ eg test-native-ef3
native func error()->(owner String? s)
; @ eg test-native-ef4
native func error()->(var Int s)
; @ eg test-native-ef5
native func error()->(s-var String? s)
; @ eg test-native-ef6
native func error()->(weak String? s)
; @ eg test-native-ef7
native func error()->(strong String? s)
; @ eg test-native-ef8
native func error(owner String s)
; @ eg test-native-ef9
native func error(weak String s)
; @ eg test-native-ef10
native func error(strong String s)
; @ eg test-native-ef11
native func error(s-var String s)
; @ eg test-native-ef12
native func fun()->(copy Int res)
func error(copy Int i)
    fun()->(copy i)
; @ eg test-native-ef13
native func fun()->(copy Int res) error
; @ eg test-native-ef14
native func error()->(user String? s)
; @ eg test-native-ef15
native func error()->(user Array?{Int} a)
; @ eg test-native-ef16
struct Error
    var Int x
native func error()->(user Error s)
; @ eg test-native-ef17
class Error
    var Int x
    func dynamic user meth()
native func error()->(user Error? e)
; @ eg test-native-ev0
native var String s
; @ eg test-native-ev1
native var Int x error
; @ eg test-native-ec0
native const Int VALUE error
; @ eg test-native-ec1
native const Int VALUE
var String{VALUE} error
; @ eg test-native-et0
native type Native error
; @ eg test-native-eb0
native code #define error
; @ ec test-native-eb1
native #ifdef error
; @@ test-parameter-type
; @ g test-parameter-type-0
struct Test{Generic}
    weak Generic? item
    func user ! set(weak Generic item)
        weak Generic x(weak item)
        self.item := x
        new Test{Generic} t!
        t.item := self.item
        self.item := t.item
; @ g test-parameter-type-1
struct Test{Generic}
    owner Generic? item
    func user get()->(user Generic? item)
        item := self.item
; @ g test-parameter-type-2
struct Test{First:Second:Third}
    weak First? first
    weak Second? second
    weak Third? third
    func user set(weak First first, weak Second second, weak Third third)
        self.first := first
        self.second := second
        self.third := third
func use(weak File first, weak Sys second, weak File third)
    var Test{File:Sys:File} t
    t.first := first
    t.second := second
    t.third := third
    t.set(weak first, weak second, weak third)
; @ g test-parameter-type-3
struct Base
    var Int x
struct Test{Generic}(Base)
; @ c test-parameter-type-4
d!.item := t
; @ c test-parameter-type-5
t := d!.item
; @ g test-parameter-type-6
struct Test{Generic}
    var Int x
    var Func{(user Generic item, copy Func{(user Generic item)} fun)} fun
    func user meth(copy Func{(user Generic item,
            copy Func{(user Generic item)} fun)} fun)
        var Func{(user Generic item, copy Func{(user Generic item)} funa)} funv
; @ c test-parameter-type-8
var Array{5:Data{Test}} ad
t := ad[2].item
; @ c test-parameter-type-10
d!.set(owner _)
; @ c test-parameter-type-11
var Data{Data{Data{Test}}} dr
t := dr.item!.item!.item
; @ c test-parameter-type-12
d!.set(owner to)
; @ c test-parameter-type-13
d!.get()->(weak t)
d!.get()!.meth()
; @ c test-parameter-type-14
var Data dg
; @ c test-parameter-type-15
user Data? dg(user d!)
; @ c test-parameter-type-16
Data{Test}.set(user d!, owner to)
; @ g test-parameter-type-17
struct Test{Generic}
    weak Test?{Generic} next
    func user meth(weak Test{Generic} next)->(user Test?{Generic} out)
        self.next := next
        out := self
; @ c test-parameter-type-18
var Data{Tb} dt
dt.item := tc
ta := dt.item
owner Tc? otc
dt.set(owner otc)
dt.get()->(weak ta)
i := dt.get()!.numa
fun7(weak dt.item)->(weak dt.item)
user Tb? tb2(user dt.item!)
tb2 := dt.item!
; @ g test-parameter-type-19
struct Base{Generic}
    weak Generic? item
    func user get()->(weak Generic? item)
struct Test(Base{File})
    func user set(weak File? f)
        self.item := f
        self.get()->(weak f)
func ! fun(user Test test, weak File? f)
    test.item := f
    test.set(weak f)
    f := test.item
    test.get()->(weak f)
    test.get()!.putc(copy 'a')!
; @ g test-parameter-type-20
class Base{Param}
    weak Param? item
    func dynamic user set(weak Param? item)
    func dynamic user get()->(weak Param? item)
class Test{Generic}(Base{Generic})
    func dynamic user set(weak Generic? item)
    func dynamic user get()->(weak Generic? item)
func ! mock(weak Test{File} test, weak File? f)
    test!.set(weak f)
    test!.get()->(weak f)
    test!.get()!.putc(copy 'a')!
; @ g test-parameter-type-21
struct Test{Param}
    weak Param? item
    func user meth(weak Param? in)->(weak Param? out) _
func Test.meth(weak Param? in)->(weak Param? out)
    weak Param? p(weak in)
    out := p
    self.item := p
    self.meth(weak p)->(weak p)
; @ eg test-parameter-type-eg0
struct Test{First:Second:Third
; @ eg test-parameter-type-eg1
struct Test{Generic}
    var Generic error
; @ eg test-parameter-type-eg2
struct Test{Generic}
    weak Generic? item
    func user meth(copy Generic error)
; @ eg test-parameter-type-eg3
struct Test{Generic}
    weak Generic? item
    func user meth(weak String s)
        self.item := s
; @ eg test-parameter-type-eg4
struct Test{Generic}
    weak Generic? item
    func user ! meth()->(user String? s)
        s := self.item!
; @ eg test-parameter-type-eg5
struct Test{Generic}
    weak Generic? item
    func user meth()
        var Generic error
; @ eg test-parameter-type-eg6
struct Test{First:Second}
    weak First? first
    weak Second? second
    func user meth()
        self.first := self.second
; @ eg test-parameter-type-eg7
struct Test{error}
    var Int x
; @ eg test-parameter-type-eg11
struct Test{First:Second:Third}
    weak First first
    weak Second second
    weak Third third
func meth(user Test{File:File} t)
    user Test{File:File:File} error(user t)
; @ eg test-parameter-type-eg12
struct Base{Param}
    weak Param item
struct Error(Base)
; @ eg test-parameter-type-eg13
struct Base
    weak Int x
struct Error(Base{File})
; @ eg test-parameter-type-eg14
struct Base{Param}
    weak Param item
struct Error(Base{File:File})
; @ eg test-parameter-type-eg15
struct Base{Param0:Param1}
    weak Param0 item0
    weak Param1 item1
struct Error(Base{File})
; @ ec test-parameter-type-ec0
var Data{Int} error
; @ ec test-parameter-type-ec1
var Data{File:File} error
; @ ec test-parameter-type-ec2
var Data{Error} error
; @ ec test-parameter-type-ec3
var Char{File} error
; @ ec test-parameter-type-ec4
var Data dg
str := dg.item!
; @ ec test-parameter-type-ec5
s-var Data dg!
d := dg
; @ ec test-parameter-type-ec6
str := d!.item!
; @ ec test-parameter-type-ec7
var Data{Array{Int}} error
; @ ec test-parameter-type-ec8
var Data{String} error
; @@ test-parameter-inheritance
; @ g test-parameter-inheritance-0
struct Base{Generic}
    weak Generic? item
struct Test(Base{File})
    func user ! set(weak File f)
        self.item := f
        Test.set(user Test()!, weak f)!
func use(weak File f)
    var Test t
    t.item := f
; @ g test-parameter-inheritance-1
struct Base{Generic}
    weak Generic? item
struct Test{Param}(Base{Param})
    func user ! set(weak Param i, weak File f)
        self.item := i
        Test{File}.set(user Test{File}()!, weak f, weak f)!
func use(weak File f)
    var Test{File} t
    t.item := f
; @ g test-parameter-inheritance-2
struct Base{Pbase}
    weak Pbase? item
    func user set(weak Pbase i)
struct Mid{Pmid}(Base{Pmid})
    func user set(weak Pmid i)
struct Top(Mid{File})
    func user set(weak File f)
        base(weak f)
        self.item := f
struct Test(Top)
    func user ! set(weak File f)
        base(weak f)
        self.item := f
        Top.set(user Top()!, weak f)
        Test.set(user Test()!, weak f)!
        Mid{File}.set(user Top()!, weak f)
func use(weak File f)
    var Test t
    t.item := f
; @ g test-parameter-inheritance-3
struct Base{Generic}
    weak Generic? item
struct Test{Generic}(Base{Generic})
    func user ! set(weak Generic i, weak File f)
        self.item := i
        Test{File}.set(user Test{File}()!, weak f, weak f)!
func use(weak File f)
    var Test{File} t
    t.item := f
; @ g test-parameter-inheritance-4
struct Base{First:Second}
    weak First? first
    weak Second? second
struct Mid{Param:Third}(Base{Param:Sys})
    weak Third? third
    func user set(weak Param first, weak Sys second, weak Third third)
        self.first := first
        self.second := second
        self.third := third
struct Top{Generic}(Mid{Generic:File})
    func user set(weak Generic first, weak Sys second, weak File third)
        self.first := first
        self.second := second
        self.third := third
struct Test(Top{File})
    func user set(weak File first, weak Sys second, weak File third)
        self.first := first
        self.second := second
        self.third := third
func use(weak File first, weak Sys second, weak File third)
    var Test t
    t.first := first
    t.second := second
    t.third := third
; @ g test-parameter-inheritance-5
struct First{FirstGeneric}
    weak FirstGeneric? item
struct Second{SecondGeneric}
    weak SecondGeneric? item
struct Test{Generic}(First{Second{Generic}})
    func user ! set(weak Generic g, weak Second{Generic} sg)
        self.item := sg
        self.item!.item := g
func ! use(weak File f, weak Second{File} ff)
    var Test{File} t
    t.item := ff
    t.item!.item := f
; @ g test-parameter-inheritance-6
struct BaseGen{FirstGeneric}
    weak FirstGeneric? item
struct TestGen{SecondGeneric}(BaseGen{SecondGeneric})
struct Base
    var Int x
struct Test(Base)
func test()
    user BaseGen?{Base} bb
    user BaseGen?{Test} bt
    user TestGen?{Base} tb
    user TestGen?{Test} tt
    bb := tb
    bt := tt
    bb := bt
    tb := tt
    bb := tt
; @ g test-parameter-inheritance-7
struct Base{Generic}
    weak Generic? first
struct Mid{First:Second}(Base{First})
    weak Second? second
struct Top{Generic}(Mid{Sys:Generic})
func fun(user Top?{File} t)
    user Mid?{Sys:File} m
    m := t
; @ eg test-parameter-inheritance-e0
struct Base{Generic}
    weak Generic item
struct Test{Param}(Base{Param})
    weak Generic error
; @ eg test-parameter-inheritance-e1
struct Base{Generic}
    weak Generic? item
struct Test(Base{File})
    func user set(weak String error)
        self.item := error
; @ eg test-parameter-inheritance-e2
struct Base{Generic}
    weak Generic? item
struct Test{Param}(Base{Param})
    func user set(weak String error)
        self.item := error
; @ eg test-parameter-inheritance-e3
struct Base{Pbase}
    weak Pbase? item
struct Mid{Pmid}(Base{Pmid})
struct Top(Mid{File})
struct Test(Top)
    func user set(weak String error)
        self.item := error
; @@ test-error-handling
; @ c test-error-handling-0
if-error i := t.num
    i := 0
; @ c test-error-handling-1
if-error fune()
    i := 0
else
    io := i
; @ c test-error-handling-2
if-ok i := t.num
    io := i
else
    i := 0
; @ c test-error-handling-3
if b
    io := 0
else-if-error fune()
    i := 0
else
    io := i
; @ c test-error-handling-4
if b
    io := 0
else-if-ok i := t.num
    io := i
else
    i := 0
; @ g test-error-handling-5
func fun(weak String s)->(var Bool fail)
    if-error s.clear()
        fail := true
; @ ec test-error-handling-e0
if-error t.num
    i := 0
; @ ec test-error-handling-e1
if-ok t.num
else
    i := 0
; @ ec test-error-handling-e2
if-error fun0()
    i := 0
; @ ec test-error-handling-e3
if-ok i := t.num
; @ ec test-error-handling-e4
if-error i := t.num
; @ ec test-error-handling-e5
if-ok i := t.num
else
; @ ec test-error-handling-e6
if-error i := t!.num
    i := 0
; @@ test-try-catch
; @ c test-try-catch-0
try
    t.num := 1
    fun0()
catch
    i := t!.num
    fun4(copy 2)
; @ c test-try-catch-1
try
    t.num := 1
    fun0()
; @ c test-try-catch-2
try
    t.num := 1
    try
        fune()
    catch
        fun4(copy 2)
catch
    try
        i := arr[3]
    catch
        i := t!.num
; @ c test-try-catch-3
try
    var String{4} sa
    try
        s-var String{4} sb
    catch
        s-var String{4} sc
catch
    var String{4} sd
    try
        s-var String{4} se
    catch
        var String{4} sf
; @ g test-try-catch-4
func fun(weak String s)
    try
        s.clear()
        assert true
        assert-error s.clear()
        raise
; @ ec test-try-catch-e0
try()
; @ ec test-try-catch-e1
catch
; @ ec test-try-catch-e2
try
catch()
; @ ec test-try-catch-e3
try
; @ ec test-try-catch-e4
try
    fune()
catch
; @ ec test-try-catch-e5
try
    fune()
i := 2
catch
    i := 3
; @ ec test-try-catch-e6
try
    i := 1
; @ ec test-try-catch-e7
try
    fune()!
; @ ec test-try-catch-e8
try
    assert! true
; @@ test-for-each
; @ g test-for-each-0
struct TestIterator
    var Int counter
    new(copy Int count)
    func user step()->(var Int num, var Bool has-data)
func ! fun()->(var Int i)
    for n in TestIterator(copy 6)!
        var String{4} s
        i := n
; @ g test-for-each-1
struct TestIterator
    owner String? value
    func user step()->(user String? text, var Bool has-data)
        text := self.value
func fun(user TestIterator iter)
    user String? t
    user String? s
    for t in iter
        s := t
; @ g test-for-each-2
struct TestIterator{Generic}
    weak Generic? item
    func user ! step()->(user Generic? item, var Bool has-data)
        item := self.item!
class Test
    var Int x
    func dynamic user fun()
func ! fun(user TestIterator{File} fiter, user TestIterator{Test} titer)
    user File? of
    user Test? ot
    for f in fiter!
        of := f
    for t in titer!
        ot := t
; @ g test-for-each-3
class TestIterator{Generic}
    weak Generic? item
    func dynamic user ! step()->(user Generic? item, var Bool has-data)
        item := self.item!
func ! f-mock(user TestIterator{File} iter)
    user File? f
    for t in iter!
        f := t
; @ g test-for-each-4
struct TestIterator
    owner String? value
    func user step()->(strong String? text, var Bool has-data)
        if-error text := String{12}(user self.value)
            text := _
func fun(user TestIterator iter)
    owner String? s
    for t in iter
        s := t
; @ g test-for-each-5
struct TestIterator
    owner String? value
    func user step()->(user String? text, var Bool has-data)
        text := self.value
func fun(user TestIterator iter)
    var Int x
    for _ in iter
        x += 1
; @ eg test-for-each-e0
struct TestIterator
    var Int num
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e1
struct TestIterator
    var Int num
    func user step(user Int x)->(var Int num, var Bool has-data)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e2
struct TestIterator
    var Int num
    func user step()
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e3
struct TestIterator
    var Int num
    func user step()->(var Int num)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e4
struct TestIterator
    var Int num
    func user step()->(var Int num, var Bool has-data, var Int error)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e5
struct TestIterator
    var Int num
    func user step()->(var Int num, var Int has-data)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e6
struct TestIterator
    var Int num
    func weak step()->(var Int num, var Bool has-data)
func fun(user TestIterator iter)
    for n in iter
; @ eg test-for-each-e7
struct TestIterator
    var Int num
    func user ! step()->(var Int num, var Bool has-data)
func fun(user TestIterator iter)
    for n in iter
; @@ test-complex-fields
; @ g test-complex-fields-0
struct Test
    var Bstruct b
    s-var Bstruct sb
    func user ! test()
        weak Bstruct b(weak self.sb)
        b := self.sb
        self.b.meth()
        Bstruct.meth(user self.b)
        user Bstruct? b2(user self.b.b!)
        b2 := self.b.b!
        self.b.b!.meth()
        self.b.b := b
        Bstruct.meth(user self.b.b!)
        s-var Test t!
        self.b.x := 5
        Astruct.meth(user self.b)
        if self.b is b or b2 is-not self.b
        b := t.b
class Astruct
    var Int x
    func dynamic user? meth()
class Bstruct(Astruct)
    weak Bstruct? b
    func dynamic user? meth()
; @ g test-complex-fields-1
struct Base
    var Int x
struct Test
    var String{10} s
    var Array{11:Int} ai
    var Array{12:Base} ab
    var Array{7:String{8}} as
    var Array{4:Array{5:Array{6:Int}}} aai
    var Array{4:Array{5:Array{6:Base}}} aab
    var Array{4:Array{5:String{6}}} aas
    func user ! test()->(var Char c, var Int i, user Base? b)
        c := self.s[3]!
        i := self.ai[4]
        b := self.ab[5]
        c := self.as[4][5]!
        i := self.aai[1][2][3]
        b := self.aab[1][2][3]
        c := self.aas[1][2][3]!
; @ eg test-complex-fields-e0
var Int x
struct Test
    var String{x} error
; @ eg test-complex-fields-e1
var Int x
struct Test
    var Array{x:Int} error
; @ eg test-complex-fields-e2
struct Test
    var Test error
; @ eg test-complex-fields-e3
struct Test
    var Base error
struct Base
    var Test t
; @ eg test-complex-fields-e4
struct Abase
    var Berror b
struct Aerror(Abase)
struct Bbase
    var Aerror a
struct Berror(Bbase)
; @ eg test-complex-fields-e5
struct Base
    var Int x
struct Test
    var Base b
    func user test(user Base b)
        self.b := b
; @ eg test-complex-fields-e6
struct Base
    var Int x
struct Test
    var Base b
    func user ! error()
        assert! self.b?
; @@ test-enum
; @ g test-enum-0
enum MyEnum
    VALUE
    ANOTHER-VALUE
    LAST-VALUE
func dummy()
    var Int x(copy MyEnum.VALUE)
    x += MyEnum.ANOTHER-VALUE
    x -= MyEnum.length
; @ g test-enum-1
enum MyEnum
    VALUE
    ANOTHER-VALUE
    LAST-VALUE
var Array{MyEnum.length:Int} arr
; @ eg test-enum-e0
enum MyEnum
    VALUE
func dummy()
    var Int x(copy MyEnum.ERROR)
; @ ec test-enum-e1
i := Error.VALUE
; @ eg test-enum-e2
enum MyEnum
    VALUE
func dummy()
    var Int x(copy MyEnum.error)
; @ eg test-enum-e3
enum My-Enum
; @ eg test-enum-e4
enum MyEnum
    Error
; @ eg test-enum-e5
enum MyEnum
    ERRoR
; @ eg test-enum-e6
enum
; @ eg test-enum-e7
enum MyEnum
    VALUE(0)
; @ eg test-enum-e8
enum MyEnum
; @ eg test-enum-e9
enum MyEnum
        VALUE
; @ eg test-enum-e10
enum Error
    VALUE
enum Error
; @ eg test-enum-e11
struct Error
    var Int x
enum Error
; @ eg test-enum-e12
enum Error
    VALUE
struct Error
    var Int x
; @@ test-constant
; @ g test-constant-0
const Int NUMBER 12
; @ g test-constant-1
const Int SIZE 12
var Array{SIZE + 3:Int} arr
func fun(user Array{Int} a)
    fun(user arr)
; @ g test-constant-2
const Int LARGE 1 - (- (2 * SMALL))
const Int SMALL 7
; @ g test-constant-3
enum MyEnum
    VALUE
const Int NUMBER MyEnum.VALUE
; @ g test-constant-4
const Int NUMBER (128 div 3) mod 10
const Int D-CHAR 'a' + 3
; @ eg test-constant-e0
const
; @ eg test-constant-e1
const Bool
; @ eg test-constant-e2
const Int
; @ eg test-constant-e3
const Int Error
; @ eg test-constant-e4
const Int ERROR
; @ eg test-constant-e5
const Int NAME false
; @ eg test-constant-e6
var Int x
const Int NAME x
; @ eg test-constant-e7
const Int ERROR ERROR + 1
; @ eg test-constant-e8
const Int A-ERROR B-ERROR
const Int B-ERROR - (2 * A-ERROR) + 1
; @ eg test-constant-e9
const Int NUMBER 12
func dummy()
    NUMBER := 3
; @ eg test-constant-e10
const Int NUMBER 12
func dummy()->(var Int x)
    dummy()->(var NUMBER)
; @@ test-module
; @ tg test-module-0
enum Enum
    VALUE
const Int SIZE 12
struct Test
    var Int x
    func user meth()
var Test t
func ! fun()
    t.x := Enum.VALUE + SIZE
    fun()!
    Test.meth(user t)
    second.t.x := second.Enum.VALUE + second.SIZE
    second.fun()!
    second.Test.meth(user second.t)
    new second.Test nt!
; @-
module second
enum Enum
    VALUE
const Int SIZE 12
struct Test(ut.Test)
    func user meth()
var Test t
func ! fun()
    t.x := Enum.VALUE + SIZE
    fun()!
    Test.meth(user t)
    ut.t.x := ut.Enum.VALUE + ut.SIZE
    ut.fun()!
    ut.Test.meth(user ut.t)
    new ut.Test nt!
test dummy()
; @ tg test-module-1
func fun()
struct Test
    var Int x
    func user meth()
        fun()
        self.meth()
; @-
module second
mock ut.fun()
mock ut.Test.meth()
test dummy()
; @ tg test-module-2
native type Native
native var Int x
native func external()
func fun()
    x := 0
; @-
module second
test use()
    var ut.Native n
    ut.x := 2
    ut.external()
; @ ec test-module-e0
ut.error
; @ eg test-module-e1
var Int ut
; @ eg test-module-e2
func ut()
; @ eg test-module-e3
var error.Test x
; @ eg test-module-e4
var ut.Error x
; @ etg test-module-e5
; nothing
; @-
module(error)
; @ etg test-module-e6
; @-
module Error
; @ etg test-module-e7
; @-
module true
; @ etg test-module-e8
; @-
module file-open-read
; @ etg test-module-e9
; @-
func fun()
; @ ec test-module-e10
fun0().Error
; @ ec test-module-e11
i.Error
; @ ec test-module-e12
ut.Error.VALUE
; @@ test-memory-owner
; @ g test-memory-owner-0
struct Test
    owner String? s
    owner String str
    new!()
        self.str := String{12}()!
        self.str.clear()
func use(user String? s)
func take(owner String? s)
func give()->(owner String? s)
func ! fun(owner String? s, user Test tu, owner Test to)
    s := _
    s := String{12}()!
    s!.clear()
    to.s := String{12}()!
    user String? su(user tu.s)
    use(user tu.s)
    take(owner to.s)
    var Array{12:Int} arr
    arr[4] := arr[8]
    loop
        give()->(owner s)
        while s?
; @ eg test-memory-owner-e0
struct Test
    owner String s
    new()
func ! fun(user Test t)
    t.s := String{12}()!
; @ eg test-memory-owner-e1
struct Aa
    var Int x
struct Bb
    owner Aa? a
func fun(user Bb b)
    owner Aa? a(owner b.a)
; @ eg test-memory-owner-e2
struct Aa
    var Int x
struct Bb
    owner Aa? a
func take(owner Aa? a)
func fun(user Bb b)
    take(owner b.a)
; @ eg test-memory-owner-e3
struct Aa
    owner String? s
struct Bb
    weak Aa? a
func ! fun(owner Array{Bb} b)
    b[3]!.a!.s := _
; @ eg test-memory-owner-e4
struct Test
    owner String? s
func get-user()->(weak Test? t)
func ! fun()
    weak Test? t
    get-user()->(weak t)!.s := _
; @ eg test-memory-owner-e5
struct Test
    owner String? s
func get-weak()->(weak Test? t)
func ! fun()
    get-weak()!.s := _
; @ eg test-memory-owner-e6
struct Test
    owner String s
    new()
func fun(owner Test t)->(owner String? s)
    s := t.s
; @ eg test-memory-owner-e7
struct Test
    owner String s
    new()
func fun(owner Test t)
    owner String s(owner t.s)
; @ eg test-memory-owner-e8
struct Test
    owner String s
    new()
func take(owner String s)
func fun(owner Test t)->(owner String? s)
    take(owner t.s)
; @ ec test-memory-owner-e9
new String{12} s!
new String{12} sg!
ostr := sg
sg := s
ostr!.clear()
sg.clear()
s.clear()
; @ eg test-memory-owner-e10
struct Test
    owner Test? t
func ! fun()->(owner Test? t, owner Test? x)
    t := x!.t
    t := t!.t
; @ eg test-memory-owner-e11
struct Test
    owner Test? t
func ! fun(owner Test? t)
    t := t!.t
; @ eg test-memory-owner-e12
struct Test
    owner Test? t
func ! fun(owner Test? t)
    t!.t := t
; @ eg test-memory-owner-e13
struct Test
    owner Test? t
func ! fun(owner Test? t)
    t!.t!.t := t!.t
; @ eg test-memory-owner-e14
struct Test
    owner String s
    new()
func fun(owner Test t, user Test tu, owner String s, user String su)
    t.s :=: s
    su.clear()
    s.clear()
    t.s.clear()
    tu.s :=: s
; @ ec test-memory-owner-e15
fun8(strong so)
so!.clear()
new String{12} s!
fun8(strong s)
s.clear()
; @ ec test-memory-owner-e16
new Test tgood!
owner Test tbad
if b
    tgood := to!
tgood.meth()
if b
    tbad := to!
tbad.meth()
; @ ec test-memory-owner-e17
new String{12} s!
repeat 12
    s.clear()
    ostr := s
    if b
        continue
    s := String{12}()!
; @ eg test-memory-owner-e18
func fun(owner String? s, owner String? s2)
    fun(owner s, owner s)
; @ eg test-memory-owner-e19
func fun()->(owner String? s, owner String? s2)
    fun()->(owner s, owner s2)
    fun()->(owner s, owner s)
; @ eg test-memory-owner-e20
func fun(owner String? s)->(owner String? s2)
    fun(owner s)->(owner s)
; @ eg test-memory-owner-e21
struct Test
    var Int x
func ! fun(owner Test? t)->(var Int x)
    x := fun(owner t)! + t!.x
; @ eg test-memory-owner-e22
struct Test
    var Int x
func ! fun(owner Test? t)->(var Int x)
    x := t!.x + fun(owner t)!
; @ eg test-memory-owner-e23
func ! fun(owner String s)->(var Int x)
    for _ in fun(owner s)!:s.length()
; @ ec test-memory-owner-e24
new String{12} s!
try
    owner String s2(owner s)
    if b
        raise
    s := s2
s.clear()
; @ eg test-memory-owner-e25
struct Test
    owner String? s
func error()
    var cdef.Pointer{Test} pt
    pt.get-ref-at(copy 0).s := _
; @@ test-memory-user
; @ g test-memory-user-0
func deleting()->(owner String? s)
    s := _
func fun(user String s)->(owner String? so)
    s.clear()
    deleting()->(owner so)
; @ g test-memory-user-1
func deleting()->(strong String? s)
    s := _
func ! fun()
    strong String? so(strong String{12}()!)
    user String? s(user so)
    s!.clear()
    deleting()->(strong so)
; @ g test-memory-user-2
func deleting()->(strong String? s)
    s := _
func ! fun()
    strong String? so(strong String{12}()!)
    weak String? s(weak so)
    deleting()->(strong so)
    s!.clear()
; @ c test-memory-user-3
user String? s
so := _
s := so
s!.clear()
; @ g test-memory-user-4
struct Test
    weak String? s
    func user ! get()->(user String? s) _
func ! Test.get()->(user String? s)
    s := self.s!
func ! fun(user Test t)
    user String? s
    owner String? sowner(owner _)
    t.get()->(user s)!
    s!.clear()
    s := t.get()!
    s!.clear()
; @ c test-memory-user-5
user String? s(user ostr)
ostr := _
for s in sarr!
    s!.clear()
; @ g test-memory-user-6
func get()->(user String? s)
    s := _
func ! fun()
    loop
        user String? s
        while get()->(user s)?
        s!.clear()
; @ ec test-memory-user-e0
user String? s
so := _
c := s![2]!
; @ ec test-memory-user-e1
user String? s
user String? s2
so := _
s2 := s
; @ ec test-memory-user-e2
user String? s
so := _
s!.length()->(var i)
; @ ec test-memory-user-e3
user String? s
so := _
String.clear(user s!)
; @ ec test-memory-user-e4
user String? s
so := _
b := not (false or s!.length() > 3)
; @ eg test-memory-user-e5
func deleting(owner String? s)
func fun(user String s)
    deleting(owner _)
    s.clear()
; @ eg test-memory-user-e6
func deleting()->(owner String? s)
    s := _
func proxy()
    deleting()
func fun(user String s)
    proxy()
    s.clear()
; @ eg test-memory-user-e7
func deleting()->(owner String? s)
    proxy()
    s := _
func proxy()
    deleting()
func fun(user String s)
    proxy()
    s.clear()
; @ eg test-memory-user-e8
struct Test
    var Int x
    func user deleting()->(owner String? s)
        s := _
    func user fun(user String s)
        self.deleting()
        s.clear()
; @ eg test-memory-user-e9
func deleting()->(owner String? s)
    s := _
func fun(user String s)
    deleting()
    s.clear()
; @ eg test-memory-user-e10
func deleting()
    owner String? s
func fun(user String s)
    deleting()
    s.clear()
; @ eg test-memory-user-e11
func deleting()
    var String{12} s
func fun(user String s)
    deleting()
    s.clear()
; @ eg test-memory-user-e12
func deleting()
    strong String? s
func fun(user String s)
    deleting()
    s.clear()
; @ ec test-memory-user-e13
user Array{Char} a(user ostr!)
ostr := _
c := a[2]!
; @ eg test-memory-user-e14
func ! deleting()
    var Int x(copy String{12}()!.length())
func ! fun(user String s)
    deleting()!
    s.clear()
; @ eg test-memory-user-e15
struct Test
    owner String? s
func ! deleting(owner Test? ta, owner Test? tb)
    ta!.s := tb!.s
func ! fun(user String s)
    deleting(owner _, owner _)!
    s.clear()
; @ ec test-memory-user-e16
user Test? tt
d!.set(owner _)
tt.meth()
; @ eg test-memory-user-e17
struct Base{Atype}
    var Int x
    func user fun(owner Atype? a)
struct Test{Btype}(Base{Btype})
    func user fun()
        base(owner _)
func ! fun(user File f)
    var Test{File} t
    t.fun()
    f.putc(copy 'a')!
; @ eg test-memory-user-e18
struct Base
    var Int x
struct Test(Base)
func deleting(owner Base? b)
func fun(user Test t)
    deleting(owner _)
    t.x := 0
; @ eg test-memory-user-e19
struct Base
    var Int x
struct Test(Base)
struct Other(Base)
func deleting(owner Test? t)
func fun(user Base b, user Other o)
    deleting(owner _)
    o.x := 0
    b.x := 0
; @ eg test-memory-user-e20
class Base
    var Int x
    func dynamic user fun()
class Test(Base)
    func dynamic user fun()
        owner String? s
func fun(user String s, user Base b)
    b.fun()
    s.clear()
; @ eg test-memory-user-e21
class Base
    var Int x
    func dynamic user fun()
class Test{Generic}(Base)
    func dynamic user fun()
func fun(user String s, user Base b)
    b.fun()
    s.clear()
; @ eg test-memory-user-e22
class Base
    var Int x
    func dynamic user? fun(owner Base? b)
        recursive()
class Test{Generic}(Base)
    func dynamic user? fun(owner Base? b)
func recursive()
    Base.fun(user _, owner _)
func fun(user String s)
    recursive()
    s.clear()
; @ ec test-memory-user-e23
user String? s
t!.fun!()
s!.clear()
; @ eg test-memory-user-e24
func ! deleting(copy Func?{()} f)
    f!()
func ! fun(user String s)
    deleting(copy _)!
    s.clear()
; @ eg test-memory-user-e25
func fun()->(user String? s)
; @ eg test-memory-user-e26
func deleting()
    owner String? s
func fun()->(user String? s)
    s := _
    deleting()
; @ eg test-memory-user-e27
func fun(owner String so)->(user String? s)
    s := _
; @ eg test-memory-user-e28
func fun()->(user String? s)
    owner String? so
    s := _
; @ eg test-memory-user-e29
struct Test
    owner String? s
func fun(owner Test? t, user String s)
    t := _
    s.clear()
; @ eg test-memory-user-e30
struct Other
    owner String? s
struct Test
    owner Other? o
func fun(owner Test? t, user String s)
    t := _
    s.clear()
; @ eg test-memory-user-e31
struct Base
    owner String? s
struct Test(Base)
struct Other(Base)
    owner File? f
func ! fun(owner Test? t, user String s, user File f)
    t := _
    f.putc(copy 'a')!
    s.clear()
; @ eg test-memory-user-e32
struct Base
    var Int x
struct Test(Base)
    owner String? s
func fun(owner Base? b, user String s)
    b := _
    s.clear()
; @ eg test-memory-user-e33
struct Test{Generic}
    owner Generic? x
func ! fun(owner Test?{File} t, user File f)
    t := _
    f.putc(copy 'a')!
; @ eg test-memory-user-e34
struct Base{Generic}
    owner Generic? x
struct Test{Data}(Base{Data})
func ! fun(owner Test?{File} t, user File f)
    t := _
    f.putc(copy 'a')!
; @ eg test-memory-user-e35
main
    owner String? so(owner String{12}()!)
    user String? su(user so)
    so := _
    su!.clear()
; @ ec test-memory-user-e36
assert! str?
; @ ec test-memory-user-e37
assert-error! str.clear()
; @ ec test-memory-user-e38
if str?
; @ ec test-memory-user-e39
for _ in str!.length():2
; @ ec test-memory-user-e40
for _ in 2:str!.length()
; @ ec test-memory-user-e41
for _ in str!
; @ ec test-memory-user-e42
if b
    str!.clear()
; @ ec test-memory-user-e43
if false
    str := ostr
str!.clear()
; @ ec test-memory-user-e44
str := ostr
repeat 12
    str!.clear()
    ostr := _
    if b
        continue
    str := ostr
; @ ec test-memory-user-e45
str := ostr
try
    ostr := _
    if b
        raise
    str := ostr
str!.clear()
; @ eg test-memory-user-e46
func fun(user String sin)->(user String? sout)
    if false
        sout := sin
; @ eg test-memory-user-e47
func fun(user String sin)->(user String? sout)
    if true
        return
    sout := sin
; @ ec test-memory-user-e48
str := ostr
for n in str!
    ostr := _
; @@ test-memory-temp
; @ g test-memory-temp-0
struct Test
    owner String? s
func fun(temp Test t)
    t.s := _
func use(owner Test t)
    fun(temp t)
    fun(temp t)
    temp Test? tc
    tc := _
; @ g test-memory-temp-1
struct Test
    owner String? s
func fun(owner Test to)
    temp Test t(temp to)
    t.s := _
; @ g test-memory-temp-2
struct Test
    owner String? s
func fun(owner Test to)
    if to.s?
        to.s := _
        temp Test t1(temp to)
        t1.s := _
    else
        to.s := _
        temp Test t2(temp to)
        t2.s := _
    to.s := _
    temp Test t3(temp to)
    t3.s := _
; @ eg test-memory-temp-e0
func fun(temp String s)
func error(user String s)
    fun(temp s)
; @ eg test-memory-temp-e1
func fun(owner String s)
func error(temp String s)
    fun(owner s)
; @ eg test-memory-temp-e2
func error()->(temp String s)
; @ eg test-memory-temp-e3
func fun(temp String s1, temp String s2)
func error(owner String s)
    fun(temp s, temp s)
; @ eg test-memory-temp-e4
func fun(owner String so, temp String st)
func error(owner String s)
    fun(owner s, temp s)
; @ eg test-memory-temp-e5
func fun(temp String st, owner String so)
func error(owner String s)
    fun(temp s, owner s)
; @ eg test-memory-temp-e6
struct Sa
    owner Sb? sb
struct Sb
    owner Sa? sa
func fun(temp Sb sb, temp Sb x)
    sb.sa := x.sa
func ! error(owner Sb x)
    x.sa := Sa()!
    x.sa!.sb := Sb()!
    fun(temp x.sa!.sb!, temp x)
; @ ec test-memory-temp-e7
temp String? s1(temp so)
temp String? s2(temp so)
; @ ec test-memory-temp-e8
temp String? s(temp so)
so!.clear()
; @ ec test-memory-temp-e9
temp String? s1(temp so)
temp String? s2(temp s1)
s1!.clear()
; @ ec test-memory-temp-e10
temp String? s
if true
    temp String? si(temp so)
    s := si
; @@ test-memory-constructor
; @ g test-memory-constructor-0
struct NoConstructor
    var String{12} s
struct HasConstructor
    owner String s
    new!()
        self.s := String{12}()!
struct Test
    var NoConstructor vnc
    var HasConstructor vhc
    s-var NoConstructor svnc
    s-var HasConstructor svhc
    new!()
        self.vnc.s.clear()
        self.svnc.s.clear()
        self.vhc.new()!
        self.vhc.s.clear()
        self.svhc.new()!
        self.svhc.s.clear()
; @ g test-memory-constructor-1
func fun1()
func fun2(copy Func{()} f)
struct Base
    owner String s
    new!()
        self.s := String{12}()!
struct Mid(Base)
    new!()
        base()!
struct Test(Mid)
    owner Base? b
    new!()
        fun1()
        fun2(copy fun1)
        self.b!.new()!
        base()!
; @ eg test-memory-constructor-e0
struct Error
    weak String s
; @ eg test-memory-constructor-e1
struct Error
    owner String s
    new()
; @ eg test-memory-constructor-e2
struct Error
    weak String s
    new!(strong String s)
        self.s!.clear()
        self.s := s
; @ eg test-memory-constructor-e3
struct Error
    owner String s
    new!()
        self.fun()
        self.s := String{12}()!
    func user fun()
        self.s.clear()
; @ eg test-memory-constructor-e4
struct Error
    owner String s
    new!()
        error(user self)
        self.s := String{12}()!
func error(user Error e)
    e.s.clear()
; @ eg test-memory-constructor-e5
struct Error
    owner String s
    new!()
        if false
            self.s := String{12}()!
; @ eg test-memory-constructor-e6
struct Error
    owner String s
    new() _
func Error.new()
; @ eg test-memory-constructor-e7
struct Error
    owner String s
    new!()
        if true
            return
        self.s := String{12}()!
; @ eg test-memory-constructor-e8
struct Test
    owner String s
    new!()
        self.s := String{12}()!
struct Error
    var Test t
; @ eg test-memory-constructor-e9
struct Test
    owner String s
    new!()
        self.s := String{12}()!
struct Error
    var Test t
    new()
; @ eg test-memory-constructor-e10
struct Base
    owner String s
    new!()
        self.s := String{12}()!
struct Test(Base)
    new()
; @ eg test-memory-constructor-e11
struct Test
    owner String s
    new!()
        self.s := String{12}()!
struct Error
    var Test t
    new!()
        self.t.s.clear()!
; @ eg test-memory-constructor-e12
struct Test
    owner String s
    new!()
        self.s := String{12}()!
struct Error
    var Test t
    new!()
        if false
            self.t.new()!
        self.t.s.clear()!
; @@ test-memory-error
; @ ec test-memory-error-e0
str := str
; @ eg test-memory-error-e1
struct Error
    user String? s
; @ eg test-memory-error-e2
struct Error
    temp String? s
; @ eg test-memory-error-e3
func error(var String s)
; @ eg test-memory-error-e4
func error()->(var String s)
; @@ test-c-objects
; @ c test-c-objects-0
var cdef.Char c-char
var cdef.Uchar c-uchar
var cdef.Short c-short
var cdef.Ushort c-ushort
var cdef.Int c-int
var cdef.Uint c-uint
var cdef.Long c-long
var cdef.Ulong c-ulong
var cdef.Size c-size
var cdef.Float c-float
var cdef.Double c-double
var cdef.LongDouble c-long-double
c-char := i
i := c-char
c-uchar := i
i := c-uchar
c-short := i
i := c-short
c-ushort := i
i := c-ushort
c-int := i
i := c-int
c-uint := i
i := c-uint
c-long := i
i := c-long
c-ulong := i
i := c-ulong
c-size := i
i := c-size
c-float := i
i := c-float
c-double := i
i := c-double
c-long-double := i
i := c-long-double
; @ c test-c-objects-1
var cdef.Pointer p-void
var cdef.Pointer{cdef.Char} p-char
var cdef.Pointer{cdef.Uint} p-uint
var cdef.Pointer{Test} p-test
var cdef.Pointer{cdef.Pointer{cdef.Int}} pp-int
var cdef.Pointer{cdef.Pointer{cdef.Pointer{cdef.Char}}} ppp-char
p-void := p-char
p-uint := p-void
p-char := p-uint
; @ c test-c-objects-2
var cdef.Int int
var cdef.Pointer{cdef.Int} p-int
var cdef.Pointer{cdef.Pointer{cdef.Int}} pp-int
user Array?{cdef.Int} arr-int
p-int.set-from-array(user arr-int!)
p-int.set-point-to(var int)
pp-int.set-point-to(var p-int)
p-int := pp-int.get-pointed-at(copy 0)
int := p-int.get-pointed-at(copy 3)
var Test test
user Test u-test(user test)
var cdef.Pointer{Test} p-test
user Array?{Test} arr-test
p-test.set-from-array(user arr-test!)
p-test.set-from-ref(user test)
u-test := p-test.get-ref-at(copy 5)
; @ c test-c-objects-3
var cdef.Pointer{Char} p-char
p-char.set-from-array(user ostr!)
ostr!.copy-from-pointer(copy p-char)!
ostr!.set-null-term-length()
; @ ec test-c-objects-e0
var cdef.Pointer{Ta} error
; @ ec test-c-objects-e1
var cdef.Pointer{Int} p-int
i := p-int.get-ref-at(copy 5)
; @ ec test-c-objects-e2
var Test tv
var cdef.Pointer{Test} p-test
tv := p-test.get-pointed-at(copy 0)
; @