struct Test
    var Int num
    weak Test? t
    var Func{()} fun
    func user? meth()
class Ta(Test)
    var Int numa
    func inst user? metha()
    func dynamic user? dyn()
class Tb(Ta)
    var Int numb
    new(copy Int num)
    func inst user? methb()
    func dynamic user? dyn()
class Tc(Tb)
    var Int numc
    func inst user? methc()
    func dynamic user? dyn()
struct Data{Generic}
    weak Generic? item
    func user? set(owner Generic? item)
    func user? get()->(weak Generic? item)

func fun0()
func fun1(copy Int x, user String? s, owner String? o)
func fun2()->(strong String? s, var Int x)
func fun3(copy Int x)->(strong String? s)
func fun4(copy Int x)
func fun5(copy Int x)->(var Int y)
func fun6(copy Int x, copy Int y)->(var Int n, var Int m)
func fun7(weak Tb? tb)->(weak Tb? tbo)
func fun8(strong String? s)

var Int i
var Char c
var Bool b
user String? str
owner String? ostr
weak Array?{Int} arr
owner File? fobj
weak Test? t
weak Ta? ta
strong Tb? tb
weak Tc? tc
weak Data?{Test} d
weak Array?{String} sarr

func mock()->(strong String? so, var Int io, strong Test? to, weak Tc? tco)
; @@ test-int-expression
; @ c t0
i := 0
; @ c t1
i := 9630
; @ c t2
i := -9630
; @ c t3
i := 07520
; @ c t4
i := -07520
; @ c t5
i := 0xfda940
; @ c t6
i := -0xfda940
; @ c t7
i := 0xFDA940
; @ c t8
i := -0xFDA940
; @ ec te0
2a
; @ ec te1
0a
; @ ec te2
038
; @ ec te3
0b021
; @ ec te4
0xadg
; @ ec te5
0b1001
; @@ test-char-expression
; @ c t0
c := 'a'
; @ c t1
c := '\''
; @ c t2
c := '\n'
; @ c t3
c := '\x0f'
; @ c t4
c := '\xA9'
; @ c t5
c := '\270'
; @ fec te0
c := '''
; @ fec te1
c := '\'
; @ fec te2
c := 'aa
; @ ec te3
c := '\c'
; @ ec te4
c := 'aaaa'
; @ ec te5
c := '\x6g'
; @ ec te6
c := '\058'
; @ ec te7
c := ''
; @ ec te8
c := 'aa'
; @ ec te9
c := 'aaa'
; @ ec te10
c := 'aaaaa'
; @@ test-string-expression
; @ c t0
str := "some string"
; @ c t1
str := "\nstring\t\"with\\formatting\n"
; @ c t2
str := "line\
        split\
        string\
        "
; @ c t3
str := "multi
        line
        string
        "
; @ c t4
str := "line\
         split"
; @ fec te0
str := "aaa
; @ fec te1
str := "
; @ ec te2
"error"+"string"
; @ ec te3
str := "indention
    too short"
; @ ec te4
str := "indention\
    too short"
; @@ test-empty-expression
; @ c t0
str := _
; @ c t1
t := _
; @ c t2
so := _
; @ c t3
b := t is _ or ta is-not _
; @ ec te0
i := _
; @@ test-member-expression
; @ c t0
i := t!.num
; @ c t1
i := tc!.numb
; @ c t2
i := tc!.num
; @ c t3
i := to!.num
; @ c t4
tco := tc
i := tco!.num
; @ c t5
i := t!.t!.num
; @ c t6
i := t!.t!.t!.num
; @ ec te0
error
; @ ec te1
(i := 1).error
; @ ec te2
t.error
; @ ec te3
5.error
; @@ test-slice-expression
; @ c t0
c := ostr![13]
; @ c t1
user Array?{Char} x
x := ostr![2:6]
; @ c t2
i := arr![13]
; @ c t3
user Array?{Int} x
x := arr![2:6]
; @ c t4
ostr![4] := c
; @ c t5
arr![4] := i
; @ c t6
strong Array?{Test} tarr
t := tarr![3]
; @ c t7
var Array{8:String{5}} vsa
user String s(user vsa[3])
user Array{String} sa(user vsa[2:4])
; @ g t8
func fun(s-var String s, strong Array{String} sa)
    var Char c(copy s[5])
    user Array{Char} part(user s[4:2]!)
    user String si(user sa[3]!)
; @ c t9
strong Array?{String} sa
sa![3]!.copy(user "text")
sa := _
; @ c t10
strong Array?{Array{Int}} aai
arr := aai![3]
weak Array?{Array{Int}} ua(weak aai![2:4])
; @ c t11
strong Array?{Array{Array{Array{Int}}}} aai
weak Array?{Array{Array{Int}}} ua(weak aai![3])
weak Array?{Array{Array{Array{Int}}}} uaa(weak aai![2:4])
; @ c t12
strong Array?{Array{Array{String}}} aas
weak Array?{Array{String}} ua(weak aas![3])
weak Array?{Array{Array{String}}} uaa(weak aas![2:4])
aas := _
; @ c t13
var Array{8:Array{7:Array{6:Array{5:Int}}}} aai
user Array?{Array{Array{Int}}} ua(user aai[3])
user Array?{Array{Array{Array{Int}}}} uaa(user aai[2:4])
; @ c t14
var Array{8:Array{7:Array{6:String{5}}}} aas
user Array?{Array{String}} ua(user aas[3])
user Array?{Array{Array{String}}} uaa(user aas[2:4])
; @ g t15
func fun()
    var Array{8:Array{7:Array{6:String{5}}}} aas
    user String s(user aas[4][3][2])
; @ c t16
user Array?{Char} x
x := ostr
; @ c t17
new String{12} s
sys.print(user s)
; @ g t18
struct Test
    owner String? s
func fun()
    var Test t
    var Array{6:Test} a
; @ ec te0
arr[2
; @ ec te1
arr[2:3
; @ ec te2
(i := 3)[2]
; @ ec te3
i[2]
; @ ec te4
arr![str]
; @ ec te5
arr![3:str]
; @ ec te6
arr![i += 3]
; @ ec te7
str![2:5] := so
; @ ec te8
arr![7:2] := Array{5:Int}()
; @ ec te9
user Array?{Test} at
at![0] := t
; @ ec te10
so := sarr![3]
; @ ec te11
var Array{3:Tc} error
; @ eg te12
struct Test
    var Int x
    new()
func func(user Array{Test} error)
; @@ test-call-expression
; @ c t0
fun0()
; @ c t1
fun1(copy 3, user ostr, owner _)
; @ c t2
fun2()->(strong so, var io)
; @ c t3
var Int x
strong String? s
fun2()->(strong s, var x)
; @ c t4
fun3(copy 0)->(strong so)
; @ c t5
var Int x
fun4(copy fun5(copy 3)->(var x))
; @ c t6
fun6(
        copy 2,
        copy 3)->(
        var io,
        var io)
; @ c t7
fun5(copy 4)
; @ c t8
io := fun5(copy 4)
; @ c t9
so := fun3(copy 7)
; @ c t10
t!.meth()
; @ c t11
to.meth()
; @ c t12
tc!.methc()
; @ c t13
tc!.methb()
; @ c t14
tc!.meth()
; @ c t15
tco := tc
tco!.meth()
; @ c t16
t!.t!.meth()
; @ c t17
fun1(copy 3, user ostr, owner so)
; @ c t18
fun3(copy 1)
fun5(copy 2)
; @ g t19
class Base
    var Int x
    func dynamic user meth(owner Base b)
class Test(Base)
    func dynamic user meth(owner Test t)
        base(owner t)
; @ g t20
class Test
    var Int x
    func dynamic weak? meth()
func mock()->(weak Test? t)
    mock()->(weak t).meth()
; @ g t21
class Test
    var Int x
    func dynamic weak? meth()->(weak Test? t)
        self.meth().meth()
; @ g t22
func fun()->(owner Array?{String} astr)
    fun()->(owner astr)
; @ g t23
func fun(var String s)
    var String{12} vars
    s-var String{12} s-vars
    owner String owners(owner String{12}())
    strong String strongs(strong String{12}())
    user String users(user s)
    fun(var s)
    fun(var vars)
    fun(var s-vars)
    fun(var owners)
    fun(var strongs)
    s.clear()
; @ c t24
strong String? s
weak String? sw
fun1(copy 0, user sw!, owner s)
; @ c t25
fun8(strong ostr)
; @ ec te0
function( copy 1)
; @ ec te1
function(user)
; @ ec te2
function(copy 4,copy 3)
; @ ec te3
function(copy 2
; @ ec te4
function(error 4)
; @ ec te5
(i := 0)()
; @ ec te6
i()
; @ ec te7
fun5(copy 0)->(var 4)
; @ ec te8
fun7(weak _)->(weak tc)
; @ ec te9
fun5(copy i := 1)
; @ ec te10
fun5(user 8)
; @ ec te11
fun1(copy 3, user str, owner str)
; @ ec te12
fun3(copy 3)->(strong str)
; @ ec te13
fun7(weak _)->(weak tb)
; @ ec te14
fun0(copy i)
; @ ec te15
fun1()
; @ ec te16
fun0()->(copy i)
; @ ec te17
fun2()
; @ eg te18
struct Base
    var Int x
    func user meth(owner Base b)
struct Test(Base)
    func user meth(owner Test t)
        base(owner t)
; @ ec te19
var String{16} text
fun1(copy 3, user str, owner text)
; @ ec te20
owner Tb? tbo
fun7(weak tbo)
; @@ test-type-expression
; @ c t0
Test.meth(user t!)
; @ c t1
Tb.methb(user tc!)
; @ c t2
Tc.meth(user tc!)
; @ ec t3
Error
; @@ test-base-expression
; @ g t0
struct Base
    var Int x
    func user methb()
struct Mid(Base)
    func user methm()
struct Top(Mid)
    func user methb()
    func user methm()
        base.methm()
; @ g t1
struct Base
    var Int x
    func user methb()
struct Mid(Base)
    func user methm()
struct Top(Mid)
    func user methb()
    func user methm()
        base.methb()
; @ ec te0
base
; @ eg te1
struct Test
    var Int x
    func user mock()
        base
; @ eg te2
struct Base
    var Int x
struct Test(Base)
    var Int x
    func user mock()
        base()
; @ eg te3
struct Base
    var Int x
struct Test(Base)
    func user mock()
        base := self
; @ eg te4
struct Base
    var Int x
struct Test(Base)
    func user mock()->(var Int x)
        x := base.x
; @@ test-block-expression
; @ c t0
i := 2 + (123)
; @ c t1
i := (123)
; @ c t2
i := (123 * (i - 4)) + 2
; @ ec t3
(error
; @@ test-unary-expression
; @ c t0
i := - i
; @ c t1
i := -
        i
; @ c t2
i := - - i
; @ c t3
b := not b
; @ c t4
b := not i > 3
; @ ec t5
{45}
; @ ec t6
-[
; @ ec t7
+ 2
; @ ec t8
- (i := 2)
; @ ec t9
- (i > 4)
; @ ec t10
not i
; @@ test-binary-expression
; @ c t0
i := 23 + 54
; @ c t1
i += (100 * 2) - (37 div 5 mod 2)
i *= 3
; @ c t2
i -= 12 *
        13
; @ c t3
b := 3 < 5 or 23 > 37
; @ c t4
b := 3 <= 5 and 23 >= 37
; @ c t5
b := i = 5 or i <> 37
; @ c t6
b := 2 < i < 12 = 2 * i
; @ c t7
t := tc
; @ c t8
owner String? s
s := so
; @ c t9
str := so
; @ c t10
b := t is ta or tc is-not tb
; @ c t11
c := '0' + 4
; @ c t12
b := fun0 is-not fun1
; @ c t13
b := b = b
; @ c t14
owner Tc? otc
tb := otc
; @ c t15
owner Array?{Test} otarr
otarr := _
; @ ec te0
345 @ 2
; @ ec te1
80 +(
; @ ec te2
1 + 2 * 3
; @ ec te3
1 < i or 2 < i and 3 < i
; @ ec te4
1 not 2
; @ ec te5
1 := 2
; @ ec te6
1 += 2
; @ ec te7
1 -= 2
; @ ec te8
so := str
; @ ec te9
b := 1 or 2
; @ ec te10
b := t > 3
; @ ec te11
b := 1 > 4 > t
; @ ec te12
i := 3 + t
; @ ec te13
t += 3
; @ ec te14
i -= b
; @ ec te15
b := 3 is t
; @ ec te16
user Array?{Char} ca
ca := arr!
; @ ec te17
owner Test? ot
ot := tb
; @ ec te18
b := b is b
; @ ec te19
b := t is t < 2
; @ ec te20
user Test? tu
t := tu
; @ ec te21
var Test tv
user Test tu(user tv)
tu := t
; @@ test-swap-expression
; @ c t0
new Test t1
new Test t2
t1 :=: t2
; @ c t1
strong Test t1(strong to!)
strong Test t2(strong to!)
t1 :=: t2
; @ c t2
new Tc t1(copy 1)
new Tc t2(copy 2)
t1 :=: t2
; @ c t3
strong Tc t1(strong Tc(copy 1))
strong Tc t2(strong Tc(copy 2))
t1 :=: t2
; @ c t4
new Array{4:Int} a1
new Array{6:Int} a2
a1 :=: a2
; @ c t5
strong Array{Int} a1(strong Array{4:Int}())
strong Array{Int} a2(strong Array{6:Int}())
a1 :=: a2
; @ c t6
new String{4} s1
new String{6} s2
s1 :=: s2
; @ c t7
strong String s1(strong String{4}())
strong String s2(strong String{6}())
s1 :=: s2
; @ g t8
struct Test
    owner File f
    new(owner File f)
        self.f := f
func fun(owner Test t1, owner Test t2)
    t1.f :=: t2.f
; @ c t9
user Test t1(user t!)
user Test t2(user t!)
t1 :=: t2
; @ c t10
weak Test t1(weak to!)
weak Test t2(weak to!)
t1 :=: t2
; @ c t11
i :=: io
; @ c t12
d!.item :=: t
; @ ec te0
t :=: to
; @ ec te1
new Test t1
t1 :=: t1
; @ ec te2
new String{8} nstr
ostr :=: nstr
; @ ec te3
weak Array{Char} a(weak so!)
a :=: so![1:2]
; @ ec te4
ta :=: tc
; @ ec te5
new Test t1
strong Test t2(strong to!)
t1 :=: t2
; @@ test-question-expression
; @ c t0
b := ostr?
; @ c t1
b := not arr?
; @ c t2
b := t!.fun?
; @ c t3
b := to?
; @ c t4
b := fun7(weak _)->(weak t)?
; @ g t5
struct Test
    weak String? s
    func user meth()->(var Bool res)
        res := self.s?
; @ ec te0
(i := 2)?
; @ ec te1
i?
; @@ test-exclamation-expression
; @ c t0
user String s(user ostr!)
; @ c t1
user Test tt(user t!.t!)
; @ c t2
user Test? tu
tu := fun7(weak _)->(weak t)!
; @ c t3
i := tb!.num
; @ c t4
weak Test tt(weak t!)
; @ c t5
new String{str!.length()} s
; @ ec te0
user String s(user str)
; @ ec te1
user Test? tt(user t)
; @ ec te2
new String{4} s
s := ostr
; @ ec te3
weak String? s
fun1(copy 0, user s, owner _)
; @ ec te4
t.num
; @ ec te5
t.meth()
; @ ec te6
var Func?{()} fun
fun()
; @ ec te7
i := arr[3]
; @ ec te8
for _ in str
; @ ec te9
weak String? s
raise s
; @ ec te10
new String{str.length()} s
; @ ec teo0
raise str!!
; @ ec ten0
var String{8} s
so := s!
; @ ec ten1
io := (2!) + 3
; @ ec ten2
so! := str
; @ ec ten3
"text"!.clear()
; @ ec ten4
var Func{(user Test? self)} fun(copy Test!.meth)
; @ ec ten5
var Test tv
i := tv!.num
; @ eg ten6
struct Base
    var Int x
    func user fun()
struct Test(Base)
    func user fun()
        base!()
; @ ec ten7
fun0!()
; @ eg ten8
func fun(user String s)
    fun(user s!)
; @ ec ten9
var Func{()} fun(copy fun0)
fun!()
; @ ec ten10
if not b!
; @ ec ten11
io := 2 + 3!
; @ eg ten12
func fun()
mock fun()
    fun!.active := false
; @ ec ten13
ut!.fun0()
; @ ec ten14
if t!?
; @ ec ten15
if b!
; @ ec ten16
do
    while b!
; @ ec ten17
for _ in 3!
; @ ec ten18
for _ in 3!:4
; @ ec ten19
for _ in 3:4!
; @ ec ten20
var String{4} s
for _ in s!
; @ ec ten21
var Array{4:Int} a
for _ in a!
; @ ec ten22
user String? s(user str!)
; @ eg ten23
const Int CONST 12!
; @ ec ten24
assert b!
; @ ec ten25
assert-error t!
; @ ec ten26
var Array{4:Int} a
i := a![2]
; @ ec ten27
var Array{4:Int} a
i := a[2!]
; @ ec ten28
var Array{4:Int} a
i := a[2:3!]
; @ ec ten29
var Ref r
r := ostr!
; @ ec ten30
raise "error"!
; @ ec ten31
raise str!
; @ ec ten32
var String{23!} s
; @@ test-dynamic
; @ c t0
var Ta a
; @ c t1
user Ta? a
; @ c t2
owner Ta nta(owner Ta())
; @ c t3
new Ta a
; @ c t4
user Ta? a(user ta!)
; @ c t5
user Ta? x
x := ta!
; @ c t6
ta := tb
; @ c t7
ta := tc
; @ c t8
ta := _
; @ c t9
strong Array?{Ta} aa
ta := aa![4]
; @ c t10
strong Array?{Tc} ca
ta := ca![4]
; @ c t11
ta!.dyn()
; @ c t12
tb.dyn()
; @ c t13
tc!.dyn()
; @ c t14
tco := tc
tco!.dyn()
; @ c t15
fun7(weak tc)->(weak ta)
; @ g t16
class Test
    var Int x
    func dynamic user meth()
func mock()->(weak Test? t)
    t!.meth()
; @ g t17
class Base
    var Int x
    func dynamic user meth()
class Test(Base)
    func inst user fun()
        self.meth()
; @ c t18
fun7(weak _)
; @@ test-function-object
; @ c t0
var Func{()} fun
fun := fun0
fun()
; @ c t1
var Func{(copy Int x)->(var Int y)} fun(copy fun5)
var Int x
fun(copy 9)->(var x)
; @ c t2
var Func{(user Test? self)} fun(copy Test.meth)
fun(user t!)
; @ c t3
var Func?{()} fun
fun := _
b := fun?
; @ c t4
t!.fun := fun0
t!.fun()
; @ c t5
var Array{38:Func{()}} farr
farr[3] := fun0
farr[3]()
; @ c t6
var Func{(copy Int x,
        copy Int y)} fun
; @ g t7
func mock()->(var Func{()} f)
    f()
; @ g t8
func fun(copy Func?{(copy Int x,
        copy Int y)} fi)->(var Func{(copy Int x,
        copy Int y)} fo)
    fun(copy _)
struct Test
    var Func{(copy Int x,
            copy Int y)} fun
    func user meth(copy Func{(copy Int x,
            copy Int y)} fi)->(var Func{(copy Int x,
            copy Int y)} fo)
; @ ec te0
var Func error
; @ ec te1
var Array{3:Func} error
; @ ec te2
var Func{} error
; @ ec te3
var Func{() } error
; @ ec te4
var Func{()} fun(copy fun1)
; @ ec te5
var Func{()->(var Int x)} fun
fun := fun0
; @@ test-builtin
; @ c ti0
i.str(user ostr!)
; @ c tb0
b := true
; @ c tb1
b := false
; @ ec c0
c := EOF
; @ c ta0
arr!.length()->(var i)
; @ c ts0
ostr!.length()->(var i)
; @ c ts1
ostr!.clear()
; @ c ts2
ostr!.equal(user ostr!)->(var b)
; @ c ts3
ostr!.get(copy i)->(var c)
; @ c ts4
ostr!.set(copy i, copy c)
; @ c ts5
ostr!.append(copy c)
; @ c ts6
var String{12} sv
sv.copy(user ostr!)
; @ c ts7
ostr!.concat(user ostr!)
; @ c ts8
ostr!.concat-int(copy i)
; @ c ts9
ostr!.find(user ostr!)->(var i)
; @ c ts10
ostr!.has(copy c)->(var b)
; @ c ts11
String.set(user ostr!, copy 0, copy 'a')
; @ c ts12
ostr!.max-length()->(var i)
; @ c tf0
file-open-read(user ostr!)->(owner fobj)
; @ c tf1
file-open-write(user ostr!)->(owner fobj)
; @ c tf2
file-close(owner fobj!)
; @ c tf3
fobj!.getc()->(var c, var b)
; @ c tf4
fobj!.putc(copy c)
; @ c tf5
fobj!.write(user ostr!)
; @ c ty0
user Array{String} argv(user sys.argv)
; @ c ty1
sys.print(user ostr!)
; @ c ty2
sys.println(user ostr!)
; @ c ty3
sys.getchar()->(var c, var b)
; @ c ty4
sys.getline(user ostr!)
; @ c ty5
sys.exit(copy i)
; @ c ty6
sys.system(user ostr!)->(var i)
; @ c ty7
sys.getenv(user ostr!, user ostr!)->(var b)
; @ c ty8
sys.stdout.putc(copy c)
; @ c ty9
sys.stdin.getc()->(var c, var b)
; @ c ty10
sys.stderr.putc(copy c)
; @ ec tef0
var File error
; @ ec tef1
new File error
; @ ec tef2
File()
; @ ec tef3
user File? f
file-open-read(user "name")->(owner fobj)
f!.putc(copy 'a')
; @ ec tef4
user File? f
file-open-write(user "name")->(owner fobj)
f!.putc(copy 'a')
; @ ec tef5
user File? f
file-close(owner fobj!)
f!.putc(copy 'a')
; @ ec tef6
owner File f(owner fobj!)
file-open-read(user "name")->(owner f)
; @ ec tey0
var Sys error
; @ ec tey1
new Sys error
; @ ec tey2
Sys()
; @@ test-general
; @ g t0
user String str
; @ g t1


    

var Int x
; @ g t2
; comment

var Int x
; @ g t3
~~~ documentation ~~~

var Int x
; @ g t4
[; multi 
 line 
 comment ;]

var Int x
; @ g t5
~~~ multi 
 line    
 documentation
 confused by ~ or ~~ or ; or ~~ ~ ?
~~~

var Int x
; @ g t6
var String{12} s
user String us(user s)
user String gs(user "global text")
main
    var Int x(copy 6)
    x := 7
; @ tg t7
var String{12} s
user String us(user s)
func fun()
    s.set(copy 0, copy 'a')
; @-
module second
test dummy()
; @ tg t8
func fun()
main
    fun()
; @-
module test
test test-fun()
; @ eg te0
error 
; @ ec te1
1 + 2
; @ ec te2
return
i := 3
; @ ec te3
raise
i := 3
; @ eg te4
[; comment ;]?
; @ eg te5
main(
; @ eg te6
    struct Test
; @ eg te7
func f()
    x :=
        y
; @ feg te8
var Int x
; @ eg te9
var Int name
var Int name
; @ eg te10
func name()
var Int name
; @ eg te11
user Error error
; @ eg te12
var Int x(copy error)
; @ eg te13
[ ; error
; @@ test-struct
; @ g t0
struct Test
    var Int x
; @ g t1
struct Test
    var Int x
; @ g t2
struct Test1
    var Int x
struct Test2
    var Int x


struct Test3
    var Int x
; @ g t3
struct Test2(Test1)
    var Int y
struct Test1
    var Int x
; @ g t4
struct Test
    owner Test? to
    strong Test? ts
    weak Test? tw
; @ eg te0
struct(
; @ eg te1
struct error
; @ eg te2
struct ERror
; @ eg te3
struct Error-name
; @ eg te4
struct E
; @ eg te5
struct Int
; @ eg te6
struct Test
struct Test
; @ eg te7
struct Test(Base
; @ eg te8
struct Test
    error 
; @ feg te9
struct Test
; @ eg te10
struct Error
; @ eg te11
struct Error
    new 
; @ eg te12
struct Error
    new()
    new()
; @ eg te13
struct Error
    var Int x
    new()->(var Int x)
; @ eg te14
struct Error(Error)
    var Int x
; @ eg te15
struct Aerror(Berror)
    var Int x
struct Berror(Aerror)
    var Int x
; @@ test-class
; @ g t0
class Base
    var Int x
    owner Base? b
    func inst user stat()
    func dynamic user dyn0()
    func dynamic user dyn1()
class Mid(Base)
    var Int y
    owner Mid? m
    func dynamic user dyn0()
    func dynamic user dyn2()
class Top(Mid)
    var Int z
    owner Top? t
    func dynamic user dyn0()
        base()
    func dynamic user dyn3()
        base.dyn0()
; @ g t1
class Test
    owner Test? to
    strong Test? ts
    weak Test? tw
    func dynamic user fun()
; @ eg te0
class(
; @ eg te1
class Error
    var Int x
; @ eg te2
class Error
    func error f()
; @ eg te3
struct Base
    var Int x
    func user meth()
class Error(Base)
    func dynamic user meth()
; @ eg te4
class Base
    var Int x
    func dynamic user meth()
class Error(Base)
    func inst user meth()
; @@ test-function
; @ g t0
func name()
; @ g t1
func name(user String self, user String text, copy Int num)
; @ g t2
func name()->(owner String? text, var Int num)
; @ g t3
func name(copy Char param)->(owner String? out)
; @ g t4
func name(user Array{Int} array)
; @ g t5
func name(copy Func{(copy Int x)->(var Int y)} fun)->(var Func{()} joy)
; @ g t6
func name()
    var Int x
; @ g t7
func name(user String self, copy Int px, user Array{Char} pu, owner String po)->(
        strong String? oself, var Int ox, weak String? ou, owner String? oo)
    var Int x
    user String? u
    owner String? o
    var String{12} v
    new String{12} n
    o := String{12}()
    u := "constant string"
    pu := po[2:6]
; @ g t8
struct Struct
    owner Struct? s
    owner Array?{Struct} as
    owner Array?{String} astr
class Class
    owner Class? c
    owner Array?{Class} ac
    func dynamic user meth()
func name(
        owner Struct ps,
        owner Class pc,
        owner Array{Struct} pas,
        owner Array{Class} pac)
    owner Struct? s
    owner Class? c
    owner Array?{Struct} as
    owner Array?{Class} ac
    owner Array?{Int} ai
    owner Array?{File} af
    owner Array?{String} astr
; @ g t9
class Test
    var Int x
    func dynamic user meth()
func name()->(owner Test? t)
    t := _
; @ g t10
func name(user Array{Array{String}} ai)->(owner Array?{Array{Int}} ao)
; @ g tm0
main
    var Int x
; @ eg te0
func(
; @ eg te1
func name
; @ eg te2
func Error()
; @ eg te3
func error_name()
; @ eg te4
func name()
func name()
; @ eg te5
var Int name
func name()
; @ eg te6
func name( )
; @ eg te7
func name(user)
; @ eg te8
func name(user String
; @ eg te9
func name(error Int x)
; @ eg te10
func name(user String str,user Int x)
; @ eg te11
func name()-()
; @ feg te12
func name()
; @ eg te13
func name()
        var Int x
; @ eg te14
func name(user Int x)
; @ eg te15
func name()->(copy Int x)
; @ eg te16
func name(copy String s)
; @ eg te17
func name(user Array error)
; @ eg te18
func name(copy Func error)
; @ eg te20
func name(
    copy Int x)
; @ eg te21
func Type.Error.name()
; @ eg te22
func module.error.name()
; @ eg te23
func name(copy Int error, copy Int error)
; @ eg te24
func name(copy Int error)->(var Int error)
; @ eg te25
var Int error
func name(copy Int error)
; @ eg te26
func error()
func name(copy Int error)
; @ eg te27
func error(copy Int error)
; @ eg te28
func name(copy Int Error)
; @ eg te29
func name()->(owner String s)
; @@ test-members
; @ g t0
struct Test
    var Int x
    weak String? str
; @ g t1
struct Test
    var Int x
    func user name()
        self.x := 2
; @ g t2
struct Test
    var Int x
    func user name()
        var Int x
        x := self.x
; @ g t3
struct Test
    ; comment
    var Int x
; @ g t4
struct Test
    ~~~ documemtation ~~~
    var Int x
; @ g t5
struct Test
    [; multi 
    line 
    comment ;]
    var Int x
; @ g t6
struct Test
    ~~~ multi 
    line 
    documemtation
    ~~~
    var Int x
; @ g t7
var Int name
func fun()
struct Test1
    var Int name
    func user fun()
struct Test2
    var Int fun
    func user name()
; @ g t8
struct Test
    var Int x
    func user fun()
        if self.x > 3
            self.x := 3
        do
            for n in 4
                self.x += n
; @ g t9
struct Test
    var Int x
    func user fun() _
func Test.fun()
    self.x := 3
; @ g t10
func Test.fun(user String s)->(var Int x)
    s.length()->(var x)
struct Test
    var Int x
    func user fun(user String s)->(var Int x) _
; @ g t11
struct Test
    var Int x
    new(copy Int x) _
func Test.new(copy Int x)
    self.x := x
; @ eg te0
struct Test
    var Int name
    var Int name
; @ eg te1
struct Test
    func user name()
    var Int name
; @ eg te2
struct Test
    func user name()
    func user name()
; @ eg te3
struct Test
    var Int name
    func user name()
; @ eg te4
struct Test
    var Int x
    func user meth()
        owner Test? error
        error := self
; @ eg te5
struct Test
    var Int x
    func user name() 
; @ eg te6
struct Test
    var Int x
    func user error.name()
; @ eg te7
struct Test
    var Int x
    func user fun()
func Test.fun()
; @ eg te8
func Test.fun()
struct Test
    var Int x
    func user fun() _
func Test.fun()
; @ eg te9
struct Test
    var Int x
    func user fun()
        self..x := 3
; @ ec te10
Test.num
; @ eg te11
struct Test
    var Int x
    func error()
; @ eg te12
struct Test
    var Int x
    func error?()
; @@ test-return
; @ g t0
func name()
    return
; @ g t1
func name()
    raise
; @ g t2
func name()
    raise "some error"
; @ g t3
func name(user Array{String} arr)
    raise arr[3]
; @ c t4
weak String? s
raise s!
; @ ec te0
return()
; @ ec te1
raise()
; @ ec te2
raise 2
; @ ec te3
raise _
; @@ test-code-variables
; @ c t0
var Int x
; @ c t1
user String? s
; @ c t2
owner Array?{Int} a
; @ c t3
user Test? tt
; @ c t4
var String{12} s
; @ c t5
var Array{12:Int} a
; @ c t6
var Array{12:Test} a
; @ c t7
var Array{12:String{7}} sa
; @ c t8
new String{12} s
so := s
; @ c t9
var Array{12:Ta} a
; @ c t10
new Array{12:Int} a
; @ c t11
new Array{12:String{7}} sa
; @ c t12
var Array{3:Array{4:String{5}}} aa
; @ c t13
new Array{3:Array{4:String{5}}} aa
; @ g t14
func fun()
    var String{4} sv
    if 1 > 2
        user Array{Char} su(user sv[1:2])
; @ ec te0
var Int
; @ ec te1
var Int Error
; @ ec te2
var Int errorName
; @ ec te3
var Int name
var Int name
; @ ec te4
var Int name
do
    var Int x
    do
        var Int name
; @ eg te5
var Int name
func mock()
    var Int name
; @ eg te6
func name()
func mock()
    var Int name
; @ eg te7
struct Test
    var Int x(1)
; @ ec te8
new
; @ ec te9
var Array{i:Int} error
; @ ec te10
var Int error--name
; @@ test-initialize
; @ c t0
tb := Tb(copy i)
; @ c t1
str := String{arr![0]}()
; @ c t2
owner Array{Int} a(owner Array{arr![0]:Int}())
; @ c t3
owner Array{Test} a(owner Array{arr![0]:Test}())
; @ c t4
owner Array{String} sa(owner Array{arr![0]:String{arr![1]}}())
; @ c t5
var Int x(copy arr![0])
; @ c t6
user String? s(user ostr)
; @ c t7
var String{12} s(user "some string")
; @ c t8
new String{i} s(user ostr!)
; @ c t9
user Test? tt(user tc!)
; @ c t10
var Tc tt(copy 3)
; @ c t11
new Tc tt(copy 3)
; @ c t12
tb := Tc(copy 3)
; @ c t13
user Tb? tt(user tb)
; @ c t14
owner Ta? ota(owner tb)
; @ c t15
owner Array{Array{String}} sa(owner Array{arr![0]:Array{arr![1]:String{arr![2]}}}())
; @ g t16
func get()->(owner File? a)
    owner File? b(owner get())
; @ c t17
owner Test? ot(owner to)
strong Test? st(strong ot)
; @ c t18
s-var Tc tt(copy 3)
; @ ec te0
Int()
; @ ec te1
var String s
; @ ec te2
var Array{4:String} sa
; @ ec te3
new String s
; @ ec te4
String()
; @ ec te5
user Array a
; @ ec te6
new Array a
; @ ec te7
Array()
; @ ec te8
var Array{23} a
; @ eg te9
struct Test{Generic}
    owner Array{Generic} arr
; @ ec te10
var Array{1
; @ ec te11
var String{12
; @ ec te12
var Array{error:Int} a
; @ ec te13
var Array{"12":Int} a
; @ ec te14
user Int x
; @ ec te15
new Int x
; @ ec te16
var Array{4:Int} a(copy 1)
; @ ec te17
var Bool x(var 1)
; @ ec te18
var Int x(var 1, var 2)
; @ eg te19
struct Test
    var Int x
func mock()
    Test(copy 1)
; @ ec te20
var Int x(user 3)
; @ ec te21
owner String? s(user so)
; @ ec te22
owner String? s(owner str)
; @ ec te23
var Array{1:Int:Int} a
; @ ec te24
owner Test? ot(owner tb)
; @ ec te25
user String s
s.clear()
; @ ec te26
user String s(user _)
; @ ec te27
user String s(user str)
; @ ec te28
i := error
var Int error
; @ ec te29
var Int error(copy error)
; @ ec te30
if b
    var Int error
i := error
; @ ec te31
new Test? a
; @ ec te32
to := Test?()
; @@ test-comment
; @ c t0
; comment

var Int x
; @ c t1
~~~ documemtation ~~~

var Int x
; @ c t2
[; multi 
line 
comment ;]

var Int x
; @ c t3
~~~ multi 
line 
documemtation
~~~

var Int x
; @@ test-if-else
; @ c t0
if t!.num > 3
    i -= 2
; @ c t1
if i > 3
    i -= 2
else
    i += 1
; @ c t2
if i > 3
    i -= 3
else-if t!.num > 2
    i -= 2
else-if t!.num > 1
    i -= 1
else
    i += 1
; @ c t3
if b
    return
i := 3
; @ c t4
if b and
        b
    i += 1
; @ c t5
if b
    var String{4} sa
    if b
        var String{4} sb
    else-if b
        var String{4} sc
    else
        var String{4} sd
else-if b
    var String{4} se
else
    var String{4} sf
; @ ec te0
if 3
; @ ec te1
if b
    error
; @ ec te2
if b
    i := 0
else
    error
; @ ec te3
if b
    i := 0
else-if b
    error
; @ ec te4
if b
    return
    i := 3
; @ ec te5
if()
; @ ec te6
else
; @ ec te7
if false
    ; ...
else 
; @ ec te8
else-if
; @ ec te9
if false
    ; ...
else-if()
; @ feg te10
func error()
    if b
; @@ test-do-loop
; @ c t0
do
    var Int x
; @ c t1
do
    break
; @ c t2
do
    while t!.num > 3
; @ c t3
do
    continue
; @ c t4
do
    if true
        while false
; @ c t5
do
    var String{4} sa
    while b
    break
    continue
    if b
        return
    do
        var String{4} sb
        while b
        break
        continue
        if b
            return
        do
            var String{4} sc
            while b
            break
            continue
            if b
                return
; @ ec te0
do(
; @ ec te1
while true
; @ ec te2
continue
; @ ec te3
do
    while 2
; @ ec te4
do
    error
; @ ec te5
do
    var Int error
do
    var Int error
; @ ec te6
do
    while i := 3
; @ ec te7
do
    while
; @ ec te8
do
    continue error
; @ ec te9
break
; @ ec te10
do
    break error
; @@ test-for-loop
; @ c t0
for n in 5
    i += n
; @ c t1
for n in t!.num:ostr!.length() + 2
    i += n
; @ c t2
for ch in ostr!
    c := ch
; @ c t3
for n in arr!
    i += n
; @ c t4
for s in sarr!
    s.set(copy 0, copy 'a')
; @ c t5
var Int n
for n in 5
    i += n
; @ c t6
for n in 5
    i += n
for n in 7
    i += n
; @ c t7
for n in 1 +
        2
    i += n
; @ c t8
for n in 6
    var String{4} sa
    break
    continue
    if b
        return
    for ch in ostr!
        var String{4} sb
        break
        continue
        if b
            return
; @ c t9
user String s(user "text")
for ch in s
    c := ch
; @ c t10
var Array{3:String{4}} sa
for s in sa
    s.set(copy 0, copy 'a')
; @ ec te0
for(
; @ ec te1
for n
; @ ec te2
for n error
; @ ec te3
for n in fun0()
; @ ec te4
for n in str:8
; @ ec te5
for n in 5
    error
; @ ec te6
for n in arr!
    i += n
for n in sarr!
; @ ec te7
for n in 7
    i += 1
var Int n
; @@ test-testing
; @ c ta0
assert t!.num = 2
; @ c ta1
assert-error t!.num
; @ c ta2
assert-error fun0()
; @ c ta3
assert-error t!.num, "expected error"
; @ c ta4
assert-error fun0(), "expected error in the function"
; @ c ta5
assert-error t!.num,
        "expected error in new line"
; @ c ta6
if b
    var String{4} s
    assert b
    assert-error s[1:2]
    do
        assert-error s[1:2]
; @ g tm0
func fun()
    fun()
mock fun()
    raise
; @ g tm1
mock fun()
func fun()
    fun()
; @ g tm2
mock Test.meth(copy Int x)
struct Test
    var Int x
    func user meth(copy Int x)
        self.meth(copy x)
; @ g tm3
mock Test.meth(copy Int x)
class Test
    var Int x
    func dynamic user meth(copy Int x)
        self.meth(copy x)
; @ g tm4
func fun(copy Int x)->(var Int y)
mock fun(copy Int x)->(var Int y)
    fun.mocked(copy x)->(var y)
    fun.active := false
    fun(copy x)->(var y)
    fun.active := true
; @ g tm5
struct Test
    var Int x
    func user meth(copy Int x)->(var Int y)
        self.meth(copy x)->(var y)
mock Test.meth(copy Int x)->(var Int y)
    self.meth.mocked(copy x)->(var y)
    Test.meth.mocked(user self, copy x)->(var y)
    self.meth.active := false
    Test.meth(user self, copy x)->(var y)
    Test.meth.active := true
; @ g tm6
class Test
    var Int x
    func dynamic user meth(copy Int x)->(var Int y)
        self.meth(copy x)->(var y)
mock Test.meth(copy Int x)->(var Int y)
    Test.meth.mocked(user self, copy x)->(var y)
    Test.meth.active := false
    Test.meth(user self, copy x)->(var y)
    Test.meth.active := true
; @ g tm7
func fun()
    sys.print(user "mock print")
    sys.print.mocked(user "really print")
    Sys.print.active := false
    sys.print.active := true
mock Sys.print(user Array{Char} text)
; @ g tm8
struct Test
    var Int x
    new(copy Int x)
mock Test.new(copy Int x)
func fun()
    var Test t(copy 2)
; @ tg tt0
func fun0()
    var Int x(copy 4)
    x += 1
    var Int y(copy 5)
    y := x
    if y > 3
        y := 3
    else-if y < 0
        y := 0
    else
        y += 1
    try
        x := 0
        sys.print(user "")
        y := 0
    catch
        x := 1
        x := 2
    if x > 3
        return
    else
        raise
    do
        while x > 1
        if x = 5
            continue
    for n in 3
        x += y
; @-
module ut
func fun1()
    fun0()
test fun2()
    fun1()
; @ tg tt1
func fun()
    var Int x
main
; @-
module second
test fun0()
test fun1()
; @ g tmg0
mock Test.delete()
    var Ref? r(copy self)
struct Test
    weak String? s
; @ g tmg1
mock delete()
    var Ref? r(copy self)
main
; @ g tmg2
mock new()->(var Bool allocate-success)
    allocate-success := false
main
; @ c tr0
var Ref r
; @ c tr1
var Ref r
r := ostr
; @ c tr2
var Ref r
r := _
; @ c tr3
var Ref r(copy ostr)
; @ c tr4
var Ref r
assert r is r
; @ ec te0
assert 3
; @ ec te1
assert error
; @ ec te2
assert-error error
; @ eg te3
test fun(copy Int x)
; @ eg te4
test fun()->(copy Int x)
; @ eg te5
mock error()
; @ eg te6
mock Error.fun()
; @ eg te7
struct Test
    var Int x
mock Test.error()
; @ eg te8
mock fun(owner String s)
func fun(user String s)
; @ eg te9
mock fun(user Int s)
func fun(user String s)
; @ eg te10
mock fun(user Array{Char} a)
func fun(user Array{Int} a)
; @ ec te11
assert
; @ ec te12
assert-error
; @ eg te13
mock()
; @ eg te14
func fun()
mock fun()
mock fun()
; @ eg te15
struct Test
    var Int x
    func user fun()
mock Test.fun()
mock Test.fun()
; @ eg te16
mock delete()
mock delete()
; @ eg te17
struct Test
    var Int x
mock Test.delete()
mock Test.delete()
; @ ec te18
assert-error t.num , "error"
; @ ec te19
assert-error t.num,"error"
; @ ec te19-copy
assert-error t.num,"error"
; @ ec te20
assert-error t.num,  "error"
; @ ec te21
assert-error t.num, error
; @ eg te22
mock new()->(var Bool res)
mock new()->(var Bool res)
; @ eg te23
mock new()->(var Int x)
; @ eg te24
mock new()
; @ eg te25
mock new(copy Int x)->(var Bool res)
; @ eg te26
mock new()->(var Bool res, var Int x)
; @ eg te27
mock delete(copy Int x)
; @ eg te28
mock delete()->(copy Int x)
; @ eg te29
func fun()
mock fun()
    fun.error
; @ eg te30
class Test
    var Int x
    func dynamic user meth()
mock Test.meth()
    self.meth.mocked()
; @ eg te31
test
; @ eg te32
struct Test
    owner String s
    new()
        self.s := String{12}()
mock Test.new()
; @@ test-native
; @ g tf0
native func external()
func call()
    external()
; @ g tf1
class Test
    var Int x
    func dynamic user meth()
native func external(copy Int i, user String? s, user Test? ta)->(var Int io)
func call()
    var Int i
    user String? s
    user Test? ta
    external(copy 5, user s, user ta)->(var i)
; @ g tv0
native var Int x
func use()
    x := 2
; @ g tt0
native type Native
native func external(copy Native n)->(var Native no)
; @ eg te0
native()
; @ eg te1
native error
; @ eg te2
native error 
; @ eg tef1
native func error(owner String s)
; @ eg tef2
native func error()->(user String? s)
; @ eg tef3
native func error()->(owner String? s)
; @ eg tef4
native func error()
native func error()
; @ eg tev3
native var String s
; @@ test-parameter-type
; @ g t0
struct Test{Generic}
    weak Generic? item
    func user set(weak Generic item)
        weak Generic x(weak item)
        self.item := x
        new Test{Generic} t
        t.item := self.item
        self.item := t.item
; @ g t1
struct Test{Generic}
    owner Generic? item
    func user get()->(user Generic? item)
        item := self.item
; @ g t2
struct Test{First:Second:Third}
    weak First? first
    weak Second? second
    weak Third? third
    func user set(weak First first, weak Second second, weak Third third)
        self.first := first
        self.second := second
        self.third := third
func use(weak File first, weak Sys second, weak File third)
    var Test{File:Sys:File} t
    t.first := first
    t.second := second
    t.third := third
    t.set(weak first, weak second, weak third)
; @ g t3
struct Base
    var Int x
struct Test{Generic}(Base)
; @ c t4
d!.item := t
; @ c t5
t := d!.item
; @ c t8
var Array{5:Data{Test}} ad
t := ad[2].item
; @ c t10
d!.set(owner _)
; @ c t11
var Data{Data{Data{Test}}} dr
t := dr.item!.item!.item
; @ c t12
d!.set(owner to)
; @ c t13
d!.get()->(weak t)
d!.get()!.meth()
; @ c t14
var Data dg
; @ c t15
user Data? dg(user d!)
; @ c t16
Data{Test}.set(user d!, owner to)
; @ g t17
struct Test{Generic}
    weak Test?{Generic} next
    func user meth(weak Test{Generic} next)->(user Test?{Generic} out)
        self.next := next
        out := self
; @ c t18
var Data{Tb} dt
dt.item := tc
ta := dt.item
owner Tc? otc
dt.set(owner otc)
dt.get()->(weak ta)
i := dt.get()!.numa
fun7(weak dt.item)->(weak dt.item)
user Tb? tb2(user dt.item!)
tb2 := dt.item!
; @ g t19
struct Base{Generic}
    weak Generic? item
    func user get()->(weak Generic? item)
struct Test(Base{File})
    func user set(weak File? f)
        self.item := f
        self.get()->(weak f)
func fun(user Test test, weak File? f)
    test.item := f
    test.set(weak f)
    f := test.item
    test.get()->(weak f)
    test.get()!.putc(copy 'a')
; @ g t20
class Base{Param}
    weak Param? item
    func dynamic user set(weak Param? item)
    func dynamic user get()->(weak Param? item)
class Test{Generic}(Base{Generic})
    func dynamic user set(weak Generic item)
    func dynamic user get()->(weak Generic? item)
func mock(weak Test{File} test, weak File? f)
    test!.set(weak f)
    test!.get()->(weak f)
    test!.get()!.putc(copy 'a')
; @ g t21
struct Test{Param}
    weak Param? item
    func user meth(weak Param? in)->(weak Param? out) _
func Test.meth(weak Param? in)->(weak Param? out)
    weak Param? p(weak in)
    out := p
    self.item := p
    self.meth(weak p)->(weak p)
; @ eg teg0
struct Test{First:Second:Third
; @ eg teg1
struct Test{Generic}
    var Generic error
; @ eg teg2
struct Test{Generic}
    weak Generic? item
    func user meth(copy Generic error)
; @ eg teg3
struct Test{Generic}
    weak Generic? item
    func user meth(weak String s)
        self.item := s
; @ eg teg4
struct Test{Generic}
    weak Generic? item
    func user meth()->(user String? s)
        s := self.item!
; @ eg teg5
struct Test{Generic}
    weak Generic? item
    func user meth()
        var Generic error
; @ eg teg6
struct Test{First:Second}
    weak First? first
    weak Second? second
    func user meth()
        self.first := self.second
; @ eg teg7
struct Test{error}
    var Int x
; @ eg teg11
struct Test{First:Second:Third}
    weak First first
    weak Second second
    weak Third third
func meth(user Test{File:File} t)
    user Test{File:File:File} error(user t)
; @ eg teg12
struct Base{Param}
    weak Param item
struct Error(Base)
; @ eg teg13
struct Base
    weak Int x
struct Error(Base{File})
; @ eg teg14
struct Base{Param}
    weak Param item
struct Error(Base{File:File})
; @ eg teg15
struct Base{Param0:Param1}
    weak Param0 item0
    weak Param1 item1
struct Error(Base{File})
; @ ec tec0
var Data{Int} error
; @ ec tec1
var Data{File:File} error
; @ ec tec2
var Data{Error} error
; @ ec tec3
var Char{File} error
; @ ec tec4
var Data dg
str := dg.item!
; @ ec tec5
s-var Data dg
d := dg
; @ ec tec6
str := d!.item!
; @ ec tec7
var Data{Array{Int}} error
; @ ec tec8
var Data{String} error
; @@ test-parameter-inheritance
; @ g t0
struct Base{Generic}
    weak Generic? item
struct Test(Base{File})
    func user set(weak File f)
        self.item := f
        Test.set(user Test(), weak f)
func use(weak File f)
    var Test t
    t.item := f
; @ g t1
struct Base{Generic}
    weak Generic? item
struct Test{Param}(Base{Param})
    func user set(weak Param i, weak File f)
        self.item := i
        Test{File}.set(user Test{File}(), weak f, weak f)
func use(weak File f)
    var Test{File} t
    t.item := f
; @ g t2
struct Base{Pbase}
    weak Pbase? item
    func user set(weak Pbase i)
struct Mid{Pmid}(Base{Pmid})
    func user set(weak Pmid i)
struct Top(Mid{File})
    func user set(weak File f)
        base(weak f)
        self.item := f
struct Test(Top)
    func user set(weak File f)
        base(weak f)
        self.item := f
        Top.set(user Top(), weak f)
        Test.set(user Test(), weak f)
        Mid{File}.set(user Top(), weak f)
func use(weak File f)
    var Test t
    t.item := f
; @ g t3
struct Base{Generic}
    weak Generic? item
struct Test{Generic}(Base{Generic})
    func user set(weak Generic i, weak File f)
        self.item := i
        Test{File}.set(user Test{File}(), weak f, weak f)
func use(weak File f)
    var Test{File} t
    t.item := f
; @ g t4
struct Base{First:Second}
    weak First? first
    weak Second? second
struct Mid{Param:Third}(Base{Param:Sys})
    weak Third? third
    func user set(weak Param first, weak Sys second, weak Third third)
        self.first := first
        self.second := second
        self.third := third
struct Top{Generic}(Mid{Generic:File})
    func user set(weak Generic first, weak Sys second, weak File third)
        self.first := first
        self.second := second
        self.third := third
struct Test(Top{File})
    func user set(weak File first, weak Sys second, weak File third)
        self.first := first
        self.second := second
        self.third := third
func use(weak File first, weak Sys second, weak File third)
    var Test t
    t.first := first
    t.second := second
    t.third := third
; @ g t5
struct First{FirstGeneric}
    weak FirstGeneric? item
struct Second{SecondGeneric}
    weak SecondGeneric? item
struct Test{Generic}(First{Second{Generic}})
    func user set(weak Generic g, weak Second{Generic} sg)
        self.item := sg
        self.item!.item := g
func use(weak File f, weak Second{File} ff)
    var Test{File} t
    t.item := ff
    t.item!.item := f
; @ g t6
struct BaseGen{FirstGeneric}
    weak FirstGeneric? item
struct TestGen{SecondGeneric}(BaseGen{SecondGeneric})
struct Base
    var Int x
struct Test(Base)
func test()
    user BaseGen?{Base} bb
    user BaseGen?{Test} bt
    user TestGen?{Base} tb
    user TestGen?{Test} tt
    bb := tb
    bt := tt
    bb := bt
    tb := tt
    bb := tt
; @ g t7
struct Base{Generic}
    weak Generic? first
struct Mid{First:Second}(Base{First})
    weak Second? second
struct Top{Generic}(Mid{Sys:Generic})
func fun(user Top?{File} t)
    user Mid?{Sys:File} m
    m := t
; @ eg te0
struct Base{Generic}
    weak Generic item
struct Test{Param}(Base{Param})
    weak Generic error
; @ eg te1
struct Base{Generic}
    weak Generic? item
struct Test(Base{File})
    func user set(weak String error)
        self.item := error
; @ eg te2
struct Base{Generic}
    weak Generic? item
struct Test{Param}(Base{Param})
    func user set(weak String error)
        self.item := error
; @ eg te3
struct Base{Pbase}
    weak Pbase? item
struct Mid{Pmid}(Base{Pmid})
struct Top(Mid{File})
struct Test(Top)
    func user set(weak String error)
        self.item := error
; @@ test-error-handling
; @ c t0
try
    t!.num := 1
    fun0()
catch
    i := t!.num
    fun4(copy 2)
; @ c t1
try
    t!.num := 1
    fun0()
; @ c t2
try
    t!.num := 1
    try
        fun0()
    catch
        fun4(copy 2)
catch
    try
        i := arr![3]
    catch
        i := t!.num
; @ c t3
try
    var String{4} sa
    try
        var String{4} sb
    catch
        var String{4} sc
catch
    var String{4} sd
    try
        var String{4} se
    catch
        var String{4} sf
; @ ec te0
try()
; @ ec te1
catch
; @ ec te2
try
catch()
; @ ec te3
try
; @ ec te4
try
    i := 1
catch
; @ ec te5
try
    i := 1
i := 2
catch
    i := 3
; @@ test-for-each
; @ g t0
struct TestIterator
    var Int counter
    new(copy Int count)
    func user has()->(var Bool has-data)
    func user get()->(var Int num)
    func user next()
func fun()->(var Int i)
    for n in TestIterator(copy 6)
        var String{4} s
        i := n
; @ g t1
struct TestIterator
    weak String? value
    func user has()->(var Bool has-data)
    func user get()->(user String? text)
        text := self.value!
    func user next()
func fun(user TestIterator iter)
    user String? s
    for t in iter
        s := t
; @ g t2
struct TestIterator{Generic}
    weak Generic? item
    func user has()->(var Bool has-data)
    func user get()->(user Generic? item)
        item := self.item!
    func user next()
class Test
    var Int x
    func dynamic user fun()
func fun(user TestIterator{File} fiter, user TestIterator{Test} titer)
    user File? of
    user Test? ot
    for f in fiter
        of := f
    for t in titer
        ot := t
; @ g t3
class TestIterator{Generic}
    weak Generic? item
    func dynamic user has()->(var Bool has-data)
    func dynamic user get()->(user Generic? item)
        item := self.item!
    func dynamic user next()
func f-mock(user TestIterator{File} iter)
    user File? f
    for t in iter
        f := t
; @ eg te0
struct TestIterator
    var Int num
    func user get()->(var Int num)
    func user next()
func f-mock()
    for n in TestIterator()
; @ eg te1
struct TestIterator
    var Int num
    func user has(copy Int x)->(var Bool has-data)
    func user get()->(var Int num)
    func user next()
func f-mock()
    for n in TestIterator()
; @ eg te2
struct TestIterator
    var Int num
    func user has()
    func user get()->(var Int num)
    func user next()
func f-mock()
    for n in TestIterator()
; @ eg te3
struct TestIterator
    var Int num
    func user has()->(var Bool has-data, var Int x)
    func user get()->(var Int num)
    func user next()
func f-mock()
    for n in TestIterator()
; @ eg te4
struct TestIterator
    var Int num
    func user has()->(var Int x)
    func user get()->(var Int num)
    func user next()
func f-mock()
    for n in TestIterator()
; @ eg te5
struct TestIterator
    var Int num
    func user has()->(var Bool has-data)
    func user next()
func f-mock()
    for n in TestIterator()
; @ eg te6
struct TestIterator
    var Int num
    func user has()->(var Bool has-data)
    func user get(user Int x)->(var Int num)
    func user next()
func f-mock()
    for n in TestIterator()
; @ eg te7
struct TestIterator
    var Int num
    func user has()->(var Bool has-data)
    func user get()
    func user next()
func f-mock()
    for n in TestIterator()
; @ eg te8
struct TestIterator
    var Int num
    func user has()->(var Bool has-data)
    func user get()->(var Int num, var Int x)
    func user next()
func f-mock()
    for n in TestIterator()
; @ eg te9
struct TestIterator
    var Int num
    func user has()->(var Bool has-data)
    func user get()->(owner String s)
    func user next()
func f-mock()
    for n in TestIterator()
; @ eg te10
struct TestIterator
    var Int num
    func user has()->(var Bool has-data)
    func user get()->(weak String s)
    func user next()
func f-mock()
    for n in TestIterator()
; @ eg te11
struct TestIterator
    var Int num
    func user has()->(var Bool has-data)
    func user get()->(var Int num)
func f-mock()
    for n in TestIterator()
; @ eg te12
struct TestIterator
    var Int num
    func user has()->(var Bool has-data)
    func user get()->(var Int num)
    func user next(user Int x)
func f-mock()
    for n in TestIterator()
; @ eg te13
struct TestIterator
    var Int num
    func user has()->(var Bool has-data)
    func user get()->(var Int num)
    func user next()->(var Int x)
func f-mock()
    for n in TestIterator()
; @ eg te14
struct ConditionalIterator
    weak String str
    func user has()->(var Bool has-data)
    func user get()->(var String? num)
    func user next()
struct NonConditionalIterator
    weak String str
    func user has()->(var Bool has-data)
    func user get()->(var String num)
    func user next()
func f-mock()
    for s in NonConditionalIterator()
    for s in ConditionalIterator()
; @@ test-complex-fields
; @ g t0
struct Test
    var Bstruct b
    s-var Bstruct sb
    func user test()
        weak Bstruct b(weak self.sb)
        b := self.sb
        self.b.meth()
        Bstruct.meth(user self.b)
        user Bstruct? b2(user self.b.b!)
        b2 := self.b.b!
        self.b.b!.meth()
        self.b.b := b
        Bstruct.meth(user self.b.b!)
        s-var Test t
        self.b.x := 5
        Astruct.meth(user self.b)
        if self.b is b or b2 is-not self.b
        b := t.b
class Astruct
    var Int x
    func dynamic user? meth()
class Bstruct(Astruct)
    weak Bstruct? b
    func dynamic user? meth()
; @ g t1
struct Base
    var Int x
struct Test
    var String{10} s
    var Array{11:Int} ai
    var Array{12:Base} ab
    var Array{7:String{8}} as
    var Array{4:Array{5:Array{6:Int}}} aai
    var Array{4:Array{5:Array{6:Base}}} aab
    var Array{4:Array{5:String{6}}} aas
    func user test()->(var Char c, var Int i, user Base? b)
        c := self.s[3]
        i := self.ai[4]
        b := self.ab[5]
        c := self.as[4][5]
        i := self.aai[1][2][3]
        b := self.aab[1][2][3]
        c := self.aas[1][2][3]
; @ eg te0
var Int x
struct Test
    var String{x} error
; @ eg te1
var Int x
struct Test
    var Array{x:Int} error
; @ eg te2
struct Test
    var Test error
; @ eg te3
struct Test
    var Base error
struct Base
    var Test t
; @ eg te4
struct Abase
    var Berror b
struct Aerror(Abase)
struct Bbase
    var Aerror a
struct Berror(Bbase)
; @ eg te5
struct Base
    var Int x
struct Test
    var Base b
    func user test(user Base b)
        self.b := b
; @ eg te6
struct Base
    var Int x
struct Test
    var Base b
    func user error()
        assert self.b?
; @@ test-enum
; @ g t0
enum MyEnum
    VALUE
    ANOTHER-VALUE
    LAST-VALUE
func dummy()
    var Int x(copy MyEnum.VALUE)
    x += MyEnum.ANOTHER-VALUE
    x -= MyEnum.length
; @ g t1
enum MyEnum
    VALUE
    ANOTHER-VALUE
    LAST-VALUE
var Array{MyEnum.length:Int} arr
; @ eg te0
enum MyEnum
    VALUE
func dummy()
    var Int x(copy MyEnum.ERROR)
; @ ec te1
i := Error.VALUE
; @ eg te2
enum MyEnum
    VALUE
func dummy()
    var Int x(copy MyEnum.error)
; @ eg te3
enum My-Enum
; @ eg te4
enum MyEnum
    Error
; @ eg te5
enum MyEnum
    ERRoR
; @ eg te6
enum
; @ eg te7
enum MyEnum
    VALUE(0)
; @ eg te8
enum MyEnum
; @ eg te9
enum MyEnum
        VALUE
; @ eg te10
enum Error
    VALUE
enum Error
; @ eg te11
struct Error
    var Int x
enum Error
; @ eg te12
enum Error
    VALUE
struct Error
    var Int x
; @@ test-constant
; @ g t0
const Int NUMBER 12
; @ g t1
const Int SIZE 12
var Array{SIZE + 3:Int} arr
func fun(user Array{Int} a)
    fun(user arr)
; @ g t2
const Int LARGE - (2 * SMALL) + 1
const Int SMALL 7
; @ g t3
enum MyEnum
    VALUE
const Int NUMBER MyEnum.VALUE
; @ eg te0
const
; @ eg te1
const Bool
; @ eg te2
const Int
; @ eg te3
const Int Error
; @ eg te4
const Int ERROR
; @ eg te5
const Int NAME false
; @ eg te6
var Int x
const Int NAME x
; @ eg te7
const Int ERROR ERROR + 1
; @ eg te8
const Int A-ERROR B-ERROR
const Int B-ERROR - (2 * A-ERROR) + 1
; @ eg te9
const Int NUMBER 12
func dummy()
    NUMBER := 3
; @ eg te10
const Int NUMBER 12
func dummy()->(var Int x)
    dummy()->(var NUMBER)
; @@ test-module
; @ tg t0
enum Enum
    VALUE
const Int SIZE 12
struct Test
    var Int x
    func user meth()
var Test t
func fun()
    t.x := Enum.VALUE + SIZE
    fun()
    Test.meth(user t)
    second.t.x := second.Enum.VALUE + second.SIZE
    second.fun()
    second.Test.meth(user second.t)
    new second.Test nt
; @-
module second
enum Enum
    VALUE
const Int SIZE 12
struct Test(ut.Test)
    func user meth()
var Test t
func fun()
    t.x := Enum.VALUE + SIZE
    fun()
    Test.meth(user t)
    ut.t.x := ut.Enum.VALUE + ut.SIZE
    ut.fun()
    ut.Test.meth(user ut.t)
    new ut.Test nt
test dummy()
; @ tg t1
func fun()
struct Test
    var Int x
    func user meth()
        fun()
        self.meth()
; @-
module second
mock ut.fun()
mock ut.Test.meth()
test dummy()
; @ tg t2
native type Native
native var Int x
native func external()
func fun()
    x := 0
; @-
module second
test use()
    var Native n
    x := 2
    external()
; @ ec te0
ut.error
; @ eg te1
var Int ut
; @ eg te2
func ut()
; @ eg te3
var error.Test x
; @ eg te4
var ut.Error x
; @ etg te5
; nothing
; @-
module(error)
; @ etg te6
; @-
module Error
; @ etg te7
; @-
module true
; @ etg te8
; @-
module file-open-read
; @ etg te9
; @-
func fun()
; @ ec te10
fun0().Error
; @ ec te11
i.Error
; @ ec te12
ut.Error.VALUE
; @@ test-memory
; @ g to0
struct Test
    owner String? s
    owner String str
    new()
        self.str := String{12}()
        self.str.clear()
func use(user String? s)
func take(owner String? s)
func give()->(owner String? s)
func fun(owner String? s, user Test tu, owner Test to)
    s := _
    s := String{12}()
    s!.set(copy 0, copy 'a')
    to.s := String{12}()
    user String? su(user tu.s)
    use(user tu.s)
    take(owner to.s)
    var Array{12:Int} arr
    arr[4] := arr[8]
    do
        give()->(owner s)
; @ g tu0
func deleting()->(owner String? s)
    s := _
func fun(user String s)->(owner String? so)
    s.set(copy 0, copy 'a')
    deleting()->(owner so)
; @ g tu1
func deleting()->(strong String? s)
    s := _
func fun()
    strong String? so(strong String{12}())
    user String? s(user so)
    s!.set(copy 0, copy 'a')
    deleting()->(strong so)
; @ g tu2
func deleting()->(strong String? s)
    s := _
func fun()
    strong String? so(strong String{12}())
    weak String? s(weak so)
    deleting()->(strong so)
    s!.set(copy 0, copy 'a')
; @ c tu3
user String? s
so := _
s := so
s!.set(copy 0, copy 'a')
; @ g tu4
struct Test
    weak String? s
    func user get()->(user String? s) _
func Test.get()->(user String? s)
    s := self.s!
func fun(user Test t)->(user String? s)
    t.get()->(user s)
    s!.set(copy 0, copy 'a')
; @ c tu5
user String? s(user ostr)
ostr := _
for s in sarr!
    s!.clear()
; @ g tb0
struct Test
    owner String? s
func fun(var Test t)
    t.s := _
func use(owner Test to)
    fun(var to)
; @ eg teo0
struct Test
    owner String s
    new()
func fun(user Test t)
    t.s := String{12}()
; @ eg teo1
struct Aa
    var Int x
struct Bb
    owner Aa? a
func fun(user Bb b)
    owner Aa? a(owner b.a)
; @ eg teo2
struct Aa
    var Int x
struct Bb
    owner Aa? a
func take(owner Aa? a)
func fun(user Bb b)
    take(owner b.a)
; @ eg teo3
struct Aa
    owner String? s
struct Bb
    weak Aa? a
func fun(owner Array{Bb} b)
    b[3].a!.s := _
; @ eg teo4
struct Test
    owner String? s
func get-user()->(weak Test? t)
func fun()
    weak Test? t
    get-user()->(weak t)!.s := _
; @ eg teo5
struct Test
    owner String? s
func get-weak()->(weak Test? t)
func fun()
    get-weak()!.s := _
; @ eg teo6
struct Test
    owner String s
    new()
func fun(owner Test t)->(owner String? s)
    s := t.s
; @ eg teo7
struct Test
    owner String s
    new()
func fun(owner Test t)
    owner String s(owner t.s)
; @ eg teo8
struct Test
    owner String s
    new()
func take(owner String s)
func fun(owner Test t)->(owner String? s)
    take(owner t.s)
; @ ec teo9
new String{12} s
new String{12} sg
ostr := sg
sg := s
ostr!.clear()
sg.clear()
s.clear()
; @ eg teo10
struct Test
    owner Test? t
func fun()->(owner Test? t, owner Test? x)
    t := x!.t
    t := t!.t
; @ eg teo11
struct Test
    owner Test? t
func fun(owner Test? t)
    t := t!.t
; @ eg teo12
struct Test
    owner Test? t
func fun(owner Test? t)
    t!.t := t
; @ eg teo13
struct Test
    owner Test? t
func fun(owner Test? t)
    t!.t!.t := t!.t
; @ eg teo14
struct Test
    owner String s
    new()
func fun(owner Test t, user Test tu, owner String s, user String su)
    t.s :=: s
    su.clear()
    s.clear()
    t.s.clear()
    tu.s :=: s
; @ ec teo15
fun8(strong so)
so!.clear()
new String{12} s
fun8(strong s)
s.clear()
; @ ec teo16
new Test tgood
owner Test tbad
if b
    tgood := to!
tgood.meth()
if b
    tbad := to!
tbad.meth()
; @ ec teo17
new String{12} s
do
    s.clear()
    ostr := s
    if b
        continue
    s := String{12}()
; @ eg teo18
func fun(owner String? s, owner String? s2)
    fun(owner s, owner s)
; @ eg teo19
func fun()->(owner String? s, owner String? s2)
    fun()->(owner s, owner s2)
    fun()->(owner s, owner s)
; @ eg teo20
func fun(owner String? s)->(owner String? s2)
    fun(owner s)->(owner s)
; @ eg teo21
struct Test
    var Int x
func fun(owner Test? t)->(var Int x)
    x := fun(owner t) + t!.x
; @ eg teo22
struct Test
    var Int x
func fun(owner Test? t)->(var Int x)
    x := t!.x + fun(owner t)
; @ eg teo23
struct Test
    var Int x
func fun(owner Test? t)->(var Int x)
    for _ in fun(owner t):t!.x
; @ eg teo24
struct Test
    var Int x
func fun(owner Test? t)->(var Int x)
    for _ in t!.x:fun(owner t)
; @ ec teo25
new String{12} s
try
    owner String s2(owner s)
    if b
        raise
    s := s2
s.clear()
; @ ec teu0
user String? s
so := _
c := s![2]
; @ ec teu1
user String? s
user String? s2
so := _
s2 := s
; @ ec teu2
user String? s
so := _
s!.length()->(var i)
; @ ec teu3
user String? s
so := _
String.set(user s!, copy 0, copy 'a')
; @ ec teu4
user String? s
so := _
b := not (false or s!.length() > 3)
; @ eg teu5
func deleting(owner String? s)
func fun(user String s)
    deleting(owner _)
    s.set(copy 0, copy 'a')
; @ eg teu6
func deleting()->(owner String? s)
    s := _
func proxy()
    deleting()
func fun(user String s)
    proxy()
    s.set(copy 0, copy 'a')
; @ eg teu7
func deleting()->(owner String? s)
    proxy()
    s := _
func proxy()
    deleting()
func fun(user String s)
    proxy()
    s.set(copy 0, copy 'a')
; @ eg teu8
struct Test
    var Int x
    func user deleting()->(owner String? s)
        s := _
    func user fun(user String s)
        self.deleting()
        s.set(copy 0, copy 'a')
; @ eg teu9
func deleting()->(owner String? s)
    s := _
func fun(user String s)
    deleting()
    s.set(copy 0, copy 'a')
; @ eg teu10
func deleting()
    owner String? s
func fun(user String s)
    deleting()
    s.set(copy 0, copy 'a')
; @ eg teu11
func deleting()
    var String{12} s
func fun(user String s)
    deleting()
    s.set(copy 0, copy 'a')
; @ eg teu12
func deleting()
    strong String? s
func fun(user String s)
    deleting()
    s.set(copy 0, copy 'a')
; @ ec teu13
user Array{Char} a(user ostr!)
ostr := _
c := a[2]
; @ eg teu14
func deleting()
    var Int x(copy String{12}().length())
func fun(user String s)
    deleting()
    s.set(copy 0, copy 'a')
; @ eg teu15
struct Test
    owner String? s
func deleting(owner Test? ta, owner Test? tb)
    ta!.s := tb!.s
func fun(user String s)
    deleting(owner _, owner _)
    s.set(copy 0, copy 'a')
; @ ec teu16
user Test? tt
d!.set(owner _)
tt.meth()
; @ eg teu17
struct Base{Atype}
    var Int x
    func user fun(owner Atype? a)
struct Test{Btype}(Base{Btype})
    func user fun()
        base(owner _)
func fun(user File f)
    var Test{File} t
    t.fun()
    f.putc(copy 'a')
; @ eg teu18
struct Base
    var Int x
struct Test(Base)
func deleting(owner Base? b)
func fun(user Test t)
    deleting(owner _)
    t.x := 0
; @ eg teu19
struct Base
    var Int x
struct Test(Base)
struct Other(Base)
func deleting(owner Test? t)
func fun(user Base b, user Other o)
    deleting(owner _)
    o.x := 0
    b.x := 0
; @ eg teu20
class Base
    var Int x
    func dynamic user fun()
class Test(Base)
    func dynamic user fun()
        owner String? s
func fun(user String s, user Base b)
    b.fun()
    s.set(copy 0, copy 'a')
; @ eg teu21
class Base
    var Int x
    func dynamic user fun()
class Test{Generic}(Base)
    func dynamic user fun()
func fun(user String s, user Base b)
    b.fun()
    s.set(copy 0, copy 'a')
; @ eg teu22
class Base
    var Int x
    func dynamic user? fun(owner Base? b)
        recursive()
class Test{Generic}(Base)
    func dynamic user fun()
func recursive()
    Base.fun(user _, owner _)
func fun(user String s)
    recursive()
    s.set(copy 0, copy 'a')
; @ ec teu23
user String? s
t!.fun()
s!.set(copy 0, copy 'a')
; @ eg teu24
func deleting(copy Func?{()} f)
    f!()
func fun(user String s)
    deleting(copy _)
    s.set(copy 0, copy 'a')
; @ eg teu25
func fun()->(user String? s)
; @ eg teu26
func deleting()
    owner String? s
func fun()->(user String? s)
    s := _
    deleting()
; @ eg teu27
func fun(owner String so)->(user String? s)
    s := _
; @ eg teu28
func fun()->(user String? s)
    owner String? so
    s := _
; @ eg teu29
struct Test
    owner String? s
func fun(owner Test? t, user String s)
    t := _
    s.set(copy 0, copy 'a')
; @ eg teu30
struct Other
    owner String? s
struct Test
    owner Other? o
func fun(owner Test? t, user String s)
    t := _
    s.set(copy 0, copy 'a')
; @ eg teu31
struct Base
    owner String? s
struct Test(Base)
struct Other(Base)
    owner File? f
func fun(owner Test? t, user String s, user File f)
    t := _
    f.putc(copy 'a')
    s.set(copy 0, copy 'a')
; @ eg teu32
struct Base
    var Int x
struct Test(Base)
    owner String? s
func fun(owner Base? b, user String s)
    b := _
    s.set(copy 0, copy 'a')
; @ eg teu33
struct Test{Generic}
    owner Generic? x
func fun(owner Test?{File} t, user File f)
    t := _
    f.putc(copy 'a')
; @ eg teu34
struct Base{Generic}
    owner Generic? x
struct Test{Data}(Base{Data})
func fun(owner Test?{File} t, user File f)
    t := _
    f.putc(copy 'a')
; @ eg teu35
main
    owner String? so(owner String{12}())
    user String? su(user so)
    so := _
    su!.set(copy 0, copy 'a')
; @ ec teu36
assert str?
; @ ec teu37
assert-error str!.clear()
; @ ec teu38
if str?
; @ ec teu39
for _ in str!.length():2
; @ ec teu40
for _ in 2:str!.length()
; @ ec teu41
for _ in str!
; @ ec teu42
if b
    str!.clear()
; @ ec teu43
if false
    str := ostr
str!.clear()
; @ ec teu44
str := ostr
do
    str!.clear()
    ostr := _
    if b
        continue
    str := ostr
; @ ec teu45
str := ostr
try
    ostr := _
    if b
        raise
    str := ostr
str!.clear()
; @ eg teu46
func fun(user String sin)->(user String? sout)
    if false
        sout := sin
; @ eg teu47
func fun(user String sin)->(user String? sout)
    if true
        return
    sout := sin
; @ eg tev0
func fun(var String s)
func error(user String s)
    fun(var s)
; @ eg tev1
func fun(owner String s)
func error(var String s)
    fun(owner s)
; @ eg tev2
func error(var String a, owner String b)
    a := b
; @ eg tev3
func error()->(var String s)
; @ eg tee0
struct Error
    weak String s
; @ eg tee1
struct Error
    owner String s
    new()
; @ eg tee2
struct Error
    weak String s
    new(strong String s)
        self.s!.clear()
        self.s := s
; @ eg tee3
struct Error
    owner String s
    new()
        self.fun()
        self.s := String{12}()
    func user fun()
        self.s.clear()
; @ eg tee4
struct Error
    owner String s
    new()
        error(user self)
        self.s := String{12}()
func error(user Error e)
    e.s.clear()
; @ eg tee5
struct Error
    owner String s
    new()
        if false
            self.s := String{12}()
; @ eg tee6
struct Error
    owner String s
    new() _
func Error.new()
; @ ec tec0
str := str
; @ eg tec1
struct Error
    user String s
; @