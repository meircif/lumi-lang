~~~ TL5 compiler - Syntax tree type ~~~
module tl5-compiler

 ~~~ Type node in the syntax tree ~~~
class TypeData(SyntaxTreeNamespace)
  owner String name
  user ModuleMembers my-module
  owner TypeInstance base-type
  owner List{String} parameters
  owner NameMap{SyntaxTreeFunction} dynamic-base-methods
  user SyntaxTreeConstructor constructor
  var Bool is-primitive
  var Bool is-dynamic
  var Bool is-ordered
  var Bool is-delete-mocked
  var Bool ordering
  
  func inst parse-new(copy Bool is-dynamic)->(owner TypeData new-node)
    new-node := TypeData()
    new-node.parse(copy is-dynamic)
  
  func inst parse(copy Bool is-dynamic)
    self.is-dynamic := is-dynamic
    self.set-location()
    self.my-module := glob.current-module
    read-new(user "({")->(owner self.name)
    self.add-type(user self.my-module)
    if glob.last-char = '{'
      self.parameters := List{String}()
      do
        owner String name
        read-new(user ":}")->(owner name)
        if not is-legal-name(user name, copy NameGroup.TYPE)
          self.syntax-error(user "illegal type parameter name", user name)
        self.parameters.add(owner name)
        while glob.last-char = ':'
      if glob.last-char != '}'
        self.syntax-error-c(user "expected \"}\" after type parameters, got")
      read-c()
    if glob.last-char = '('
      self.base-type := TypeInstance()
      self.base-type.parse(user ")", user self, user _)
      if glob.last-char != ')'
        self.syntax-error-c(user "expected \")\" after base type, got")
      read-c()
    self.indentation-spaces := 2
    self.parse-block-children(user self, user _)
    self.indentation-spaces := 0
  
  func inst is-base-dynamic()->(var Bool base-dynamic)
    base-dynamic := false
    if self.base-type?
      base-dynamic := self.base-type.type-data.is-dynamic
  
  func inst add-type(user ModuleMembers my-module)
    if not is-legal-name(user self.name, copy NameGroup.TYPE)
      self.syntax-error(user "illegal type name", user self.name)
    if glob.find-type(user self.name)?
      self.syntax-error(user "redefinition of type", user self.name)
    if glob.current-module.enum-map.find(user self.name)?
      self.syntax-error(user "type name overrides Enum", user self.name)
    my-module.type-map.add(user self.name, user self)
  
  func dynamic parse-child(user String keyword)
    if self.parse-if-function(user keyword, user self)
      return
    
    if keyword.equal(user "new")
      if glob.last-char != '('
        self.syntax-error-c(user "expected \"(\" after \"new\", got")
      if self.constructor?
        self.syntax-error(
            user "constructor already defined for type", user self.name)
      owner SyntaxTreeConstructor constructor
      self.constructor := SyntaxTreeConstructor.parse-new(
          user _, user self)->(owner constructor)
      self.functions.add(owner constructor)
      
    else
      self.syntax-error(user "unknown keyword", user keyword)
  
  func inst is-same(user TypeData other)->(var Bool is-same)
    is-same := self is other or
        ((self is glob.type-int or self is glob.type-char) and
        (other is glob.type-int or other is glob.type-char))
  
  func inst new-type-instance()->(owner TypeInstance type-instance)
    type-instance := TypeInstance()
    type-instance.type-data := self
  
  func inst self-type-instance()->(owner TypeInstance type-instance)
    self.new-type-instance()->(owner type-instance)
    if self.parameters?
      type-instance.parameters := List{TypeInstance}()
      for parameter-name in self.parameters.iter()
        new TypeInstance parameter
        parameter.type-data := glob.type-generic
        string-new-copy(user parameter-name)->(owner parameter.name)
        type-instance.parameters.add(owner parameter)
  
  func dynamic get-parent-type()->(user TypeData parent-type)
    parent-type := self
  
  func inst find-field(user String name)->(
      user SyntaxTreeVariable field, var Int bases)
    user TypeData type-data(user self)
    bases := 0
    do
      while type-data?
      for variable in type-data.variables.iter()
        if variable.name.equal(user name)
          field := variable
          return
      while type-data.base-type?
      type-data := type-data.base-type.type-data
      bases += 1
    field := _
  
  func inst find-meth(user String name)->(
      user SyntaxTreeFunction method, var Int bases)
    user TypeData type-data(user self)
    bases := 0
    do
      while type-data?
      for function in type-data.functions.iter()
        if function.name.equal(user name)
          method := function
          return
      while type-data.base-type?
      type-data := type-data.base-type.type-data
      bases += 1
    method := _
  
  func inst order-bases(user List{TypeData} ordered-list)->(
      var Bool recursion-error)
    recursion-error := false
    if self.is-ordered
      return
    if self.ordering
      self.print-syntax-error-header()
      print-msg-with-item(user "recursive declaration of type", user self.name)
      recursion-error := true
      return
    
    self.ordering := true
    
    ; order base type
    if self.base-type?
      glob.current-module := self.my-module
      self.base-type.link-types(user self)
      glob.current-module := _
      if self.base-type.type-data.order-bases(user ordered-list)->(
          var recursion-error)
        print-msg-with-item(user ", extended by type", user self.name)
        return
    
    ; order complex fields
    for variable in self.variables.iter()
      if variable.access = Access.VAR
        glob.current-module := self.my-module
        variable.type-instance.link-types(user self)
        glob.current-module := _
        if not variable.type-instance.type-data.is-primitive and
            variable.type-instance.type-data is-not glob.type-generic
          if variable.type-instance.type-data.order-bases(user ordered-list)->(
              var recursion-error)
            print-msg-with-item(user ", variable of type", user self.name)
            return
    
    ordered-list.add(owner glob.root.types.remove(user self))
    self.is-ordered := true
    
    ; init `self.dynamic-base-methods` and test override methods
    if self.is-dynamic
      self.dynamic-base-methods := NameMap{SyntaxTreeFunction}()
    for function in self.functions.iter()
      user SyntaxTreeFunction method
      var Int bases
      if self.base-type?
        self.base-type.type-data.find-meth(user function.name)->(
            user method, var bases)
      if method?
        function.compare(user method)
        if function.is-dynamic
          function.dynamic-base-method := method.dynamic-base-method
          function.dynamic-base-count := method.dynamic-base-count + bases + 1
      else-if function.is-dynamic
        function.dynamic-base-method := function
        self.dynamic-base-methods.add(user function.name, user function)
  
  func dynamic link-types()
    glob.current-module := self.my-module
    if self.base-type?
      self.base-type.link-types(user self)
      if self.base-type.type-data.parameters? and
          not self.base-type.parameters?
        self.syntax-error(
            user "no parameter given for type with parameters",
            user self.base-type.type-data.name)
    base()
    glob.current-module := _
  
  func dynamic analyze()
    glob.current-module := self.my-module
    if self.base-type?
      self.base-type.analyze-lengths(user self, copy true)
    if not self.base-type? and self.variables.is-empty()
      self.syntax-error(user "type with no fields", user self.name)
    if self.is-dynamic and not self.is-base-dynamic()
      var ListIterator{SyntaxTreeFunction} iter(user self.functions)
      do
        if not iter.has()
          self.syntax-error(
              user "class with no dynamic methods", user self.name)
        while not iter.get().is-dynamic
        iter.next()
    base()
    glob.current-module := _
  
  func inst write-cname()
    if self.my-module?
      self.my-module.write-prefix()
    write-cname(user self.name)
  
  func dynamic write-declaration()
    ; typedef struct `name` `name`;
    ; typedef struct `name`_Dynamic `name`_Dynamic;
    write(user "\ntypedef struct ")
    self.write-cname()
    write(user " ")
    self.write-cname()
    write(user ";\n")
    if self.is-dynamic
      write(user "\ntypedef struct ")
      self.write-cname()
      write(user "_Dynamic ")
      self.write-cname()
      write(user "_Dynamic;\n")
  
  func dynamic write()
    ; struct `name` {
    ;   `variables...`
    ; };
    ; struct `name`_Dynamic {
    ;   `dynamic-function-pointers...`
    ; };
    write(user "\nstruct ")
    self.write-cname()
    write(user " {\n")
    self.indentation-spaces := 2
    if self.base-type?
      self.write-spaces()
      self.base-type.type-data.write-cname()
      write(user " _base;\n")
    self.write-children(user self.variables)
    write(user "};\n")
    if self.is-dynamic
      write(user "\nstruct ")
      self.write-cname()
      write(user "_Dynamic {\n")
      if self.is-base-dynamic()
        self.write-spaces()
        self.base-type.type-data.write-cname()
        write(user "_Dynamic _base;\n")
      else
        self.write-spaces()
        write(user "Dynamic_Del _del;\n")
      for method in self.dynamic-base-methods.iter()
        self.write-spaces()
        method.write-pointer()
        write(user ";\n")
      write(user "};\n")
    self.indentation-spaces := 0
  
  func dynamic write-methods-declaration()
    self.write-functions-declaration()
    ; void `cname`_Del(`cname`* self);
    write(user "\nvoid ")
    self.write-cname()
    write(user "_Del(")
    self.write-cname()
    write(user "* self);\n")
  
  func dynamic write-global()
    write(user "\n")
    if self.is-dynamic
      ; `name`_Dynamic `name`_dynamic = {`dynamic-functions...`};
      self.write-cname()
      write(user "_Dynamic ")
      self.write-cname()
      write(user "_dynamic = ")
      self.write-dynamic-init(user self)
    else
      ; Generic_Type_Dynamic `name`_dynamic = {(Dynamic_Del)`name`_Del};
      write(user "Generic_Type_Dynamic ")
      self.write-cname()
      write(user "_dynamic = {(Dynamic_Del)")
      self.write-cname()
      write(user "_Del}")
    write(user ";\n")
  
  func inst write-dynamic-init(user TypeData type-data)
    write(user "{")
    if type-data.is-base-dynamic()
      self.write-dynamic-init(user type-data.base-type.type-data)
    else
      write(user "(Dynamic_Del)")
      self.write-cname()
      write(user "_Del")
    for base-method in type-data.dynamic-base-methods.iter()
      user SyntaxTreeFunction method
      self.find-meth(user base-method.name)->(user method)
      write(user ", ")
      if method is-not base-method
        write(user "(Func)")
      method.parent-type.write-cname()
      write(user "_")
      if method.mocker-function?
        write-cname(user method.mocker-function.name)
      else
        write-cname(user method.name)
    write(user "}")
  
  func dynamic write-methods-body()
    self.write-children(user self.functions)
    ; void `cname`_Del(`cname`* self) {
    ;   if (self == NULL) return;
    ;   `base`_Del(self);
    ;   ...
    ; }
    write(user "\nvoid ")
    self.write-cname()
    write(user "_Del(")
    self.write-cname()
    write(user "* self) {\n")
    write(user "  if (self == NULL) return;\n")
    if self.base-type?
      write(user "  ")
      self.base-type.type-data.write-cname()
      write(user "_Del(&(self->_base));\n")
    if self.is-delete-mocked
      write(user "  IGNORE_ERRORS( ")
      self.write-cname()
      write(user "_MockDel(self) )\n")
    self.write-cleanup(user self)
    write(user "}\n")
  
  func dynamic write-me(user TypeWriter type-writer)
    type-writer.write(user self)


class TypeWriter
  var Int dummy
  func dynamic write(user TypeData type-data)
    raise

class TypeDeclarationWriter(TypeWriter)
  func dynamic write(user TypeData type-data)
    type-data.write-declaration()

class TypeMethodsDeclarationWriter(TypeWriter)
  func dynamic write(user TypeData type-data)
    type-data.write-methods-declaration()

class TypeGlobalWriter(TypeWriter)
  func dynamic write(user TypeData type-data)
    type-data.write-global()

class TypeMethodsBodyWriter(TypeWriter)
  func dynamic write(user TypeData type-data)
    type-data.write-methods-body()
