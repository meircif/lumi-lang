~~~ Math functions for integers. ~~~
module math

~~~ Return the absolute value of `x` ~~~
func abs(copy Sint64 x)->(var Sint64 res)
    if x >= 0
        res := x
    else
        res := - x


~~~ Return `x` with the sign of `sign`,
if sign is `0` no sign change is made to `x` ~~~
func copysign(copy Sint64 x, copy Sint64 sign)->(var Sint64 res)
    if (x >= 0 and sign >= 0) or (x < 0 and sign <= 0)
        res := x
    else
        res := - x


~~~ Return `x` raised to power `exp`, fail if `exp` is negative,
if `x` and `exp` are zero the result is `1` ~~~
func ! power(copy Sint64 x, copy Uint64 exp)->(var Sint64 res)
    res := 1
    for n in exp
        res := res * x


~~~ Return `x`!, fail if `x` is negative ~~~
func ! factorial(copy Uint64 x)->(var Uint64 res)
    res := 1
    for n in 2:x + 1
        res := res * n


struct IntBox
    var Sint64 value

    func user set(copy Sint64 value)
        self.value := value


class IntIterator
    ~~~ in TL5 a class must contain at least one field. ~~~
    var Uint8 dummy

    ~~~ Is called once before any iteration step.
    Iteration continues only if "has" returns true, in such case
    "value" is set to the iteration value. ~~~
    func dynamic user? ! step()->(user IntBox? value, var Bool has)
        value := _
        raise! "unimplemented dynamic method 'step'"


~~~ Return the sum of all integers in `iter` ~~~
func ! sum(user IntIterator iter)->(var Sint64 res)
    res := 0
    for box in iter!
        res += box!.value
